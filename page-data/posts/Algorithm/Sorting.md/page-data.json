{"componentChunkName":"component---src-templates-post-index-tsx","path":"/posts/Algorithm/Sorting.md/","result":{"data":{"markdownRemark":{"id":"f3fa286d-64fa-5dfa-b43e-5772a9b71604","html":"<blockquote>\n<p>면접에서 탈탈 털린 후 작성한 정렬 관련 알고리즘을 총정리</p>\n</blockquote>\n<ul>\n<li><a href=\"#1-bubble-sort-%EA%B1%B0%ED%92%88-%EC%A0%95%EB%A0%AC\">1. Bubble Sort (거품 정렬)</a>\n<ul>\n<li><a href=\"#11-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">1.1. 동작 과정</a></li>\n<li><a href=\"#12-%EB%B3%B5%EC%9E%A1%EB%8F%84\">1.2. 복잡도</a></li>\n<li><a href=\"#13-python-%EA%B5%AC%ED%98%84\">1.3. Python 구현</a></li>\n</ul>\n</li>\n<li><a href=\"#2-selection-sort-%EC%84%A0%ED%83%9D-%EC%A0%95%EB%A0%AC\">2. Selection Sort (선택 정렬)</a>\n<ul>\n<li><a href=\"#21-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">2.1. 동작 과정</a></li>\n<li><a href=\"#22-%EB%B3%B5%EC%9E%A1%EB%8F%84\">2.2. 복잡도</a></li>\n<li><a href=\"#23-python-%EA%B5%AC%ED%98%84\">2.3. Python 구현</a></li>\n</ul>\n</li>\n<li><a href=\"#3-insertion-sort-%EC%82%BD%EC%9E%85-%EC%A0%95%EB%A0%AC\">3. Insertion Sort (삽입 정렬)</a>\n<ul>\n<li><a href=\"#31-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">3.1. 동작 과정</a></li>\n<li><a href=\"#32-%EB%B3%B5%EC%9E%A1%EB%8F%84\">3.2. 복잡도</a></li>\n<li><a href=\"#33-python-%EA%B5%AC%ED%98%84\">3.3. Python 구현</a></li>\n</ul>\n</li>\n<li><a href=\"#4-shell-sort-%EC%85%B8-%EC%A0%95%EB%A0%AC\">4. Shell Sort (셸 정렬)</a>\n<ul>\n<li><a href=\"#41-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">4.1. 동작 과정</a></li>\n<li><a href=\"#42-%EB%B3%B5%EC%9E%A1%EB%8F%84\">4.2. 복잡도</a></li>\n<li><a href=\"#43-python-%EA%B5%AC%ED%98%84\">4.3. Python 구현</a></li>\n</ul>\n</li>\n<li><a href=\"#5-heap-sort-%ED%9E%99-%EC%A0%95%EB%A0%AC\">5. Heap Sort (힙 정렬)</a></li>\n<li><a href=\"#6-merge-sort-%EB%B3%91%ED%95%A9-%EC%A0%95%EB%A0%AC\">6. Merge Sort (병합 정렬)</a>\n<ul>\n<li><a href=\"#61-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">6.1. 동작 과정</a></li>\n<li><a href=\"#62-%EB%B3%B5%EC%9E%A1%EB%8F%84\">6.2. 복잡도</a></li>\n<li><a href=\"#63-python-%EA%B5%AC%ED%98%84\">6.3. Python 구현</a></li>\n</ul>\n</li>\n<li><a href=\"#7-quick-sort-%ED%80%B5-%EC%A0%95%EB%A0%AC\">7. Quick Sort (퀵 정렬)</a>\n<ul>\n<li><a href=\"#71-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">7.1. 동작 과정</a></li>\n<li><a href=\"#72-%EB%B3%B5%EC%9E%A1%EB%8F%84\">7.2. 복잡도</a></li>\n<li><a href=\"#73-python-%EA%B5%AC%ED%98%84\">7.3. Python 구현</a></li>\n</ul>\n</li>\n<li><a href=\"#8-counting-sort-%EA%B3%84%EC%88%98-%EC%A0%95%EB%A0%AC\">8. Counting Sort (계수 정렬)</a>\n<ul>\n<li><a href=\"#81-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">8.1. 동작 과정</a></li>\n<li><a href=\"#82-%EB%B3%B5%EC%9E%A1%EB%8F%84\">8.2. 복잡도</a></li>\n<li><a href=\"#83-python-%EA%B5%AC%ED%98%84\">8.3. Python 구현</a></li>\n</ul>\n</li>\n<li><a href=\"#9-%EB%B3%B5%EC%9E%A1%EB%8F%84-%EB%B9%84%EA%B5%90\">9. 복잡도 비교</a></li>\n</ul>\n<h1 id=\"1-bubble-sort-거품-정렬\" style=\"position:relative;\"><a href=\"#1-bubble-sort-%EA%B1%B0%ED%92%88-%EC%A0%95%EB%A0%AC\" aria-label=\"1 bubble sort 거품 정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Bubble Sort (거품 정렬)</h1>\n<p>가장 시간복잡도가 높은 알고리즘이기 때문에 사용을 추천하지 않는다.<br>\n단 정렬이 완료되었는지를 루프마다 판단할 수 있어서, 거의 정렬이 된 데이터에 대해서는 유효한 성능을 낼 수 있다.</p>\n<h2 id=\"11-동작-과정\" style=\"position:relative;\"><a href=\"#11-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\" aria-label=\"11 동작 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1. 동작 과정</h2>\n<ol>\n<li>0 ~ n-1 번 인덱스에 대해서 현재 숫자와 뒤의 숫자를 비교한다. 현재 숫자가 더 클 경우 스왑한다.<br>\n그 결과 뒤에서 첫번째 수는 배열에서 첫번째로 큰 수가 자리한다.</li>\n<li>0 ~ n-2 번 인덱스에 대해서 현재 숫자와 뒤의 숫자를 비교한다. 현재 숫자가 더 클 경우 스왑한다.<br>\n그 결과 뒤에서 두번째 수는 배열에서 두번째로 큰 수가 자리한다.<br>\n...</li>\n<li>0 ~ 0 번 인덱스에 대해서 대해서 현재 숫자와 뒤의 숫자를 비교한다. 현재 숫자가 더 클 경우 스왑한다.<br>\n그 결과 뒤에서 N-1 번째 수는 배열에서 N-1번째로 큰 수가 자리한다.</li>\n</ol>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/43fda64724febd98f63199eb005c6bcf/a6d32/bubble_sort_image.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 114.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAXABQDASIAAhEBAxEB/8QAGQABAAMBAQAAAAAAAAAAAAAAAAIEBQED/8QAFgEBAQEAAAAAAAAAAAAAAAAAAQID/9oADAMBAAIQAxAAAAHSlw53GcWfoDaBX//EABoQAAMBAQEBAAAAAAAAAAAAAAABAhESExT/2gAIAQEAAQUCdMi9oWi62fozyZCro//EABoRAAICAwAAAAAAAAAAAAAAAAACARIQMWH/2gAIAQMBAT8B7BYVa6x//8QAGhEBAAEFAAAAAAAAAAAAAAAAAQAQEiExQf/aAAgBAgEBPwEeMtjndP/EAB0QAAEDBQEAAAAAAAAAAAAAAAIAEBEBITEyQpH/2gAIAQEABj8CvUfFEi3a6bUVgYb/xAAdEAADAAICAwAAAAAAAAAAAAAAAREhQTGRgaHh/9oACAEBAAE/IV89kO6UkxcGmeUFTFs45ZDY9wf1WJrgjVFwf//aAAwDAQACAAMAAAAQcDCA/8QAGREBAAIDAAAAAAAAAAAAAAAAAQARECFB/9oACAEDAQE/EEdM1C3GDZw//8QAGxEAAQQDAAAAAAAAAAAAAAAAAQAQESFhcfD/2gAIAQIBAT8QsI77aOQRxpMN/8QAHhABAAMAAgIDAAAAAAAAAAAAAQARITFBUWGRodH/2gAIAQEAAT8QSaPyp3kLBxuxlqNdc2kVlJq3BANW7Ssubu1/r93CCtW/JGVMVqt6hTXNrP/Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"bubble sort image\" title=\"\" src=\"/TIL/static/43fda64724febd98f63199eb005c6bcf/b4294/bubble_sort_image.jpg\" srcset=\"/TIL/static/43fda64724febd98f63199eb005c6bcf/75985/bubble_sort_image.jpg 150w,\n/TIL/static/43fda64724febd98f63199eb005c6bcf/f93b5/bubble_sort_image.jpg 300w,\n/TIL/static/43fda64724febd98f63199eb005c6bcf/b4294/bubble_sort_image.jpg 600w,\n/TIL/static/43fda64724febd98f63199eb005c6bcf/a6d32/bubble_sort_image.jpg 652w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<h2 id=\"12-복잡도\" style=\"position:relative;\"><a href=\"#12-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"12 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2. 복잡도</h2>\n<ul>\n<li><strong>공간복잡도 O(1)</strong><br>\n주어진 배열 내에서 스왑하며 연산이 이뤄지기 때문에 추가 메모리를 필요로 하지 않는다.</li>\n<li><strong>시간복잡도 O(n**2)</strong><br>\n비교와 스왑 연산이 (n-1 + n-2 + n-3 + .... + 3 + 2 + 1)회 일어난다.<br>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/640be/bubble_sort_time_complexity.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 20%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAEABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3QUH/8QAFhABAQEAAAAAAAAAAAAAAAAAABFB/9oACAEBAAEFAtR//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFRABAQAAAAAAAAAAAAAAAAAAARD/2gAIAQEABj8CL//EABkQAAIDAQAAAAAAAAAAAAAAAAABESFBcf/aAAgBAQABPyFrRkXp0z//2gAMAwEAAgADAAAAEHPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxAAAgIDAQAAAAAAAAAAAAAAAAERgSFBUWH/2gAIAQEAAT8QgV22NY5axeiz/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"bubble sort time complexity\" title=\"\" src=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/b4294/bubble_sort_time_complexity.jpg\" srcset=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/75985/bubble_sort_time_complexity.jpg 150w,\n/TIL/static/6612efa9c4891b8a1e34a1d50906b391/f93b5/bubble_sort_time_complexity.jpg 300w,\n/TIL/static/6612efa9c4891b8a1e34a1d50906b391/b4294/bubble_sort_time_complexity.jpg 600w,\n/TIL/static/6612efa9c4891b8a1e34a1d50906b391/640be/bubble_sort_time_complexity.jpg 608w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span><br>\n(단, 최선의 경우 O(n)의 복잡도를 가진다.)</li>\n</ul>\n<h2 id=\"13-python-구현\" style=\"position:relative;\"><a href=\"#13-python-%EA%B5%AC%ED%98%84\" aria-label=\"13 python 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.3. Python 구현</h2>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">bubble_sort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n    N <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span>\r\n\r\n    <span class=\"token comment\"># 배열의 길이에 대응하는 횟수만큼 루프를 돈다.</span>\r\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>N<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n        is_swapped <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span>  <span class=\"token comment\"># 루프에 대해서 스왑여부를 판단하는 플래그</span>\r\n\r\n        <span class=\"token comment\"># 스왑여부를 탐색하는 배열 길이를 하나씩 줄여나간다.</span>\r\n        <span class=\"token comment\"># 루프를 돌 때마다, 탐색한 배열에서 가장 큰 숫자가 순서대로 뒷쪽에 쌓이기 때문.</span>\r\n        <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>N <span class=\"token operator\">-</span> i <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n            <span class=\"token keyword\">if</span> nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> arr<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\r\n                arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token comment\"># 현재 숫자가 뒤의 숫자보다 클 경우, 스왑</span>\r\n                is_swapped <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>   <span class=\"token comment\"># 플래그를 바꿔준다</span>\r\n\r\n        <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> is_swapped<span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 루프에 대해서 한 번도 스왑이 일어나지 않았으면, 정렬 완료</span>\r\n            <span class=\"token keyword\">return</span> nums\r\n\r\n    <span class=\"token keyword\">return</span> nums</code></pre></div>\n<h1 id=\"2-selection-sort-선택-정렬\" style=\"position:relative;\"><a href=\"#2-selection-sort-%EC%84%A0%ED%83%9D-%EC%A0%95%EB%A0%AC\" aria-label=\"2 selection sort 선택 정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Selection Sort (선택 정렬)</h1>\n<h2 id=\"21-동작-과정\" style=\"position:relative;\"><a href=\"#21-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\" aria-label=\"21 동작 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. 동작 과정</h2>\n<ol>\n<li>0 ~ n-1번 인덱스 중 가장 작은 값을 찾아 0번 인덱스와 스왑한다.</li>\n<li>1 ~ n-1번 인덱스 중 가장 작은 값을 찾아 1번 인덱스와 스왑한다.<br>\n...</li>\n<li>n-2 ~ n-1번 인덱스 중 가장 작은 값을 찾아 n-2번 인덱스와 스왑한다.</li>\n</ol>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 512px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/73b4107b21dbe5e28b41a1735c712afe/36dd4/selection_sort_image.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 142.00000000000003%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAcABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAEDAgX/xAAVAQEBAAAAAAAAAAAAAAAAAAABAP/aAAwDAQACEAMQAAAB9tZGiJZ0nYH/xAAYEAEBAQEBAAAAAAAAAAAAAAABEDEAAv/aAAgBAQABBQJ2MOYZ6v8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGBAAAgMAAAAAAAAAAAAAAAAAIDEQEUH/2gAIAQEABj8CdBkof//EABwQAAIDAAMBAAAAAAAAAAAAAAABESExQWGBUf/aAAgBAQABPyGgK7fYsPM9nsvhixJUFw1xMqglOiSgWH//2gAMAwEAAgADAAAAEDzHDP/EABcRAAMBAAAAAAAAAAAAAAAAAAEQEUH/2gAIAQMBAT8Q1WmL/8QAFxEAAwEAAAAAAAAAAAAAAAAAARARQf/aAAgBAgEBPxDFIKv/xAAeEAEAAwACAwEBAAAAAAAAAAABABEhMUFRYXGBof/aAAgBAQABPxBgU89l3C22ngY/2cE9XDMRUOL4US1cX3XEJEXZPSMd78govw8TICCuCKNl5CACf//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"selection sort image\" title=\"\" src=\"/TIL/static/73b4107b21dbe5e28b41a1735c712afe/36dd4/selection_sort_image.jpg\" srcset=\"/TIL/static/73b4107b21dbe5e28b41a1735c712afe/75985/selection_sort_image.jpg 150w,\n/TIL/static/73b4107b21dbe5e28b41a1735c712afe/f93b5/selection_sort_image.jpg 300w,\n/TIL/static/73b4107b21dbe5e28b41a1735c712afe/36dd4/selection_sort_image.jpg 512w\" sizes=\"(max-width: 512px) 100vw, 512px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<h2 id=\"22-복잡도\" style=\"position:relative;\"><a href=\"#22-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"22 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2. 복잡도</h2>\n<ul>\n<li><strong>공간복잡도 O(1)</strong><br>\n주어진 배열 내에서 스왑하며 연산이 이뤄지기 때문에 추가 메모리를 필요로 하지 않는다.</li>\n<li><strong>시간복잡도 O(n**2)</strong><br>\n비교 연산이 (n-1 + n-2 + n-3 + .... + 3 + 2 + 1)회 일어나고, n-1번의 스왑 연산이 일어난다.<br>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/640be/bubble_sort_time_complexity.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 20%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAEABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3QUH/8QAFhABAQEAAAAAAAAAAAAAAAAAABFB/9oACAEBAAEFAtR//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFRABAQAAAAAAAAAAAAAAAAAAARD/2gAIAQEABj8CL//EABkQAAIDAQAAAAAAAAAAAAAAAAABESFBcf/aAAgBAQABPyFrRkXp0z//2gAMAwEAAgADAAAAEHPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxAAAgIDAQAAAAAAAAAAAAAAAAERgSFBUWH/2gAIAQEAAT8QgV22NY5axeiz/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"bubble sort time complexity\" title=\"\" src=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/b4294/bubble_sort_time_complexity.jpg\" srcset=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/75985/bubble_sort_time_complexity.jpg 150w,\n/TIL/static/6612efa9c4891b8a1e34a1d50906b391/f93b5/bubble_sort_time_complexity.jpg 300w,\n/TIL/static/6612efa9c4891b8a1e34a1d50906b391/b4294/bubble_sort_time_complexity.jpg 600w,\n/TIL/static/6612efa9c4891b8a1e34a1d50906b391/640be/bubble_sort_time_complexity.jpg 608w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span></li>\n</ul>\n<h2 id=\"23-python-구현\" style=\"position:relative;\"><a href=\"#23-python-%EA%B5%AC%ED%98%84\" aria-label=\"23 python 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3. Python 구현</h2>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">selection_sort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n    N <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span>\r\n\r\n    <span class=\"token comment\"># N-1 번 최솟값을 찾아낸다.</span>\r\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>N <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n        min_idx <span class=\"token operator\">=</span> i <span class=\"token comment\"># i번째 숫자를 포함(기준으로 삼음)</span>\r\n\r\n        <span class=\"token comment\"># i+1번째부터 순회하며 i번째 가장 작은 값을 탐색</span>\r\n        <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> N<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n            <span class=\"token keyword\">if</span> nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">[</span>min_idx<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\r\n                min_idx <span class=\"token operator\">=</span> j\r\n\r\n        nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>min_idx<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>min_idx<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token comment\"># i번째 숫자와 i번째 작은 숫자를 스왑</span>\r\n    <span class=\"token keyword\">return</span> nums</code></pre></div>\n<h1 id=\"3-insertion-sort-삽입-정렬\" style=\"position:relative;\"><a href=\"#3-insertion-sort-%EC%82%BD%EC%9E%85-%EC%A0%95%EB%A0%AC\" aria-label=\"3 insertion sort 삽입 정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Insertion Sort (삽입 정렬)</h1>\n<p>간단하게 말해 배열의 앞부분을 정렬된 배열, 뒷 부분을 정렬되지 않은 배열로 구분한다. 그리고 정렬되지 않은 배열의 가장 앞에 수를 꺼내서 정렬된 배열의 적절한 위치로 삽입한다.</p>\n<h2 id=\"31-동작-과정\" style=\"position:relative;\"><a href=\"#31-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\" aria-label=\"31 동작 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1. 동작 과정</h2>\n<ol>\n<li>0 ~ 1번 인덱스 중 1번 인덱스 값이 들어갈 위치를 찾아 넣는다.</li>\n<li>0 ~ 2번 인덱스 중 2번 인덱스 값이 들어갈 위치를 찾아 넣는다.<br>\n...</li>\n<li>0 ~ n-1번 인덱스 중 n-1번 인덱스 값이 들어갈 위치를 찾아 넣는다.</li>\n</ol>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 485px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/613f10142617d0d176187dfbfc351b98/0d3a1/insertion_sort_image.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 101.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAIDBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAABAP/aAAwDAQACEAMQAAAB9TbPMelJEhSI/8QAGxAAAwACAwAAAAAAAAAAAAAAAAERAhASEyH/2gAIAQEAAQUC7Kz0uQso9NU4o//EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/ASP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAZEAACAwEAAAAAAAAAAAAAAAAAERAhMTL/2gAIAQEABj8CueRJTZh//8QAHhAAAgEDBQAAAAAAAAAAAAAAAAERIUFREDGxwdH/2gAIAQEAAT8hVCnL60nIc3ss4xgVVKuN1FRhsJI//9oADAMBAAIAAwAAABCAyIP/xAAYEQEAAwEAAAAAAAAAAAAAAAABABExEP/aAAgBAwEBPxBWhy6yUM//xAAYEQACAwAAAAAAAAAAAAAAAAAAEQEQMf/aAAgBAgEBPxBrbUH/xAAfEAEAAgICAgMAAAAAAAAAAAABABEhMUHhUXFhkaH/2gAIAQEAAT8QdKIKCFmagvk/Op8z66lhlt4+fXiZKcA3Kvbeow8gLGupkYNwMWWspStwGgOtq8e5/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"insertion sort image\" title=\"\" src=\"/TIL/static/613f10142617d0d176187dfbfc351b98/0d3a1/insertion_sort_image.jpg\" srcset=\"/TIL/static/613f10142617d0d176187dfbfc351b98/75985/insertion_sort_image.jpg 150w,\n/TIL/static/613f10142617d0d176187dfbfc351b98/f93b5/insertion_sort_image.jpg 300w,\n/TIL/static/613f10142617d0d176187dfbfc351b98/0d3a1/insertion_sort_image.jpg 485w\" sizes=\"(max-width: 485px) 100vw, 485px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<h2 id=\"32-복잡도\" style=\"position:relative;\"><a href=\"#32-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"32 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2. 복잡도</h2>\n<ul>\n<li><strong>공간복잡도 O(1)</strong><br>\n주어진 배열 내에서 스왑하며 연산이 이뤄지기 때문에 추가 메모리를 필요로 하지 않는다.</li>\n<li><strong>시간복잡도 O(n**2)</strong><br>\n비교 연산이 최대 (1 + 2 + 3 + .... + n-3 + n-2 + n-1)회 일어나고, n-1번의 스왑 연산이 일어난다.<br>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/640be/bubble_sort_time_complexity.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 20%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAEABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3QUH/8QAFhABAQEAAAAAAAAAAAAAAAAAABFB/9oACAEBAAEFAtR//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFRABAQAAAAAAAAAAAAAAAAAAARD/2gAIAQEABj8CL//EABkQAAIDAQAAAAAAAAAAAAAAAAABESFBcf/aAAgBAQABPyFrRkXp0z//2gAMAwEAAgADAAAAEHPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxAAAgIDAQAAAAAAAAAAAAAAAAERgSFBUWH/2gAIAQEAAT8QgV22NY5axeiz/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"bubble sort time complexity\" title=\"\" src=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/b4294/bubble_sort_time_complexity.jpg\" srcset=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/75985/bubble_sort_time_complexity.jpg 150w,\n/TIL/static/6612efa9c4891b8a1e34a1d50906b391/f93b5/bubble_sort_time_complexity.jpg 300w,\n/TIL/static/6612efa9c4891b8a1e34a1d50906b391/b4294/bubble_sort_time_complexity.jpg 600w,\n/TIL/static/6612efa9c4891b8a1e34a1d50906b391/640be/bubble_sort_time_complexity.jpg 608w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span><br>\n(단, 정렬되어 있는 값의 경우 비교 연산만 n-1번 이루어져 O(n)의 시간복잡도를 가진다.)</li>\n</ul>\n<h2 id=\"33-python-구현\" style=\"position:relative;\"><a href=\"#33-python-%EA%B5%AC%ED%98%84\" aria-label=\"33 python 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.3. Python 구현</h2>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">insertion_sort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n    N <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span>\r\n\r\n    <span class=\"token comment\"># 1 ~ n-1 번 인덱스에 대해서 반복</span>\r\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> N<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n        cur_num <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\r\n        j <span class=\"token operator\">=</span> i <span class=\"token operator\">-</span> <span class=\"token number\">1</span>\r\n\r\n        <span class=\"token comment\"># 왼쪽 배열에서 i번째 숫자가 들어갈 위치를 찾는다.</span>\r\n        <span class=\"token keyword\">while</span> j <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token keyword\">and</span> cur_num <span class=\"token operator\">&lt;</span> array<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\r\n            array<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> array<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token comment\"># 숫자를 하나씩 오른쪽으로 민다.</span>\r\n            j <span class=\"token operator\">=</span> j <span class=\"token operator\">-</span> <span class=\"token number\">1</span>\r\n\r\n        array<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> cur_num  <span class=\"token comment\"># i번째 숫자를 삽입</span>\r\n\r\n    <span class=\"token keyword\">return</span> nums</code></pre></div>\n<h1 id=\"4-shell-sort-셸-정렬\" style=\"position:relative;\"><a href=\"#4-shell-sort-%EC%85%B8-%EC%A0%95%EB%A0%AC\" aria-label=\"4 shell sort 셸 정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Shell Sort (셸 정렬)</h1>\n<p>삽입정렬을 보완하기 위한 알고리즘이다. 앞서 살펴본 것 처럼 쉘 알고리즘은 <strong>정렬이 잘 되어 있을수록 시간복잡도가 줄어든다.</strong> 비교연산을 해야할 횟수(거리)가 줄어들기 때문이다. 반대로 생각하면, <strong>정렬을 위해 비교해야할 거리가 클 수록 시간 복잡도가 늘어난다.</strong></p>\n<p>위와 같은 특징에서 착안해서, 쉘 정렬은 배열의 전체적인 정렬도를 점차 높이는 방법으로 삽입 정렬을 수행한다. gap만큼 떨어진 숫자들을 하나의 부분 배열로 간주해서 삽입 정렬을 수행하고, 이 gap을 점차 1까지 줄여나간다.</p>\n<h2 id=\"41-동작-과정\" style=\"position:relative;\"><a href=\"#41-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\" aria-label=\"41 동작 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.1. 동작 과정</h2>\n<ol>\n<li>gap의 초기 크기를 n // 2로 결정한다.</li>\n<li>gap ~ n-1번째 인덱스를 기준점으로 왼쪽 숫자들에 대해서 gap의 간격으로 부분배열을 만들고, 삽입정렬을 수행한다.</li>\n<li>gap의 크기를 2로 나눈다.</li>\n<li>gap의 크기가 1이 될 때까지 2 ~ 3의 과정을 반복한다.</li>\n</ol>\n<h2 id=\"42-복잡도\" style=\"position:relative;\"><a href=\"#42-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"42 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.2. 복잡도</h2>\n<ul>\n<li><strong>공간복잡도 O(1)</strong><br>\n주어진 배열 내에서 스왑하며 연산이 이뤄지기 때문에 추가 메모리를 필요로 하지 않는다.</li>\n<li><strong>시간복잡도 O(n**2)</strong><br>\n쉘 정렬과 동일하게 O(n**2)의 복잡도를 가진다.\r\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/640be/bubble_sort_time_complexity.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 20%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAEABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3QUH/8QAFhABAQEAAAAAAAAAAAAAAAAAABFB/9oACAEBAAEFAtR//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFRABAQAAAAAAAAAAAAAAAAAAARD/2gAIAQEABj8CL//EABkQAAIDAQAAAAAAAAAAAAAAAAABESFBcf/aAAgBAQABPyFrRkXp0z//2gAMAwEAAgADAAAAEHPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxAAAgIDAQAAAAAAAAAAAAAAAAERgSFBUWH/2gAIAQEAAT8QgV22NY5axeiz/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"bubble sort time complexity\" title=\"\" src=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/b4294/bubble_sort_time_complexity.jpg\" srcset=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/75985/bubble_sort_time_complexity.jpg 150w,\n/TIL/static/6612efa9c4891b8a1e34a1d50906b391/f93b5/bubble_sort_time_complexity.jpg 300w,\n/TIL/static/6612efa9c4891b8a1e34a1d50906b391/b4294/bubble_sort_time_complexity.jpg 600w,\n/TIL/static/6612efa9c4891b8a1e34a1d50906b391/640be/bubble_sort_time_complexity.jpg 608w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span><br>\n그러나 최선과 평균 시간 복잡도가 O(n*log n)이다.</li>\n</ul>\n<h2 id=\"43-python-구현\" style=\"position:relative;\"><a href=\"#43-python-%EA%B5%AC%ED%98%84\" aria-label=\"43 python 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.3. Python 구현</h2>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">shell_sort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n    N <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span>\r\n\r\n    gap <span class=\"token operator\">=</span> N <span class=\"token operator\">//</span> <span class=\"token number\">2</span>    <span class=\"token comment\"># 첫 gap은 배열 크기의 반으로 지정한다.</span>\r\n    <span class=\"token keyword\">while</span> gap <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># gap이 1이 될 때까지 줄여나간다.</span>\r\n\r\n        <span class=\"token comment\"># gap의 크기만큼 간격을 띄고 shell 정렬을 수행한다.</span>\r\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>gap<span class=\"token punctuation\">,</span> N<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n            cur_num <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\r\n            j <span class=\"token operator\">=</span> i <span class=\"token operator\">-</span> gap\r\n\r\n            cur_num <span class=\"token operator\">&lt;</span> array<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\r\n            <span class=\"token keyword\">while</span> j <span class=\"token operator\">>=</span> gap <span class=\"token keyword\">and</span> cur_num <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\r\n                array<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> array<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> gap<span class=\"token punctuation\">]</span>\r\n                j <span class=\"token operator\">-=</span> gap\r\n\r\n            array<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> cur_num\r\n        gap <span class=\"token operator\">//=</span> <span class=\"token number\">2</span>   <span class=\"token comment\"># gap은 2로 나눈 몫으로 줄여나간다</span></code></pre></div>\n<h1 id=\"5-heap-sort-힙-정렬\" style=\"position:relative;\"><a href=\"#5-heap-sort-%ED%9E%99-%EC%A0%95%EB%A0%AC\" aria-label=\"5 heap sort 힙 정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. Heap Sort (힙 정렬)</h1>\n<p><a href=\"https://github.com/Byongho96/TIL/blob/master/Data%20Structure/Heap.md\">자료구조 힙</a>을 이용한 정렬 방법이다.</p>\n<p>길이가 n인 heap 배열은 depth가 log n 이다.</p>\n<ul>\n<li>pop 연산 시, logN 번의 비교 및 치환이 일어난다.(Heapify)</li>\n<li>정렬을 위해서 N번의 pop 연산이 일어난다.</li>\n</ul>\n<p>따라서 힙을 이용한 연산의 시간 복잡도는 O(n * log n)dlek.</p>\n<h1 id=\"6-merge-sort-병합-정렬\" style=\"position:relative;\"><a href=\"#6-merge-sort-%EB%B3%91%ED%95%A9-%EC%A0%95%EB%A0%AC\" aria-label=\"6 merge sort 병합 정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. Merge Sort (병합 정렬)</h1>\n<p><strong>분할 정복법</strong> 중 하나의 큰 문제를 여러 개의 작은 문제로 쪼개서, 작은 문제를 해결한 결과를 모아서 큰 문제의 답을 얻는다. 분할 정복 특징 상, 재귀로 구현된다.</p>\n<h2 id=\"61-동작-과정\" style=\"position:relative;\"><a href=\"#61-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\" aria-label=\"61 동작 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6.1. 동작 과정</h2>\n<ol>\n<li>배열의 길이가 1이 될 때 까지, 반으로 쪼갠다.(분할)</li>\n<li>쪼개진 배열을 2개씩 비교 정렬하며 합친다.(병합)</li>\n</ol>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/327e829fdcf866ae04fa8b5dccfab88f/84f0d/merge_sort_image.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 101.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGQABAAIDAAAAAAAAAAAAAAAAAAECAwQF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAgH/2gAMAwEAAhADEAAAAezMkbIS46iOwA//xAAcEAACAgIDAAAAAAAAAAAAAAAAAQIREBIhIjH/2gAIAQEAAQUCZVC5z6T6kXsz/8QAFREBAQAAAAAAAAAAAAAAAAAAEEH/2gAIAQMBAT8BKf/EABURAQEAAAAAAAAAAAAAAAAAABBB/9oACAECAQE/ASH/xAAbEAACAgMBAAAAAAAAAAAAAAAAERAhASJRYf/aAAgBAQAGPwK0jVR7HB4Lj//EAB0QAAICAgMBAAAAAAAAAAAAAAERACExURBBYZH/2gAIAQEAAT8hU3DZQNuEAYjS70cw2T9gBsX4cOgA9qY6CvOP/9oADAMBAAIAAwAAABCLD7z/xAAYEQADAQEAAAAAAAAAAAAAAAAAAREQQf/aAAgBAwEBPxCFY+c//8QAGBEBAQADAAAAAAAAAAAAAAAAAQAQEUH/2gAIAQIBAT8Q3IR3j//EABoQAQEAAwEBAAAAAAAAAAAAAAERACExQRD/2gAIAQEAAT8QUbi6o24hFAODzBK0fcoRQXc1uJAFoineCXZ8cZ3RsVtzGmEKfH//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"merge sort image\" title=\"\" src=\"/TIL/static/327e829fdcf866ae04fa8b5dccfab88f/b4294/merge_sort_image.jpg\" srcset=\"/TIL/static/327e829fdcf866ae04fa8b5dccfab88f/75985/merge_sort_image.jpg 150w,\n/TIL/static/327e829fdcf866ae04fa8b5dccfab88f/f93b5/merge_sort_image.jpg 300w,\n/TIL/static/327e829fdcf866ae04fa8b5dccfab88f/b4294/merge_sort_image.jpg 600w,\n/TIL/static/327e829fdcf866ae04fa8b5dccfab88f/84f0d/merge_sort_image.jpg 632w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<h2 id=\"62-복잡도\" style=\"position:relative;\"><a href=\"#62-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"62 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6.2. 복잡도</h2>\n<ul>\n<li><strong>공간복잡도 O(n)</strong><br>\n배열을 병합할 때, 병합 결과를 담을 배열이 필요하므로 공간 복잡도 는 O(n)이다.</li>\n<li><strong>시간복잡도 O(n*log n)</strong><br>\n크기가 n인 데이터를 절반 씩 분할 했을 경우, 병합하는 깊이는 log n이다. 각 depth에 대해 병합 시에는 모든 데이터에 대해서 한 번씩 비교연산이 일어난다. O(n * log n)</li>\n</ul>\n<h2 id=\"63-python-구현\" style=\"position:relative;\"><a href=\"#63-python-%EA%B5%AC%ED%98%84\" aria-label=\"63 python 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6.3. Python 구현</h2>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">merge_sort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n    <span class=\"token comment\"># 베이스 반환 조건: 1개 이하의 배열이 되면 반환한다.</span>\r\n    <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span>\r\n        <span class=\"token keyword\">return</span> nums\r\n\r\n    <span class=\"token comment\"># 배열을 반으로 나눠서, 왼쪽과 오른쪽 배열에 대해 각각 재귀호출 한다.</span>\r\n    mid <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span> <span class=\"token operator\">//</span> <span class=\"token number\">2</span>\r\n    left_arr <span class=\"token operator\">=</span> merge_sort<span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span>mid<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># left_arr는 왼쪽 배열이 정렬된 값이다.</span>\r\n    right_arr <span class=\"token operator\">=</span> merge_sort<span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>   <span class=\"token comment\"># right_arr는 오른쪽 배열이 정렬된 값이다.</span>\r\n\r\n    <span class=\"token comment\"># left_arr와 right_arr는 각 정렬된 값이다.</span>\r\n    <span class=\"token comment\"># left_arr와 right_arr를 앞에서부터 서로 비교하며 merged_arr에 작은 값을 merged_arr에 채워 넣는다.</span>\r\n    l <span class=\"token operator\">=</span> r <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\r\n    merged_arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\r\n    <span class=\"token keyword\">while</span> l <span class=\"token operator\">&lt;</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>left_arr<span class=\"token punctuation\">)</span> <span class=\"token keyword\">and</span> r <span class=\"token operator\">&lt;</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>right_arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 양 배열 중 적어도 하나를 탐색 완료할 때까지</span>\r\n        <span class=\"token keyword\">if</span> left_arr<span class=\"token punctuation\">[</span>l<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> right_arr<span class=\"token punctuation\">[</span>h<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\r\n            merged_arr<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>left_arr<span class=\"token punctuation\">[</span>l<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\r\n            l <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\r\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\r\n            merged_arr<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>right_arr<span class=\"token punctuation\">[</span>r<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\r\n            r <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\r\n    merged_arr <span class=\"token operator\">+=</span> left_arr<span class=\"token punctuation\">[</span>l<span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span>\r\n    merged_arr <span class=\"token operator\">+=</span> right_arr<span class=\"token punctuation\">[</span>r<span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span>\r\n\r\n    <span class=\"token keyword\">return</span> merged_arr   <span class=\"token comment\"># left_arr와 right_arr를 병합해서 정렬한 값 반환</span></code></pre></div>\n<h1 id=\"7-quick-sort-퀵-정렬\" style=\"position:relative;\"><a href=\"#7-quick-sort-%ED%80%B5-%EC%A0%95%EB%A0%AC\" aria-label=\"7 quick sort 퀵 정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7. Quick Sort (퀵 정렬)</h1>\n<p>병합 정렬과 비슷하게 문제를 분할하면서 이뤄진다. 단 다음과 같은 차이점이 있다.</p>\n<ol>\n<li>배열의 중간에 위치한 값 아닌 pivot값을 기준으로 분할한다. pivot 값을 기준으로 큰 숫자와 작은 숫자의 갯수가 동일할 수록 알고리즘이 효율적이다.</li>\n<li>배열을 <strong>분할 할 때, 비교연산</strong>이 일어난다.</li>\n</ol>\n<p>1번 기준에 따라 pivot값을 어떻게 선택하느냐에 따라서 시간 복잡도가 달라진다. 최대 O(n**2)까지 커질 수 있는 불안정한 정렬 알고리즘이다.</p>\n<h2 id=\"71-동작-과정\" style=\"position:relative;\"><a href=\"#71-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\" aria-label=\"71 동작 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7.1. 동작 과정</h2>\n<ol>\n<li>배열의 pivot을 설정한다.</li>\n<li>pivot과 나머지 숫자를 비교 연산하여, pivot보다 작은 숫자 배열과, 큰 숫자 배열을 얻는다.</li>\n<li>작은 숫자 배열과, 큰 숫자 배열에 대해서 (1 ~ 2)의 과정을 반복한다.</li>\n<li>배열의 길이가 1이하로 쪼개지면 그대로 다시 합친다.</li>\n</ol>\n<h2 id=\"72-복잡도\" style=\"position:relative;\"><a href=\"#72-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"72 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7.2. 복잡도</h2>\n<ul>\n<li>\n<p><strong>공간 복잡도</strong><br>\n인메모리 정렬 방식을 사용할 경우, O(log n)의 공간복잡도로 구현 가능하다. <del>뭔소린지 모르겠다</del></p>\n</li>\n<li>\n<p><strong>시간 복잡도</strong><br>\npivot값이 이상적으로 선택되었을 경우, 병합정렬과 마찬가지로 (log n)의 깊이의 대해서, 각각 n번의 비교 연산이 일어나므로 <strong>O(n*log n)의 복잡도</strong>를 가진다.</p>\n<p>그러나 최악의 경우 분할정복이 (n)의 깊이를 가지므로 <strong>O(n**2)의 복잡도</strong>를 가진다.</p>\n</li>\n</ul>\n<h2 id=\"73-python-구현\" style=\"position:relative;\"><a href=\"#73-python-%EA%B5%AC%ED%98%84\" aria-label=\"73 python 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7.3. Python 구현</h2>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 이 코드에서는 pivot을 병합 정렬과 동일하게 배열의 중간위치 값으로 설정한다.</span>\r\n<span class=\"token keyword\">def</span> <span class=\"token function\">quick_sort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n    <span class=\"token comment\"># 베이스 반환 조건: 1개 이하의 배열이 되면 반환한다.</span>\r\n    <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span>\r\n        <span class=\"token keyword\">return</span> nums\r\n\r\n    pivot <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span> <span class=\"token operator\">//</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span>    <span class=\"token comment\"># pivot 설정</span>\r\n    lesser_arr<span class=\"token punctuation\">,</span> equal_arr<span class=\"token punctuation\">,</span> greater_arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token comment\"># 각각 pivot보다) 작은 숫자 배열, 동일한 숫자 배열, 큰 숫자 배열</span>\r\n    <span class=\"token keyword\">for</span> num <span class=\"token keyword\">in</span> arr<span class=\"token punctuation\">:</span>\r\n        <span class=\"token keyword\">if</span> num <span class=\"token operator\">&lt;</span> pivot<span class=\"token punctuation\">:</span>\r\n            lesser_arr<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span>\r\n        <span class=\"token keyword\">elif</span> num <span class=\"token operator\">></span> pivot<span class=\"token punctuation\">:</span>\r\n            greater_arr<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span>\r\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\r\n            equal_arr<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span>\r\n\r\n    <span class=\"token comment\"># pivot보다 작은 숫자배열과, pivot보다 큰 숫자 배열을 quick_sort에 재귀호출 한다.</span>\r\n    <span class=\"token comment\"># 결과를 그대로 이어 붙여 반환한다.</span>\r\n    <span class=\"token keyword\">return</span> quick_sort<span class=\"token punctuation\">(</span>lesser_arr<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> equal_arr <span class=\"token operator\">+</span> quick_sort<span class=\"token punctuation\">(</span>greater_arr<span class=\"token punctuation\">)</span></code></pre></div>\n<h1 id=\"8-counting-sort-계수-정렬\" style=\"position:relative;\"><a href=\"#8-counting-sort-%EA%B3%84%EC%88%98-%EC%A0%95%EB%A0%AC\" aria-label=\"8 counting sort 계수 정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>8. Counting Sort (계수 정렬)</h1>\n<p>특정한 조건이 만족할 때, O(n + k)의 시간복잡도로 정렬할 수 있다. 이 때 k는 배열에 존재하는 숫자의 크기 범위이다. 즉 k가 데이터의 갯수 n보다 작으면, **O(n)**의 정렬이 가능하다.</p>\n<ul>\n<li>배열에 존재하는 모든 숫자가 0이상의 정수여야 한다.</li>\n<li>배열에 존재하는 숫자의 크기 범위(k)가 지나치게 커서는 안된다.</li>\n</ul>\n<h2 id=\"81-동작-과정\" style=\"position:relative;\"><a href=\"#81-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\" aria-label=\"81 동작 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>8.1. 동작 과정</h2>\n<ol>\n<li>배열의 숫자 범위(k)에 해당하는 <code class=\"language-text\">[0] * k</code>의 누적합 예비 배열을 만든다.</li>\n<li>배열을 1회 순회하며, 숫자를 인덱스로 하는 누적합 예비 배열의 값을 +1 한다.</li>\n<li>누적합 예비 배열을 누적합하여 누적합 배열을 만든다.</li>\n<li>누적합 배열을 1회 순회하며, 값만큼 인덱스를 출력한다.</li>\n</ol>\n<h2 id=\"82-복잡도\" style=\"position:relative;\"><a href=\"#82-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"82 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>8.2. 복잡도</h2>\n<ul>\n<li><strong>공간 복잡도 O(k)</strong><br>\n숫자 범위(k)에 해당하는 배열을 생성해야 한다.</li>\n<li><strong>시간 복잡도 O(n+k)</strong><br>\n배열을 1회 순회 O(n)하고, 누적합 배열을 1회 순회 O(k)한다.</li>\n</ul>\n<h2 id=\"83-python-구현\" style=\"position:relative;\"><a href=\"#83-python-%EA%B5%AC%ED%98%84\" aria-label=\"83 python 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>8.3. Python 구현</h2>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">counting_sort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> K<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n    N <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span>\r\n\r\n    <span class=\"token comment\"># 누적합 예비 배열을 생성한다.</span>\r\n    count_sum <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>K<span class=\"token punctuation\">)</span>\r\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> N<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n        count_sum<span class=\"token punctuation\">[</span>nums<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\r\n\r\n    <span class=\"token comment\"># 누적합 배열을 만든다. (인덱스에 해당하는 값이 들어가야할 마지막 인덱스 번호를 가리킨다.)</span>\r\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> K<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n        counts<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> counts<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\r\n\r\n    <span class=\"token comment\"># 배열의 값을 인덱스로 하는 누적합 배열을 찹조한다. -> 해당 값이 들어가야할 마지막 인덱스 번호</span>\r\n    <span class=\"token comment\"># 결과 배열의 해당 인덱스에 숫자를 집어넣는다.</span>\r\n    <span class=\"token comment\"># 다음 값을 위해 해당 값을 인덱스로 하는 누적합 배열의 값을 -1 한다.</span>\r\n    <span class=\"token comment\"># 내가 그린 기린 그림은 잘 그린 기린 그림이고...</span>\r\n    result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> N\r\n    <span class=\"token keyword\">for</span> num <span class=\"token keyword\">in</span> nums<span class=\"token punctuation\">:</span>\r\n        idx <span class=\"token operator\">=</span> count_sum <span class=\"token punctuation\">[</span>num<span class=\"token punctuation\">]</span>\r\n        result<span class=\"token punctuation\">[</span>idx <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> num\r\n        count_sum<span class=\"token punctuation\">[</span>num<span class=\"token punctuation\">]</span> <span class=\"token operator\">-=</span> <span class=\"token number\">1</span></code></pre></div>\n<h1 id=\"9-복잡도-비교\" style=\"position:relative;\"><a href=\"#9-%EB%B3%B5%EC%9E%A1%EB%8F%84-%EB%B9%84%EA%B5%90\" aria-label=\"9 복잡도 비교 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>9. 복잡도 비교</h1>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/72436f978a4796a5ec76606551c2baa1/fba02/sortings_complexity.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 65.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAQAF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAL/2gAMAwEAAhADEAAAAdpmRMf/xAAXEAADAQAAAAAAAAAAAAAAAAAAAREg/9oACAEBAAEFAiEWP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABcRAAMBAAAAAAAAAAAAAAAAAAABElH/2gAIAQIBAT8BlYSj/8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAHRAAAgEEAwAAAAAAAAAAAAAAAAERECExQVFhsf/aAAgBAQABPyFJQ7EONHQhYZPlP//aAAwDAQACAAMAAAAQ7/8A/8QAFhEAAwAAAAAAAAAAAAAAAAAAAAER/9oACAEDAQE/EKys/8QAFhEBAQEAAAAAAAAAAAAAAAAAAGEB/9oACAECAQE/EJk8f//EABsQAAIDAAMAAAAAAAAAAAAAAAABESExUXGh/9oACAEBAAE/ELckxI5XUOjiPEaVaG6XR//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"sortings complexity\" title=\"\" src=\"/TIL/static/72436f978a4796a5ec76606551c2baa1/b4294/sortings_complexity.jpg\" srcset=\"/TIL/static/72436f978a4796a5ec76606551c2baa1/75985/sortings_complexity.jpg 150w,\n/TIL/static/72436f978a4796a5ec76606551c2baa1/f93b5/sortings_complexity.jpg 300w,\n/TIL/static/72436f978a4796a5ec76606551c2baa1/b4294/sortings_complexity.jpg 600w,\n/TIL/static/72436f978a4796a5ec76606551c2baa1/8e1fc/sortings_complexity.jpg 900w,\n/TIL/static/72436f978a4796a5ec76606551c2baa1/fba02/sortings_complexity.jpg 935w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/b5c0bd27b95b94aa6421c2b377adc475/7e509/Big_O_graph.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 61.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAAC20lEQVR42lXRT2iTdxzH8Uc2T4MdxYMHYbcdN6aCTpuk1f05iffB2G0IMqYLtQouT/M8T5609bQpwhw6ioeuQpthG23UJu2aDkfpVpY29ckfzb8+TQr50+dJnuZ53qNJV+bhw+fwgxd8fl+h3mjQqlap5vNUi0WaGxtYlQrb2Qz62ENKofuUViQSKxJjvw/w25/DtDY3sDbLWGW9081CGSyTtWQSYdtxqIVC5L69TPHGDWxVpakoFK9fxxRFHFnCCYi0FZGWLGIpgxBUYUgF+SYER7B//hIyd9GyhT1wcoLa1auYigxqgKrPx44i4wQC+6ETtfPuSEEc/xDObS+EL2DHPoD8j6Qyxf/ASar9/RiStA/+H+tG6bZ/GG5+Dw+/gAU3xD3Yz0/A61tomQJCw7apTUx0QFOWsWSZhiiCqr6JSUOd5pevIXoOO36a1qybnehZ6tMfQeoHUtkiQq5SIT86Sv3aNQxZxvT7Mfz+PVDBkYNd7PZ3ED4Pi2cg7saIuMmOn6Iy5aI1cwxyt7qT06US2Xv3qA4MYAUUaqKP9u7/KQGcwRGcEd/ePA9O3MXOrIfGjIvtiIt2zAMLZ7GjXVDbBbdMk/L4OJteL01Fpr47VxrugNy/CLOfYS+cofncRWOmh0akh52oB+Z7IdYH0U+xH5+C7J03r6x7r1ATJaxBFe54ccLnseZPU5/poRb2YDzpxX52DmKfwFwfzlwvzh8f4/x1nPbqETAG0dKl7lGqkyEK3/RjBH0w9hWtp32Yz1w0I70w54alk5D4ELT3IXcUtg6B8Q60DwJvYzYF4BLptI7QBFIPRkn6P2fzyXFy8+9RfHEUPXEYPfsupY2D5MoHyFQE1rcEEmWBFV1gqSjwoiDwdPUtfl0UWNUv8SqrI2wbBq9TSVaWH5FcD6Olp1h/FWItE+Kf9COW1iaZiv5EJD7KsjbNshZmSZvez2IiTOzvEPlKkpfrL/kX0or3SLDTFYoAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Big O graph\" title=\"\" src=\"/TIL/static/b5c0bd27b95b94aa6421c2b377adc475/0a47e/Big_O_graph.png\" srcset=\"/TIL/static/b5c0bd27b95b94aa6421c2b377adc475/8a4e8/Big_O_graph.png 150w,\n/TIL/static/b5c0bd27b95b94aa6421c2b377adc475/5a46d/Big_O_graph.png 300w,\n/TIL/static/b5c0bd27b95b94aa6421c2b377adc475/0a47e/Big_O_graph.png 600w,\n/TIL/static/b5c0bd27b95b94aa6421c2b377adc475/7e509/Big_O_graph.png 745w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-bubble-sort-%EA%B1%B0%ED%92%88-%EC%A0%95%EB%A0%AC\">1. Bubble Sort (거품 정렬)</a></p>\n<ul>\n<li><a href=\"#11-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">1.1. 동작 과정</a></li>\n<li><a href=\"#12-%EB%B3%B5%EC%9E%A1%EB%8F%84\">1.2. 복잡도</a></li>\n<li><a href=\"#13-python-%EA%B5%AC%ED%98%84\">1.3. Python 구현</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-selection-sort-%EC%84%A0%ED%83%9D-%EC%A0%95%EB%A0%AC\">2. Selection Sort (선택 정렬)</a></p>\n<ul>\n<li><a href=\"#21-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">2.1. 동작 과정</a></li>\n<li><a href=\"#22-%EB%B3%B5%EC%9E%A1%EB%8F%84\">2.2. 복잡도</a></li>\n<li><a href=\"#23-python-%EA%B5%AC%ED%98%84\">2.3. Python 구현</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-insertion-sort-%EC%82%BD%EC%9E%85-%EC%A0%95%EB%A0%AC\">3. Insertion Sort (삽입 정렬)</a></p>\n<ul>\n<li><a href=\"#31-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">3.1. 동작 과정</a></li>\n<li><a href=\"#32-%EB%B3%B5%EC%9E%A1%EB%8F%84\">3.2. 복잡도</a></li>\n<li><a href=\"#33-python-%EA%B5%AC%ED%98%84\">3.3. Python 구현</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#4-shell-sort-%EC%85%B8-%EC%A0%95%EB%A0%AC\">4. Shell Sort (셸 정렬)</a></p>\n<ul>\n<li><a href=\"#41-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">4.1. 동작 과정</a></li>\n<li><a href=\"#42-%EB%B3%B5%EC%9E%A1%EB%8F%84\">4.2. 복잡도</a></li>\n<li><a href=\"#43-python-%EA%B5%AC%ED%98%84\">4.3. Python 구현</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#5-heap-sort-%ED%9E%99-%EC%A0%95%EB%A0%AC\">5. Heap Sort (힙 정렬)</a></p>\n</li>\n<li>\n<p><a href=\"#6-merge-sort-%EB%B3%91%ED%95%A9-%EC%A0%95%EB%A0%AC\">6. Merge Sort (병합 정렬)</a></p>\n<ul>\n<li><a href=\"#61-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">6.1. 동작 과정</a></li>\n<li><a href=\"#62-%EB%B3%B5%EC%9E%A1%EB%8F%84\">6.2. 복잡도</a></li>\n<li><a href=\"#63-python-%EA%B5%AC%ED%98%84\">6.3. Python 구현</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#7-quick-sort-%ED%80%B5-%EC%A0%95%EB%A0%AC\">7. Quick Sort (퀵 정렬)</a></p>\n<ul>\n<li><a href=\"#71-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">7.1. 동작 과정</a></li>\n<li><a href=\"#72-%EB%B3%B5%EC%9E%A1%EB%8F%84\">7.2. 복잡도</a></li>\n<li><a href=\"#73-python-%EA%B5%AC%ED%98%84\">7.3. Python 구현</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#8-counting-sort-%EA%B3%84%EC%88%98-%EC%A0%95%EB%A0%AC\">8. Counting Sort (계수 정렬)</a></p>\n<ul>\n<li><a href=\"#81-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">8.1. 동작 과정</a></li>\n<li><a href=\"#82-%EB%B3%B5%EC%9E%A1%EB%8F%84\">8.2. 복잡도</a></li>\n<li><a href=\"#83-python-%EA%B5%AC%ED%98%84\">8.3. Python 구현</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#9-%EB%B3%B5%EC%9E%A1%EB%8F%84-%EB%B9%84%EA%B5%90\">9. 복잡도 비교</a></p>\n</li>\n</ul>","frontmatter":{"createdAt":"2023-05-02","isCompleted":true,"reference":null,"title":"정렬(Sorting) 알고리즘 정리","updatedAt":"2023-05-03"}},"allMarkdownRemark":{"nodes":[{"id":"3a4b2e18-1298-5318-ba3d-367c5264afaf","parent":{"id":"42162e1e-42f8-5384-9248-b7a8cee98455","name":"DFS","relativePath":"Algorithm/DFS.md"},"frontmatter":{"title":"깊이 우선 탐색(Depth-First Search) 알고리즘","createdAt":"2023-03-14","updatedAt":"2023-04-17"},"excerpt":"1. 개요 상태공간이나 그래프를 출발점에서 시작하여 모든 리프노드까지 순서대로 탐색하는 완전탐색 기반의 알고리즘이다. 1.…"},{"id":"304cd1e4-5045-51ed-bb74-5d6de909b0b3","parent":{"id":"01eaf46a-e882-5691-ba22-40b8841edb2c","name":"BFS","relativePath":"Algorithm/BFS.md"},"frontmatter":{"title":"너비 우선 탐색(Breadth-First Search) 알고리즘","createdAt":"2023-03-05","updatedAt":"2023-04-17"},"excerpt":"1. 개요 상태공간이나 그래프를 출발점으로부터 가까운 순으로 탐색해가는 완전탐색 기반의 알고리즘이다. 1.…"},{"id":"d152b12a-0aec-5325-87ba-b9912faae2dd","parent":{"id":"982bfef7-ba07-5eb8-a421-444507bbca5f","name":"Dijkstra","relativePath":"Algorithm/Dijkstra.md"},"frontmatter":{"title":"다익스트라(Dijkstra) 알고리즘","createdAt":"2023-02-27","updatedAt":"2023-04-17"},"excerpt":"1. 개요 음의 가중치가 없는 그래프의 한 노드에서 다른 모드 노드까지의 최단거리를 각각 구하는 알고리즘. 대표적으로 사용되는 그리디 알고리즘이다.…"},{"id":"fe66208e-7fe6-5afb-a230-a5f12aa201e1","parent":{"id":"54b68164-06d2-5861-b5e4-0e5473d031a0","name":"DP","relativePath":"Algorithm/DP.md"},"frontmatter":{"title":"동적 계획법(Dynamic Programming) 알고리즘","createdAt":"2023-03-27","updatedAt":"2023-04-03"},"excerpt":"…"},{"id":"1bc47ab1-4e2f-5b9f-98d2-9e9863473a91","parent":{"id":"5a994e87-ef15-5f86-b3b4-630d75c93646","name":"Backtracking","relativePath":"Algorithm/Backtracking.md"},"frontmatter":{"title":"백트래킹(Backtracking) 알고리즘","createdAt":"2022-08-23","updatedAt":"2023-04-17"},"excerpt":"1. 개요 상태공간이나 그래프의 노드를 모두 탐색하는 완전탐색 기반의 알고리즘이다. 다만, 가지 치기를 통해 탐색할 필요성이 없는 노드(상태)들을 탐색 대상에서 제외함으로써 효율을 높인다.…"},{"id":"ff6459b0-68d5-5d84-954e-3a1565353b52","parent":{"id":"0ed4d430-3364-59b1-81d8-2add31072348","name":"BinarySearch","relativePath":"Algorithm/BinarySearch.md"},"frontmatter":{"title":"이진탐색(Binary Search) 알고리즘","createdAt":"2023-04-11","updatedAt":"2023-04-11"},"excerpt":"1. 개요 정렬된 데이터에서 검색 범위를 줄여 나가면서 목적 값을 찾는 알고리즘이다. 데이터가 정렬되어 있을 경우, 데이터를 크기가 같은 두 부분으로 나누고 유효한 데이터집합을 선 1.…"},{"id":"f3fa286d-64fa-5dfa-b43e-5772a9b71604","parent":{"id":"f0f6388e-222b-517a-918c-1d580e3dcf99","name":"Sorting","relativePath":"Algorithm/Sorting.md"},"frontmatter":{"title":"정렬(Sorting) 알고리즘 정리","createdAt":"2023-05-02","updatedAt":"2023-05-03"},"excerpt":"면접에서 탈탈 털린 후 작성한 정렬 관련 알고리즘을 총정리 1. Bubble Sort (거품 정렬) 1.1. 동작 과정 1.2. 복잡도 1.3. Python 구현 2. Selection Sort (선택 정렬) 2.1. 동작 과정 2.2. 복잡도 2.…"},{"id":"afaa0d6e-7d3c-5a97-a99c-0213c46b899d","parent":{"id":"bd2963c7-7771-553b-8a27-e7d18e30007d","name":"MST","relativePath":"Algorithm/MST.md"},"frontmatter":{"title":"최소 신장 트리(Minimum Spaaning Tree) 알고리즘","createdAt":"2023-04-17","updatedAt":"2023-04-17"},"excerpt":"1. 개요 신장 트리(Spanning Tree)는 그래프 내의 모든 노드를 포함하는 트리를 의미하며, **최소 신장 트리(Minimum Spanning Tree)**란 간선의 가중치 합이 최소가 되는 신장 트리를 말한다. 최소 신장 트리는 Greedy…"}]}},"pageContext":{"pagePath":"posts/Algorithm/Sorting.md","regex":"/^(?!.*README).*Algorithm.*$/","id":"f3fa286d-64fa-5dfa-b43e-5772a9b71604","parent":{"id":"f0f6388e-222b-517a-918c-1d580e3dcf99","name":"Sorting","relativeDirectory":"Algorithm","relativePath":"Algorithm/Sorting.md"}}},"staticQueryHashes":["3300660363","3571427910","82772122"],"slicesMap":{}}