{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/Algorithm/BFS.md/","result":{"data":{"markdownRemark":{"id":"304cd1e4-5045-51ed-bb74-5d6de909b0b3","html":"<h1>Breadth First Search</h1>\n<h1>1. 개요</h1>\n<p>상태공간이나 그래프를 출발점으로부터 가까운 순으로 탐색해가는 <strong>완전탐색</strong> 기반의 알고리즘이다.</p>\n<h2>1.1. 특징</h2>\n<ul>\n<li>상태(노드)간의 가중치가 동일할 때, 최단 경로를 찾기 적합하다.</li>\n<li>상태(노드)간의 가중치가 다르더라도, 누적 가중치를 비교하여 최단 경로를 찾을 수 있다.</li>\n<li>출발점을 하나 이상 설정할 수 있다</li>\n</ul>\n<h1>2. 동작</h1>\n<p>아래는 BFS가 동작하는 하나의 예시일 뿐이다.</p>\n<ol>\n<li>시작 노드를 선정한다.</li>\n<li>인접 노드 중 방문하지 않은 노드를 큐에 추가한다.</li>\n<li>큐에서 노드를 꺼낸다.</li>\n<li>목적 노드에 도착할 때까지 2~3의 과정을 반복한다.</li>\n</ol>\n<p>또한 가중치가 있는 경우에도 완전탐색을 기반으로 하여 최단거리를 구해낼 수 있다.</p>\n<h1>3. 시간 복잡도</h1>\n<p>N: 노드의 갯수\r\nE: 간선의 갯수</p>\n<h2>3.1. Basic</h2>\n<ul>\n<li><strong>O(V + E)</strong><br>\n최대 N개의 노드를 다 탐색하거나, 또는 모든 간선의 연결관계를 탐색해야 한다.\n<ul>\n<li>인접 행렬의 경우, 노드의 갯수가 N^2 이고 간선의 갯수가 4*N^2이므로 <strong>O(N^2)</strong></li>\n</ul>\n</li>\n</ul>\n<h2>3.2. Shortest Path</h2>\n<ul>\n<li><strong>O(N + E)</strong><br>\n최대 V개의 노드를 다 탐색하거나, 또는 모든 간선의 연결관계를 탐색해야 한다.\n<ul>\n<li>인접 행렬의 경우, 노드의 갯수가 N^2 이고 간선의 갯수가 4*N^2이므로 <strong>O(N^2)</strong></li>\n</ul>\n</li>\n</ul>\n<h1>4. 구현</h1>\n<h2>4.1. Basic</h2>\n<ul>\n<li>\n<p><strong>Python 코드</strong></p>\n<pre><code class=\"language-python\">'''\r\nN     : 노드 갯수\r\nstart : 시작 노드\r\nend   : 끝 노드\r\nadjLst: 특정 노드의 인접 노드를 알 수 있는 컨테이너 자료\r\n'''\r\nfrom collections import deque\r\n\r\ndef bfs(N, start, end, adjLst):\r\n    visited = [0] * N     # 방문 여부를 체크할 visited 배열\r\n    queue = deque()       # 시작점부터 거리 순으로 노드를 저장할 큐\r\n\r\n    # 시작점 셋팅\r\n    queue.append(start)\r\n    visited[start] = 1\r\n\r\n    while queue:\r\n        node = queue.popleft()    # 시작점으로 가까운 순으로 탐색\r\n\r\n        # 종료 조건\r\n        if node == end:\r\n          return visited[end] - 1\r\n\r\n        # 인접 노드 탐색\r\n        for adj in adjLst[node]:\r\n            if not visited[adj]:  # 방문하지 않은 노드만 탐색\r\n                visited[adj] = visited[node] + 1\r\n                queue.append(adj)\r\n\r\n    return -1 # 목적 노드를 도달할 수 없음\n</code></pre>\n</li>\n</ul>\n<h2>4.2. Shortest Path</h2>\n<ul>\n<li>\n<p><strong>Python 코드</strong></p>\n<pre><code class=\"language-python\">'''\r\nN     : 노드 갯수\r\nstart : 시작 노드\r\nend   : 끝 노드\r\nadjLst: 특정 노드의 인접 노드와 가중치를 알 수 있는 컨테이너 자료\r\n'''\r\ndef bfs(N, start, end, adjLst):\r\n    distance = [INF] * (N)    # 시작점으로부터 거리를 기록할 distance 배열\r\n    queue =deque()            # 시작점부터 거리 순으로 노드를 저장할 큐\r\n\r\n    # 시작점 셋팅\r\n    queue.append(start)\r\n    distance[start] = 0\r\n\r\n    while queue:\r\n        node = q.popleft()    # 시작점으로 부터 가중치를 고려하지 않은 가까운 순으로 탐색\r\n\r\n        # 인접 노드 탐색\r\n        for weight, adj in adjLst[node]:\r\n            new_cost = distance[node] + weight    # 거리가 더 짧을 경우에만 탐색\r\n            if distance[adj] > new_cost:\r\n                distance[adj] = new_cost\r\n                queue.append(adj)\r\n\r\n    if distance[end] != INF:  # 목적지에 도착하는 경우\r\n      return distance[end]\r\n    return  # 목적 노드를 도달할 수 없음\n</code></pre>\n</li>\n</ul>"}},"pageContext":{"pagePath":"posts/Algorithm/BFS.md","id":"304cd1e4-5045-51ed-bb74-5d6de909b0b3","parent":{"id":"01eaf46a-e882-5691-ba22-40b8841edb2c","name":"BFS","relativePath":"Algorithm/BFS.md"}}},"staticQueryHashes":["1274812890","3935499650","82772122"],"slicesMap":{}}