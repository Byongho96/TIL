{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/Algorithm/DFS.md/","result":{"data":{"markdownRemark":{"id":"3a4b2e18-1298-5318-ba3d-367c5264afaf","html":"<h1>Depth First Search</h1>\n<h1>1. 개요</h1>\n<p>상태공간이나 그래프를 출발점에서 시작하여 모든 리프노드까지 순서대로 탐색하는 <strong>완전탐색</strong> 기반의 알고리즘이다.</p>\n<h2>1.1. 특징</h2>\n<ul>\n<li>루트 노드(상태)로부터 리프 노드(상태)까지 길이가 유한할 때만 사용가능하다.</li>\n<li>노드 탐색 순서가 재귀적으로 표현될 때 적합하다.</li>\n</ul>\n<h1>2. 동작</h1>\n<p>아래는 DFS가 동작하는 하나의 예시일 뿐이다.</p>\n<ol>\n<li>시작 노드를 선정한다.</li>\n<li>인접 노드 중 방문하지 않은 노드를 스택에 추가한다.</li>\n<li>스택에서 노드를 꺼낸다.</li>\n<li>목적 노드에 도착할 때까지 2~3의 과정을 반복한다.</li>\n</ol>\n<h1>3. 시간 복잡도</h1>\n<p>V: 노드의 갯수\r\nE: 간선의 갯수</p>\n<ul>\n<li><strong>O(N + E)</strong><br>\n최대 V개의 노드를 다 탐색하거나, 또는 모든 간선의 연결관계를 탐색해야 한다.\n<ul>\n<li>인접 행렬의 경우, 노드의 갯수가 N^2 이고 간선의 갯수가 4*N^2이므로 <strong>O(N^2)</strong></li>\n</ul>\n</li>\n</ul>\n<h1>4. 구현</h1>\n<ul>\n<li>\n<p><strong>Python 코드</strong><br>\n단순히 모든 노드를 완전탐색하는 DFS 알고리즘이다.</p>\n<pre><code class=\"language-python\">'''\r\nN     : 노드 갯수\r\nstart : 시작 노드\r\nend   : 끝 노드\r\nadjLst: 특정 노드의 인접 노드를 알 수 있는 컨테이너 자료\r\n'''\r\n\r\ndef dfs(N, start, end, adjLst):\r\n    visited = [0] * N     # 방문 여부를 체크할 visited 배열\r\n    stack = []            # 시작점부터 거리 순으로 노드를 저장할 큐\r\n\r\n    # 시작점 셋팅\r\n    stack.append(start)\r\n    visited[start] = 1\r\n\r\n    while stack:\r\n        node = stack.pop()\r\n\r\n        # 종료 조건\r\n        if node == end:       # 목적 노드를 도달 시\r\n          return True\r\n\r\n        # 인접 노드 탐색\r\n        for adj in adjLst[node]:\r\n            if not visited[adj]:  # 방문하지 않은 노드 만 탐색\r\n                visited[adj] = True\r\n                stack.append(adj)\r\n\r\n    return False # 목적 노드를 도달할 수 없음\n</code></pre>\n<p>지나온 경로를 기억할 수 있는 DFS 알고리즘이다</p>\n<pre><code class=\"language-python\">'''\r\nN     : 노드 갯수\r\nstart : 시작 노드\r\nend   : 끝 노드\r\nadjLst: 특정 노드의 인접 노드를 알 수 있는 컨테이너 자료\r\n'''\r\ndef dfs_while(N, start, end, adjLst):\r\n  visited = [False] * 100\r\n  stack = []\r\n\r\n  node = start\r\n  visited[node] = True\r\n\r\n  while True:\r\n      # 종료 조건\r\n      if node == end:\r\n          path = stack + [node]\r\n          return path\r\n\r\n      # 인접 노드 탐색\r\n      for adj in adjLst[node]:\r\n          if not visited[adj]:\r\n              stack.append(node)\r\n              node = adj\r\n              visited[node] = True\r\n              break\r\n\r\n      # 인접 노드 없을 시, 부모 상태 노드로 후퇴\r\n      else:\r\n          if stack:\r\n              node = stack.pop()\r\n          else: # 모든 노드 탐색 완료 시, 반복문 break\r\n              break\r\n  return False\n</code></pre>\n</li>\n</ul>"}},"pageContext":{"pagePath":"posts/Algorithm/DFS.md","id":"3a4b2e18-1298-5318-ba3d-367c5264afaf","parent":{"id":"42162e1e-42f8-5384-9248-b7a8cee98455","name":"DFS","relativePath":"Algorithm/DFS.md"}}},"staticQueryHashes":["1274812890","3935499650","82772122"],"slicesMap":{}}