{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/Algorithm/BinarySearch.md/","result":{"data":{"markdownRemark":{"id":"ff6459b0-68d5-5d84-954e-3a1565353b52","html":"<h1>Binary Search</h1>\n<h1>1. 개요</h1>\n<p><strong>정렬된 데이터</strong>에서 검색 범위를 줄여 나가면서 목적 값을 찾는 알고리즘이다. 데이터가 <strong>정렬</strong>되어 있을 경우, 데이터를 크기가 같은 두 부분으로 나누고 유효한 데이터집합을 선</p>\n<h2>1.1. 특징</h2>\n<ul>\n<li>루트 노드(상태)로부터 리프 노드(상태)까지 길이가 유한할 때만 사용가능하다.</li>\n<li>노드 탐색 순서가 재귀적으로 표현될 때 적합하다.</li>\n</ul>\n<h1>2. 동작</h1>\n<ol>\n<li>데이터의 중간 값을 찾는다.</li>\n<li>중간 값과 검색 값을 비교한다.\n<ol>\n<li>중간 값이 검색 값이 같을 경우, 종료한다.</li>\n<li>중간 값이 검색 값보다 클 경우, 중간 값 기준 데이터의 왼쪽을 탐색한다.</li>\n<li>중간 값이 검색 값보다 작을 경우, 중간 값 기준 데이터의 오른쪽을 탐색한다.</li>\n</ol>\n</li>\n<li>데이터가 없을 경우 종료한다.</li>\n</ol>\n<h1>3. 시간 복잡도</h1>\n<p><strong>O(logN)</strong>\r\n데이터를 계속해서 이분하며 탐색해나간다.</p>\n<h1>4. 구현</h1>\n<ul>\n<li>\n<p><strong>Python 코드</strong><br>\n단순히 모든 노드를 완전탐색하는 DFS 알고리즘이다.</p>\n<pre><code class=\"language-python\">  def binary_search (arr, val):\r\n      first = 0\r\n      last = len(arr) - 1\r\n\r\n      # 데이터 범위가 있는 한 계속 탐색\r\n      while first &#x3C;= last:\r\n          mid = (first + last) // 2\r\n\r\n          if arr[mid] == val: # 검색 값을 찾았을 경우\r\n              return mid\r\n\r\n          if arr[mid] > val:  # 검색 값이 중간값보다 작은 경우\r\n              last = mid - 1\r\n\r\n          else:               # 검색 값이 중간값보다 큰 경우\r\n              first = mid + 1\r\n      return -1   # 검색 값을 찾지 못했을 경우\n</code></pre>\n</li>\n</ul>"}},"pageContext":{"pagePath":"posts/Algorithm/BinarySearch.md","id":"ff6459b0-68d5-5d84-954e-3a1565353b52","parent":{"id":"0ed4d430-3364-59b1-81d8-2add31072348","name":"BinarySearch","relativePath":"Algorithm/BinarySearch.md"}}},"staticQueryHashes":["1274812890","3935499650","82772122"],"slicesMap":{}}