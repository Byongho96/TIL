{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/Algorithm/First/String.md/","result":{"data":{"markdownRemark":{"id":"f2a7b08b-7678-531c-8d95-91c659a104ac","html":"<h2>1. String</h2>\n<p><strong>Even strings are stored as 0 abd 1</strong></p>\n<ul>\n<li>.jpg/.mp4/.doc ...: all the file has its own encoding rule (binary data) &#x3C;-> (desirable data)</li>\n</ul>\n<h3>1-1. Standoard Code</h3>\n<p><strong>the encoding character rule for information interchagne</strong></p>\n<ul>\n<li>ASCII(American Standard Code for Information interchange)\n<ul>\n<li>1st bit: Parity Bit\n<ul>\n<li>for detecting error by checksum</li>\n</ul>\n</li>\n<li>7bit character encoding standard\r\n<img src=\"images/%EC%BA%A1%EC%B2%98.PNG\" alt=\"ASCII\"></li>\n</ul>\n</li>\n<li>Extended ASCII\n<ul>\n<li>using all the 8bit</li>\n</ul>\n</li>\n<li>UTF-8 (Unicdoe)\n<ul>\n<li>MIN: 8bit, MAX: 32bit</li>\n<li>default encoding rule in python</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2>2. Matching Pattern</h2>\n<h3>2-1. Bruce-Force</h3>\n<ul>\n<li><strong>O(MN)</strong>\n<pre><code class=\"language-python\">p  =  'is'\r\nt  = 'This is a book'\r\n\r\ndef BruteForce(p, t):\r\n  M = len(p)\r\n  N = len(t)\r\n  i  = 0 # an index for p(string)\r\n  j  = 0 # an index for t(pattern)\r\n  while j &#x3C; M and i &#x3C; N:\r\n    if t[i] != p[j]:\r\n      i = i - j \r\n      j = -1 # consdier the following expressions\r\n    i += 1\r\n    j += 1\r\n  if j == M: return i - M # Success: the start index\r\n  else: return -1\r\nprint(BruteForce(p,t)) # 2\n</code></pre>\n</li>\n</ul>\n<h3>2-2. KMP Alogrithm</h3>\n<p><a href=\"https://yiyj1030.tistory.com/495\">KMP Explanation with images</a></p>\n<ul>\n<li><strong>O(N)~O(MN)</strong></li>\n<li><strong>STEP</strong>\n<ol>\n<li>Make Pi table(Longest Prefix Suffix Array) for the pattern(pat)</li>\n</ol>\n<img src=\"images/Pi_table.jpg\" alt=\"Ex.Pi_table\">\r\n2. Browse a string skipping some characters by referring to the Pi table\r\n<img src=\"images/KMP.jpg\" alt=\"Ex.KMP_search\">\n<pre><code class=\"language-python\"># Making LPS array(Pi table)\r\ndef computeLPSArray(pat):\r\n  table = [0] * len(pat)\r\n\r\n  i = 0 # index for prefix\r\n  j = 1 # index for suffix\r\n  while j &#x3C; len(pat):\r\n    if pat[i] == pat[j]:  # 하나를 늘렸을 때 같으면, i인덱스에 1을 더한 값(갯수)을 저장\r\n      i += 1\r\n      table[j] = i\r\n      j += 1\r\n    else: # 하나를 늘렸을 때 틀리면,\r\n      if i != 0: # prefix 인덱스가 처음을 참조하는게 아니라면\r\n        i = table(i-1)  # 그 전의 인덱스의 table값\r\n                        # table(i-1) = 3 -> 3개가 반복된다 (0,1,2)\r\n                        # 3번 인덱스로 가는 것은 반복구간 이후의 값, 새로 비교할 지점\r\n                        # 여기의 값이 pat[j]와 같으면 i+1이 테이블에 저장. 새로운(감소된) lps지점 형성\r\n      else: # prefix가 처음이라면, 0넣고 다음 j\r\n        table[j] = 0\r\n        j += 1\n</code></pre>\n<pre><code class=\"language-python\"># More Intuitive: Making LPS array(Pi table)\r\ndef computeLPSArray2(pat):\r\n  N = len(pat)\r\n  table = [0] * N  # 위 함수에서 else조건문을 빼기 위해서\r\n\r\n  i = 0 # index for prefix\r\n  j = 1 # index for suffix\r\n  for j in range(1, N): # j를 한번씩 늘리면서 실행(cause While문)\r\n    while i > 0 and pat[i] != pat[j]:\r\n      i = table[i-1]\r\n    if pat[i] == pat[j]:\r\n        i += 1\r\n        table[j] = i\n</code></pre>\n<hr>\n<pre><code class=\"language-python\"># KMP Algorithm with computeLPSArray func\r\ndef kmp(string, pat):\r\n  table = computeLPSArray9(pat)\r\n\r\n  result = [0]\r\n  i = 0\r\n  for j in range(len(string)): # 순차적으로 탐색\r\n    while i > 0 and pat[i] != string[j]:\r\n      i = table[i-1]\r\n    if pat[i] == string[j]:\r\n        i += 1\r\n        if i == len(pat):\r\n          result.append(j - 1 + 1)\r\n          i = table[i-1]\r\n  return result\r\n\n</code></pre>\n</li>\n</ul>\n<h3>2-3. Boyer-Moore Algorithm</h3>\n<p><a href=\"https://wondytyahng.tistory.com/entry/%EB%B3%B4%EC%9D%B4%EC%96%B4%EB%AC%B4%EC%96%B4\">Boyer-Moore explanation with images</a></p>\n<pre><code class=\"language-python\">\r\ndef bm_match(txt, pat):\r\n\t# Making skip table for all the ASCII\r\n  skip = [None] * 256\r\n\r\n\tfor pt in range(256): # values which is not in the pat\r\n\t\tskip[pt] = len(pat)\r\n\r\n\tfor i, pt in enumerate(pat):  # for values in the pattern\r\n\t\tskip[ord(pt)] = len(pat) - i - 1\r\n\r\n\t# Searching\r\n  result = []\r\n\twhile pt &#x3C; len(txt):  # index for text\r\n\t\tpp = len(pat) -1  # idnex for pattern. Always compare from the end\r\n\t\twhile txt[pt] == pat[pp]: #\r\n\t\t\tif pp == 0: # when find the pattern in the string\r\n\t\t\t\tresult.append(pt)\r\n\t\t\tpt -= 1\r\n\t\t\tpp -= 1\r\n    # if (the order of 'c' in the 'pattern' from the behind) > (the order of 'c' in the 'txt section' from the behind) \r\n    # for the normal case -> skip as the table\r\n    # for the abnormal case -> skip just one\r\n\t  pt += skip[ord(txt[pt])] if skip[ord(txt[pt])] > len(pat) - pp else len(pat) - pp\r\n\t\r\n\treturn -1\n</code></pre>\n<ul>\n<li><a href=\"https://dbehdrhs.tistory.com/72\">for the pt+=</a></li>\n</ul>\n<hr>\n<h2>3. Encryption</h2>\n<h3>3-1. Caesar cipher</h3>\n<ul>\n<li>string combination of 'A<del>Z'and 'a</del>z', and the key is n</li>\n</ul>\n<pre><code class=\"language-python\">def Caesar(string, n):\r\n  string = list(string)\r\n\r\n  for i in range(len(string)):\r\n    if string[i].isupper():\r\n      s[i] = chr((ord(string[i]) - ord('A') + n) % 26 + ord('A'))\r\n    elif string[i].islower():\r\n      s[i] = chr((ord(string[i]) - ord('a') + n) % 26 + ord('a'))\r\n    \r\n  return ''.join(string)\r\n\n</code></pre>\n<h3>3-2. bit array - xor</h3>\n<table>\n<thead>\n<tr>\n<th>a</th>\n<th>b</th>\n<th>a^b</th>\n<th>(a^b)^b</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>---</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>## 4. Compression</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>### 4-1. Run-length Encoding</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>```python</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>def RLE(string):</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>string += chr(ord(string[-1]) + 1)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>encoded ''</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>cnt = 1</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>for i in range(1, len(string)):</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<pre><code>if string[i] == string[i-1]:\r\n  cnt += 1\r\nelse:\r\n  encoded += string[i-1] + str(cnt)\r\n  cnt = 1\n</code></pre>\n<p>return encoded</p>\n<pre><code>### 4-2. Huffman_Coding\r\n[허프만코딩_블로그설명](len(string))\r\n* distinctive prefix\r\n---\r\n## 5. Palindrome\r\n* the longest parlindrome in the string\r\n```python\r\ndef longestPalindorme(s):\r\n  def expand(left, right):\r\n    while left >= 0 and right &#x3C; len(s) and s[left] == s[right]:\r\n      left -= 1\r\n      right += 1\r\n    return s[left + 1:right]\r\n  \r\n  if len(s) &#x3C; 2 or s == s[::-1]:\r\n    return s\r\n\r\n  result = ''\r\n  for i in range(len(s)-1):\r\n    result = max(result, expand(i, i+1), expand(i, i+2), key=len)\r\n  return result\n</code></pre>"}},"pageContext":{"pagePath":"posts/Algorithm/First/String.md","id":"f2a7b08b-7678-531c-8d95-91c659a104ac","parent":{"id":"edd944a5-b4ce-5d7f-a1e0-0f22b11c80ab","name":"String","relativePath":"Algorithm/First/String.md"}}},"staticQueryHashes":["1274812890","3935499650","82772122"],"slicesMap":{}}