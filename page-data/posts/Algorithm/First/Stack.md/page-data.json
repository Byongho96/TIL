{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/Algorithm/First/Stack.md/","result":{"data":{"markdownRemark":{"id":"fc8ff0c5-29ea-5eb5-bf6c-6e6581d2b490","html":"<h1>Stack</h1>\n<h2>1. Property</h2>\n<ul>\n<li><strong>linear data structure</strong>\n<ul>\n<li>one data -> another data</li>\n</ul>\n</li>\n<li><strong>LIFO(Last-In-First-Out)</strong></li>\n</ul>\n<h2>2. Operators</h2>\n<ul>\n<li>push(obj)\n<ul>\n<li>top += 1\n<ul>\n<li>top: pointer for the last item</li>\n</ul>\n</li>\n<li>stk[top] = x</li>\n</ul>\n<pre><code class=\"language-python\"># append is slow\r\ndef push(item):\r\n    s.append(item)\n</code></pre>\n<pre><code class=\"language-python\"># Usually stack size is confined\r\ndef push(item, size):\r\n    global top\r\n    top += 1\r\n    if top == size:\r\n        print('Overflow')\r\n    else:\r\n        stack[top] = item\r\n\r\nsize = 10\r\nstack = [0] * size\r\ntop = -1\n</code></pre>\n<pre><code class=\"language-python\">top += 1\r\nstack[top] = item\n</code></pre>\n</li>\n<li>pop\n<ul>\n<li>You don't have to actually pop the item. JUST USE THE POINTER</li>\n</ul>\n<pre><code class=\"language-python\">def pop():\r\n    if len(stack) == 0:\r\n        return\r\n    else:\r\n        return stack.pop(-1)\n</code></pre>\n<pre><code class=\"language-python\"># Usually stack size is confined\r\ndef pop():\r\n    global top\r\n    if top == -1:\r\n        print('Underflow')\r\n        return\r\n    else:\r\n        top -= 1\r\n        return stack.pop[top+1]\r\nprint(pop())\n</code></pre>\n<pre><code class=\"language-python\">if top > -1:\r\n    top -= 1\r\n    print(stack[top+1])\n</code></pre>\n</li>\n<li>isEmpty</li>\n<li>peek</li>\n</ul>\n<h2>3. Application</h2>\n<h3>3-1. <strong>Parenthesis Check</strong></h3>\n<ul>\n<li>err1: the stack is empty while checking</li>\n<li>err2: wrong pair</li>\n<li>err2: the stack is not empty after checking</li>\n</ul>\n<h3>3-2. <strong>Functon Call</strong></h3>\n<ul>\n<li>when a function is called, local variables and address to be ruturned are saved in the stack memory</li>\n<li>main -> f1 -> f2 -> f1 -> main</li>\n</ul>\n<h3>3-3. <strong>Recursive Function Call</strong></h3>\n<ul>\n<li>allocating new memory with different paramter</li>\n<li>later called function ends earlier\n<pre><code class=\"language-python\">def f(i, N): # i: current step, N: goal step\r\n    if i==N:\r\n        print(f'{i}: to do in the final step')\r\n        return\r\n    else:\r\n        print(f'{i}: to do in the middle step')\r\n        f(i+1, N)\r\nf(0,3)\r\n# 0: to do in the middle step\r\n# 1: to do in the middle step\r\n# 2: to do in the middle step\r\n# 3: to do in the final step\n</code></pre>\n<pre><code class=\"language-python\">def f(i, N):\r\n    if i == N:\r\n        print('Out of range')\r\n        return\r\n    else:\r\n        print(A[i])\r\n        f(i+1, N)\r\nN = 3\r\nA = [1, 2, 3]\r\nf(0, N)\r\n# 1\r\n# 2\r\n# 3\r\n# Out of range\n</code></pre>\n</li>\n<li><strong>Memoization</strong>\n<ul>\n<li>recursive function uses too much memory cause the number of function calls increases rapidly</li>\n<li>Skip repeated operations by Memorizing the already calculated data\n<pre><code class=\"language-python\">def fibo(n):\r\n    if n>= 2 and len(memo) &#x3C;= n: # memo이 대응값이 없으면\r\n        memo.append(fibo(n-1) + fibo(n-2))  # memo에 추가\r\n    return memo[n]  # memo에서 데이터를 읽어서 반환\r\nmemo = [0, 1]\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>DP(Dynamic Programming)</strong>\n<ul>\n<li>loop</li>\n<li>Solve for small subsets first -> solve for larger subsets -> solve for the original set\n<pre><code class=\"language-python\">def fibo(n):\r\n    f = [0, 1]\r\n    for i in range(2, n+1):\r\n        f.append(f[i-1] + f[i-2])\r\n    return f[n]\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3>3-4. <strong>DFS(Depth First Search)</strong></h3>\n<ul>\n<li><strong>Stack can be used in DFS for saving the path!!</strong></li>\n<li>DFS Algorithm\n<ol>\n<li>visit the node 'v'</li>\n<li>search the adjacent nodes\n<ul>\n<li>if there is a node 'w' that is not visted yet, push node 'v' into the stack and visit the node 'w'</li>\n<li>Otherwise, pop the stack and go back to the previous node</li>\n</ul>\n</li>\n<li>repeat 1~2. until the stack is empty</li>\n</ol>\n<img src=\"images/StackTree.jpg\" alt=\"Tree\">\n<pre><code class=\"language-python\">adjList = [[1, 2],      # 0\r\n           [0, 3, 4],   # 1\r\n           [0, 4],      # 2\r\n           [1, 5],      # 3\r\n           [1, 2, 5],   # 4\r\n           [3, 4, 6],   # 5\r\n           [5]]\n</code></pre>\n<pre><code class=\"language-python\"># iterative\r\ndef DFS(v, N):\r\n    visited = [0] * N # for cheking whether have visited\r\n    stack = [0] * N\r\n    top = -1\r\n\r\n    visited[v] = 1  # strat point\r\n    # print(v)\r\n    while True:\r\n        for w in adjList[v]:\r\n            if visited[w] == 0:\r\n                top += 1\r\n                stack[top] = v\r\n                v = w\r\n                visited[v] = 1\r\n                # print(v)\r\n                break\r\n        else:\r\n            if top != -1:\r\n                v = stack[top]\r\n                top -= 1\r\n            else:\r\n                break\r\n\r\nDFS(0, 7) # 0, 1, 3, 5, 4, 2, 6\n</code></pre>\n<pre><code class=\"language-python\"># recursive\r\ndef DFS(v, N):\r\n    visited = [0] * 7\r\n    visited[v] = 1  # strat point\r\n    # print(v)\r\n    for w in adjList[v]:\r\n        if visited[w] == 0:\r\n            DFS(w)\r\n\r\nDFS(0) # 0, 1, 3, 5, 4, 2, 6\n</code></pre>\n</li>\n<li>Making the graph from the edges data\n<pre><code class=\"language-python\">V, E = map(int, input().split()) # 0~V번의 점, E개의 간선\r\nadjList = [[] for _ in range(V+1)]  # V+1 개의 노드\r\nfor _ in range(E):\r\n    a, b = map(int, input().split())\r\n    adjList[a].append(b)\r\n    adjList[b].append(a)\n</code></pre>\n</li>\n</ul>\n<h3>3-5. Postfix notation</h3>\n<ul>\n<li>infix notation: A + B</li>\n<li>postfix notation: AB+</li>\n<li>infix -> postfix\n<ul>\n<li>\n<p>the order</p>\n<table>\n<thead>\n<tr>\n<th>operator</th>\n<th>order</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>*</td>\n<td>2</td>\n</tr>\n<tr>\n<td>/</td>\n<td>2</td>\n</tr>\n<tr>\n<td>+</td>\n<td>1</td>\n</tr>\n<tr>\n<td>-</td>\n<td>1</td>\n</tr>\n<tr>\n<td>(</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>get a token</p>\n<ul>\n<li>if operand: print</li>\n<li>if operator\n<ul>\n<li>if '(':\n<ul>\n<li>push</li>\n</ul>\n</li>\n<li>elif ')':\n<ul>\n<li>append(pop) until '('</li>\n<li>pop '('</li>\n</ul>\n</li>\n<li>elif order(the operator) > order(stack[top]):\n<ul>\n<li>push</li>\n</ul>\n</li>\n<li>else:\n<ul>\n<li>append(pop) until lower operator</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-python\">\r\n\n</code></pre>\n</li>\n</ul>\n</li>\n<li>operation\n<ul>\n<li>if operand: push</li>\n<li>if operator:\n<ul>\n<li>n1 = stack.pop</li>\n<li>n2 = stack.pop</li>\n<li>stack.push(result)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>"}},"pageContext":{"pagePath":"posts/Algorithm/First/Stack.md","id":"fc8ff0c5-29ea-5eb5-bf6c-6e6581d2b490","parent":{"id":"9b9317ef-8c34-5ddf-937b-58385d4ddd1f","name":"Stack","relativePath":"Algorithm/First/Stack.md"}}},"staticQueryHashes":["1274812890","3935499650","82772122"],"slicesMap":{}}