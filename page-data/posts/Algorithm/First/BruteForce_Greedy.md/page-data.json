{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/Algorithm/First/BruteForce_Greedy.md/","result":{"data":{"markdownRemark":{"id":"05a6e0e7-adb0-5387-a88e-ebaec262b7eb","html":"<h1>0. Intro</h1>\n<p>알고리즘은 크게 2가지로 분류할 수 있다.</p>\n<p>모든 경우의 수를 고려하여 최적해를 찾아내는 <strong>완전탐색(Brute-Force)기반 알고리즘</strong>, 그리고 지역적인 최적값 선택의 연속으로 전역적인 최적해를 찾아내는 <strong>탐욕(Greedy)알고리즘</strong>이 있다.</p>\n<p>단, 탐욕 알고리즘이 적용되기 위해서는 제약조건이 있다.</p>\n<ul>\n<li>앞의 선택이 이후의 선택에 영향을 주지 않는다.</li>\n<li>문제에 대한 최적해가 부분문제에 대해서도 최적해이다.</li>\n</ul>\n<h1>1. Brute-Force</h1>\n<ul>\n<li>Permutation</li>\n<li>Combination</li>\n<li>Powerset</li>\n<li>Backtracking</li>\n<li>Dynamic Programming(memoization, tabulation)</li>\n<li>BFS, DFS</li>\n</ul>\n<h2>1.1. Permutation</h2>\n<p><strong>Iteration</strong></p>\n<pre><code class=\"language-python\"># {1, 2, 3}\r\nfor i1 in range(1, 4):\r\n    for i2 in range(1, 4):\r\n        if i2 != i1:\r\n            for i3 in range(1, 4):\r\n                if i3 != i2 and i3 != i1:\r\n                    print(i1, i2, i3)\n</code></pre>\n<ul>\n<li>recursive(Johnson-Trotter, Minimum-change)</li>\n</ul>\n<pre><code class=\"language-python\"># array p[] with N elements\r\ndef perm(n, N):\r\n    if n == N:\r\n        print(p)\r\n        return\r\n    for i in range(n, N):\r\n        p[n], p[i] = p[i], p[n]\r\n        perm(n+1, N)\r\n        p[n], p[i] = p[i], p[n]\n</code></pre>\n<ul>\n<li>recursive sorted</li>\n</ul>\n<pre><code class=\"language-python\"># array p[] with N elements\r\nused = [0] * N\r\narr = [0] * N\r\ndef perm(n, N):\r\n    if n == N:\r\n        print(arr)\r\n        return\r\n    for i in range(N):\r\n        if not used[i]:\r\n            arr[n] = p[i]\r\n            used[i] = 1\r\n            pern(n+1, N)\r\n            used[i] = 0\n</code></pre>\n<h2>1.2. Combinations</h2>\n<ul>\n<li>recursive</li>\n</ul>\n<pre><code class=\"language-python\"># arr : len(arr) == N\r\n# comb : len(comb) == R\r\ndef comb(n, r):\r\n    if r == 0:\r\n        print(comb)\r\n        return\r\n    elif n &#x3C; r:\r\n        return\r\n    else\r\n        comb[r-1] = arr[n-1]\r\n        comb(n-1, r-1)\r\n        comb(n-1, r)\r\ncomb(N, R)\n</code></pre>\n<h3>1-3. Powerset</h3>\n<ul>\n<li>iteration</li>\n</ul>\n<pre><code class=\"language-python\"># a set of 4 elements\r\nbit = [0] * 4\r\nfor i1 in range(2):\r\n    bit[0] = 1\r\n    for i2 in range(2):\r\n        bit[1] = i2\r\n        for i3 in range(2):\r\n            bit[2] = i3\r\n            for i4 in range(2):\r\n                bit[3] = i4\r\n                print(bit)\n</code></pre>\n<ul>\n<li>binary counting iteration</li>\n</ul>\n<pre><code class=\"language-python\">arr = [3, 6, 7, 1, 5, 4]\r\nn = len(arr)\r\n\r\nfor i in range(1&#x3C;&#x3C;n): # 2**n == 부분집합의 갯수\r\n    for j in range(n):\r\n        if i &#x26; (1&#x3C;&#x3C;j):\r\n            print(arr[j], end=' ')\r\n    print()\n</code></pre>\n<ul>\n<li>recursive</li>\n</ul>\n<pre><code class=\"language-python\">arr = [0] * N\r\ndef powerset(n):\r\n    if n == N:\r\n        print(arr)\r\n        return\r\n    arr[n] = 0\r\n    powerset(n+1)\r\n    arr[n] = 1\r\n    powerset(n+1)\n</code></pre>\n<h3>1-4. Backtracking</h3>\n<ul>\n<li>Brute-force with prunning</li>\n<li>N-Queen</li>\n</ul>\n<pre><code class=\"language-python\">def N_Queen(n):\r\n    if n == N:\r\n        ans += 1\r\n        return\r\n    for j in range(N):\r\n        if j not in q1 and (n+j) not in q2 and (n-j) not in q2:\r\n            q1.append(j)\r\n            q2.append(n+j)\r\n            q3.append(n-j)\r\n            N_Queen(n+1)\r\n            q1.pop()\r\n            q2.pop()\r\n            q3.pop()\n</code></pre>\n<h3>1-5. DFS</h3>\n<ul>\n<li>recursive</li>\n</ul>\n<pre><code class=\"language-python\">def DFS_recursive(v)\r\n    visited[v] = 1\r\n    for w in adjLst[v]:\r\n        if not visited[w]:\r\n            DFS_recursive[w]\n</code></pre>\n<ul>\n<li>iteration(path)</li>\n</ul>\n<pre><code class=\"language-python\">def DFS_iteration(v):\r\n    visited = [0] * N\r\n    stk = []\r\n\r\n    visited[v] = 1\r\n    while True:\r\n        for w in adjLst[v]:\r\n            if not visited[w]:\r\n                stk.append(v)\r\n                v = w\r\n                visited[v] = 1\r\n                break\r\n        else:\r\n            if stk:\r\n                v= stk.pop()\r\n            else:\r\n                break\n</code></pre>\n<ul>\n<li>iteration(selection)</li>\n<li>Not technically DFS, but for brute force</li>\n</ul>\n<pre><code class=\"language-python\">def DFS_iteration2(v):\r\n    visited = [0] * N\r\n    stk = []\r\n\r\n    stk.append(v)\r\n    visited[v] = 1\r\n    while stk:\r\n        v = stk.pop()\r\n        for w in adjLst[v]:\r\n            if not visited[w]:\r\n                stk.append(w)\r\n                visited[w] = 1\n</code></pre>\n<pre><code class=\"language-python\">def DFS_iteration2(v):\r\n    visited = [0] * N\r\n    stk = []\r\n\r\n    stk.append(v)\r\n    while stk:\r\n        v = stk.pop()\r\n        if not visited[v]:\r\n            visited[v] = 1\r\n            # visit(V)\r\n            for w in adjLst[v]:\r\n                if not visited[w]:\r\n                    stk.append(w)\n</code></pre>\n<h3>1-6. BFS</h3>\n<ul>\n<li>iteration</li>\n</ul>\n<pre><code class=\"language-python\">def bfs(v):\r\n    visited = [0] * N\r\n    q = deque()\r\n\r\n    q.append(v)\r\n    visited[v] = 1\r\n\r\n    while q:\r\n        v = q.popleft()\r\n        for w in adjLst[v]:\r\n            if not visited[w]:\r\n                visited[w] = visited[v] + 1\r\n                q.append(w)\n</code></pre>\n<ul>\n<li>shortest path</li>\n</ul>\n<pre><code class=\"language-python\">def bfs(v):\r\n    distance = [INF] * (N)\r\n    q =deque()\r\n\r\n    q.append(v)\r\n    distance[v] = 0\r\n\r\n    while q:\r\n        v = q.popleft()\r\n        for w, d in adjLst[v]:\r\n            if distance[w] > distance[v] + w:\r\n                distance[w] = distance[v] + w\r\n                q.append(w)\r\n\r\n    return distance[-1]\n</code></pre>\n<h2>2. Greedy(Proved)</h2>\n<h3>2-1. Prim</h3>\n<ul>\n<li>Basic</li>\n</ul>\n<pre><code class=\"language-python\">def prim(s):\r\n    weight = [INF] * (V + 1)\r\n    MST = [0] * (V + 1)\r\n\r\n    weight = 0\r\n    MST[s] = 1\r\n\r\n    for _ in range(V):\r\n        mn = INF\r\n        i_min = -1\r\n        for i in range(V+1):\r\n            if not MST[i] and weight[i] &#x3C; mn:\r\n                mn = weight[i]\r\n                i_min = i\r\n        MST[i_min] = 1\r\n        for adj, w in adjLst[i_min]:\r\n            if not MST[adj]:\r\n                weight[adj] = min(weight[adj], w)\r\n\r\n    print(sum(weight))\n</code></pre>\n<ul>\n<li>heap</li>\n</ul>\n<pre><code class=\"language-python\">def prim(start, edges):\r\n    mst = []\r\n    adjLst = [[] for _ in range(V+1)]\r\n    for w, n1, n2 in edges:\r\n        adjLst[n1].append((w, n1, n2))\r\n        adjLst[n2].append((w, n2, n1))\r\n\r\n    connected = set(start)\r\n    edges_heap = adjLst[s]\r\n    heapify(edges_heap)\r\n\r\n    while edges_heap:\r\n        w, n1, n2 = heappop(edges_heap)\r\n        if n2 not in connected:\r\n            connected.add(n2)\r\n            mst.append((w, n1, n2))\r\n\r\n            for edge in adjLst[n2]:\r\n                if edge[2] not in connected:\r\n                    heappush(edges_heap, edge)\n</code></pre>\n<h3>2-2. Kruskal</h3>\n<ul>\n<li>Kruskal</li>\n</ul>\n<pre><code class=\"language-python\">V, E = map(int, input().split())\r\npar = [i for i in range(V + 1)]\r\nrank = [0] * (V + 1)\r\n\r\ndef find_set(x):\r\n    while x != par[x]:\r\n        x = par[x]\r\n    return x\r\n\r\n# union by rank\r\ndef union(x, y):\r\n    X = find_set(x)\r\n    Y = find_set(y)\r\n    if rank[X] == rank[Y]:\r\n        par[Y] = X\r\n        rank[X] += 1\r\n    elif rank[X] &#x3C; rank[Y]:\r\n        par[X] = Y\r\n    else:\r\n        par[Y] = X\r\n\r\ncnt = 0\r\nweight = 0\r\nedges.sort(key=weight)\r\nfor a, b, w in edges:\r\n    if find_set(a) != find_set(b):\r\n        union(a, b)\r\n        weight += w\r\n        cnt += 1\r\n        if cnt == V:\r\n            break\r\n\r\nprint(weight)\n</code></pre>\n<h3>2-3. Dijkstra</h3>\n<ul>\n<li>Basic</li>\n</ul>\n<pre><code class=\"language-python\">def dijkstra(s):\r\n    distance = [INF] * (V+1)\r\n    visited = [0] * (V+1)\r\n\r\n    distance[s] = 0\r\n    for _ in range(V):\r\n        mn = INF\r\n        i_min = -1\r\n        for i in range(V+1):\r\n            if not visited[i] and distance[i] &#x3C; mn:\r\n                mn = distance[i]\r\n                i_min = i\r\n        visited[i_min] = 1\r\n        for w, d in adjLst[i_min]:\r\n            # if not visited[w]:\r\n            distance[w] = min(distance[w], distance[i_min] + d)\r\n\r\n    return distance[-1]\n</code></pre>\n<ul>\n<li>heap</li>\n</ul>\n<pre><code class=\"language-python\">def dijkstra(s):\r\n    distance = [INF] * (V+1)\r\n    heap = []\r\n    heapq.heappush(heap, (0, s))\r\n    distance[s] = 0\r\n\r\n    while heap:\r\n        dist, now = heapq.heappop(heap)\r\n        if distance[now] &#x3C; dist:    # 현재 노드가 처리된적 있다면 무시\r\n            continue\r\n        for next in adjLst[now]:   # 현재 노드의 주변 노드를 탐색\r\n            cost = dist + next[1]\r\n            if cost &#x3C; distance[next[0]]:    # 현재 노드를 거치는 것이 더 빠를 경우\r\n                distance[next[0]] = cost\r\n                heapq.heappush(q, (cost, i[0]))\n</code></pre>\n<!-- * shortest path\r\n```python\r\ndef bfs(v):\r\n    distance = [INF] * (N)\r\n    q =deque()\r\n\r\n    q.append(v)\r\n    distance[v] = 0\r\n\r\n    while q:\r\n        v = q.popleft()\r\n        for w, d in adjLst[v]:\r\n            if distance[w] > distance[v] + w:\r\n                distance[w] = distance[v] + w\r\n                q.append(w)\r\n\r\n    return distance[-1]\r\n``` -->\n<h3>2-4. Bellman-Ford</h3>\n<ul>\n<li>minus edge, and minus cycle\n<ul>\n<li>방문하지 않은 노드 뿐만 아니라, 모든 간선에 대해서 최단거리를 확인</li>\n<li>N개의 정점에 대해서 N번째 갱신 시, 테이블의 변화가 있다면 음수 사이클이 존재</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-python\">def Bellman_Ford(s):\r\n    dist[s] = 0\r\n    for i in range(V):\r\n        for j in range(E):      # 간선기준으로 업데이트 실행\r\n            cur = edges[j][0]\r\n            next = edges[j][1]\r\n            cost = edges[j][2]\r\n            if dist[cur] != INF and dist[next] > dist[cur] + cost:  # 연결된 간선 중 업데이트 요소가 있는 경우\r\n                dist[next] = dist[cur] + cost\r\n                if i == V - 1:\r\n                    return True # V번째 반복에도 업데이트가 있으면 음의 사이클 존재\r\n    return False\r\n\r\ndist = [INF] * (V + 1)\r\nedges = []\r\nfor _ in range(E):\r\n    n1, n2, w = map(int, input().split())\r\n    edges.append((n1, n2, w))\r\n\r\nif Bellman_Ford(1): # 음의 순환\r\n    print(-1)\r\nelse:\r\n    print(destination)\n</code></pre>\n<h3>2-5. Floyd-Warshall</h3>\n<ul>\n<li>모든 정점에서 모든 정점으로의 최단 경로</li>\n</ul>\n<pre><code class=\"language-python\">graph = [[INF] * (n + 1) for _ in range(n + 1)]\r\n\r\nfor i in range(1, n + 1):\r\n    graph[i][i] = 0\r\n\r\nfor _ in range(E):\r\n    n1, n2, w = map(int, input().split())\r\n    graph[n1][n2] = w\r\n\r\nfor k in range(1, n+1):\r\n    for n1 in range(1, n+1):\r\n        for n2 in range(1, n+1):\r\n            graph[n1][n2] = min(graph[n1][n2], graph[n1][k] + graph[k][n2])\r\n\r\nprint[s][e]\n</code></pre>\n<h3>2-7. Huffman tree</h3>\n<h2>3. Topological Sorting</h2>\n<ul>\n<li>사이클이 없는 방향 그래프에서 모든 노드를 방향성에 거스르지 않도록 순차나열</li>\n<li>진입차수(Indegree): 들어오는 간선 갯수</li>\n<li>진출차수(Outdegree): 나가는 간선 갯수</li>\n</ul>\n<pre><code class=\"language-python\">indgegree = [0] * (V+1)\r\nadjLSt = [[] for _ in range(V+1)]\r\n\r\nfor _ in range(E):\r\n    a, b = map(int, input().split())\r\n    adjLst[a].apkpend(b)\r\n    indegree[b] += 1\r\n\r\ndef topology_sort():\r\n    result = []\r\n    q = deque()\r\n\r\n    for i in range(1, V+1):\r\n        if indegree[i] == 0:\r\n            q.append(i)\r\n\r\n    while q:\r\n        now = q.popleft()\r\n        result.append(now)\r\n        for i in adjLst[now]:\r\n            indegree[i] -= 1\r\n            if indegree[i] == 0:\r\n                q.append(i)\r\n\r\n    return result\r\n\r\ntopology_sort()\n</code></pre>"}},"pageContext":{"pagePath":"posts/Algorithm/First/BruteForce_Greedy.md","id":"05a6e0e7-adb0-5387-a88e-ebaec262b7eb","parent":{"id":"91e40e84-52a9-5dab-a8bb-2844cb1f33cf","name":"BruteForce_Greedy","relativePath":"Algorithm/First/BruteForce_Greedy.md"}}},"staticQueryHashes":["1274812890","3935499650","82772122"],"slicesMap":{}}