{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/Algorithm/First/Tree.md/","result":{"data":{"markdownRemark":{"id":"a5b23b3e-57d7-5256-aad0-1959aa72a9f7","html":"<h1>Tree</h1>\n<h2>1. Definition</h2>\n<h3>1-1. Characteristic</h3>\n<ul>\n<li><strong>Non-linear Data Structure</strong>\n<ul>\n<li>one data -> N data</li>\n</ul>\n</li>\n<li><strong>Hierarchical Structure</strong></li>\n</ul>\n<h3>1-2. terms</h3>\n<ul>\n<li>node\n<ul>\n<li>elements of the tree</li>\n</ul>\n</li>\n<li>edge\n<ul>\n<li>line that links the parent node and the child node</li>\n</ul>\n</li>\n<li>root node\n<ul>\n<li>the start node of the tree</li>\n</ul>\n</li>\n<li>sibling node\n<ul>\n<li>nodes that have the same node as the parent node</li>\n</ul>\n</li>\n<li>ancestor node\n<ul>\n<li>nodes from the parent node to the root node</li>\n</ul>\n</li>\n<li>subtree\n<ul>\n<li>tree which is made when the edge to the parent node is removed</li>\n</ul>\n</li>\n<li>descendant node\n<ul>\n<li>nodes in the subtree</li>\n</ul>\n</li>\n<li>leaf node\n<ul>\n<li>node that doesn't have the child node</li>\n</ul>\n</li>\n<li>degree\n<ul>\n<li>degree of a node\n<ul>\n<li>the number of child nodes</li>\n</ul>\n</li>\n<li>degree of a tree\n<ul>\n<li>the biggest degree of nodes in the tree</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>height\n<ul>\n<li>height of a node\n<ul>\n<li>the number of edges between the current node and the root node</li>\n</ul>\n</li>\n<li>hegiht of a tree\n<ul>\n<li>the biggest height of nodes in the tree</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2>2. Binary Tree</h2>\n<h3>2-1. Definition</h3>\n<ul>\n<li><strong>every node can have 2 child nodes at maximum</strong></li>\n</ul>\n<h3>2-2. Characteristics</h3>\n<ul>\n<li>maximum numbor of ndes at level i == 2**i\n<ul>\n<li>1 : 2**0</li>\n<li>1 1 : 2**1</li>\n<li>1 1 1 1 : 2**2</li>\n</ul>\n</li>\n<li>(i + 1) &#x3C; number of nodes of the tree which height is i &#x3C; (2**(h+1) -1)</li>\n</ul>\n<h3>2-3. Types</h3>\n<ul>\n<li>Full Binary Tree(포화이진트리)\n<ul>\n<li>구글에 치면, 이건 Perfect Binary Tree이고, Full Binary Tree는 모든 노드의 자식노드가 0개 혹은 2개인 것</li>\n<li>when the height is h, number of nodes is (2**(h+1) -1)</li>\n</ul>\n</li>\n<li>Complete Binary Tree(완전이진트리)\n<ul>\n<li>when there're n nodes in the tree, there's no empty seat from the root node to the nth node</li>\n</ul>\n</li>\n<li>Skewed Binary Tree(편향이진트리)\n<ul>\n<li>all the nodes have the only one node in the same direction</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"./images/Types_of_tree.jpg\" alt=\"types of trees\"></p>\n<h3>2-4. Traversal(basically dfs)</h3>\n<ul>\n<li><strong>Preorder traversal</strong>\n<ul>\n<li>parent -> left -> right</li>\n</ul>\n</li>\n<li><strong>Inorder traversal</strong>\n<ul>\n<li>left -> parent -> right</li>\n</ul>\n</li>\n<li><strong>Postorder traversal</strong>\n<ul>\n<li>left -> right -> pare</li>\n</ul>\n</li>\n<li>tips\n<ul>\n<li>the number of nodes in subtee\n<ol>\n<li>global cnt += 1 at every visit</li>\n<li>return 1 if leaf_node else (L + R + 1)</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3>2-5. Expression of compelete binary tree with array</h3>\n<ul>\n<li>root node = 1</li>\n<li>numbering from left to right</li>\n</ul>\n<p><img src=\"./images/expression_binarytree.jpg\" alt=\"expression of binary tree\"></p>\n<ul>\n<li>parent node = i // 2</li>\n<li>left child node = 2 * i</li>\n<li>right child node = 2 * i + 1</li>\n<li>the start node of level i = 2**i</li>\n<li>the size of the array = 2**(h + 1)\n<ul>\n<li>array[0] is empty</li>\n</ul>\n</li>\n</ul>\n<h3>2-6. Expression of binary tree with array</h3>\n<ul>\n<li>save child node using parent node as index\n<ul>\n<li>for traversal</li>\n<li>left_child = []</li>\n<li>right_child = []</li>\n</ul>\n<pre><code class=\"language-python\"># There's no relation between leftchild and rightchild\r\n# input(number of edges, parent node - child node)\r\n# 4\r\n# 1 2 1 3 3 4 3 5\r\nE = int(input())\r\narr = list(map(int, input().split()))\r\nV = E + 1\r\nch1 = [0] * (V + 1)\r\nch2 = [0] * (V + 1)\r\nfor i in range(E):\r\n    p, c = arr[i*2], arr[i*2 + 1]\r\n    if ch1[p] == 0:\r\n        ch1[p] = c\r\n    else:\r\n        ch2[p] = c\r\n\r\ndef preorder(n):\r\n    if n:\r\n        print(n)    # visit(n)\r\n        preorder(ch1[n])\r\n        preorder(ch2[n])\r\n\r\npreorder(root) # 1, 2, 3, 4, 5\n</code></pre>\n</li>\n<li>save parent node using child node as index\n<ul>\n<li>for finding the root or parents</li>\n<li>parent = []</li>\n</ul>\n<pre><code class=\"language-python\"># There's no relation between leftchild and rightchild\r\n# input(number of edges, parent node - child node)\r\n# 4\r\n# 1 2 1 3 3 4 3 5\r\nE = int(input())\r\narr = list(map(int, input().split()))\r\nV = E + 1\r\npar = [0] * (V + 1)\r\nfor i in range(E):\r\n    p, c = arr[i*2], arr[i*2 + 1]\r\n    par[c] = p \r\n\r\ndef find_root(V):\r\n    for i in range(1, V+1):\r\n        if par[i] == 0:\r\n            return i\r\n\r\nroot = find_root(V)\r\nprint(root) # 1\n</code></pre>\n</li>\n</ul>\n<h3>2-7. Expression Binary Tree(수식 트리)</h3>\n<ul>\n<li>definition\n<ul>\n<li>leaf nodes: operand</li>\n<li>non leaf nodes: operator</li>\n</ul>\n</li>\n<li>traversal\n<ul>\n<li>inorder traversal -> infix notation</li>\n<li>postorder traversal -> postfix notation</li>\n<li>preorder traversal -> prefix notation</li>\n</ul>\n</li>\n</ul>\n<h3>2-8. Binary Search Tree(이진탐색트리)</h3>\n<ul>\n<li>characteristics\n<ul>\n<li>left subtrees &#x3C; root node &#x3C; right subtree</li>\n<li>inorder traversal -> sorted</li>\n</ul>\n</li>\n<li>search\n<ul>\n<li>if key == root; end</li>\n<li>elif key &#x3C; root; search the left subtree</li>\n<li>elif key > root; search the right subree</li>\n</ul>\n</li>\n<li>Time complexity for insert, delete, access\n<ul>\n<li>O(h)\n<ul>\n<li>average: O(log N)</li>\n<li>worst: O(log N)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Python implementation</li>\n</ul>\n<pre><code class=\"language-python\">class Node:\r\n    def __init__(self, value):\r\n        self.value = value\r\n        self.left = None\r\n        self.right = None\r\n\r\nclass BST:\r\n    # 생성자\r\n    def __init__(self, root):\r\n        self.root = root\r\n    # 추가\r\n    def insert(self, value):\r\n        self.cur = self.root\r\n        while True:\r\n            if value &#x3C; self.cur.value:\r\n                if self.cur.left:\r\n                    self.cur = self.cur.left\r\n                else:\r\n                    self.cur.left = Node(value)\r\n                    break\r\n            else:\r\n                if self.cur.right:\r\n                    self.cur = self.cur.right\r\n                else:\r\n                    self.cur.right = Node(value)\r\n                    break\r\n    # 검색\r\n    def search(self. value):\r\n        self.cur = self.root\r\n        while self.cur:\r\n            if value == self.cur.value:\r\n                return True\r\n            elif value &#x3C; self.cur.value:\r\n                self.cur = self.cur.left\r\n            else:\r\n                self.cur = self.cur.right\r\n        return False\r\n\r\n    # 삭제\r\n    def delete(self, value):\r\n        # 노드 검색\r\n        is_exist = False\r\n        self.cur = self.root\r\n        self.par = None\r\n        while self.cur:\r\n            if value == self.cur.value:\r\n                is_exist = True\r\n                break\r\n            elif value &#x3C; self.cur.value:\r\n                self.par = self.cur\r\n                self.cur = self.cur.left\r\n            else:\r\n                self.par = self.cur\r\n                self.cur = self.cur.right\r\n        if is_search == False:\r\n            return False\r\n\r\n        # 자식 노드가 없을 때\r\n        if self.cur.left == None and self.cur.right == None\r\n            # 부모의 왼쪽 자식일 때\r\n            if value &#x3C; self.par.value:\r\n                self.par.left = None\r\n            # 부모의 오른쪽 자식일 때\r\n            else:\r\n                self.par.right = None\r\n\r\n        # 왼쪽 자식 노드만 있을 때\r\n        elif self.cur.left and self.cur.right == None\r\n             # 부모의 왼쪽 자식일 때\r\n            if value &#x3C; self.par.value:\r\n                self.par.left = self.cur.left\r\n            # 부모의 오른쪽 자식일 때\r\n            else:\r\n                self.par.right = self.cur.left\r\n\r\n        # 오른쪽 자식 노드만 있을 때\r\n        elif self.cur.left == None and self.cur.right\r\n             # 부모의 왼쪽 자식일 때\r\n            if value &#x3C; self.par.value:\r\n                self.par.left = self.cur.right\r\n            # 부모의 오른쪽 자식일 때\r\n            else:\r\n                self.par.right = self.cur.left\r\n\r\n        # 자식 노드 2개\r\n        else:\r\n            # 왼쪽 서브트리 중 가장 오른쪽\r\n            # 오른쪽 서브트리 중 가장 왼쪽\r\n            self.change = self.cur.right\r\n            self.change_par = self.cur\r\n            while change.left:\r\n                self.change_par = self.cur\r\n                self.change = self.cur.left\r\n\r\n            if self.change.right:\r\n                self.change_par.left = self.change.right\r\n            else:\r\n                self.change_par.left = self.None\r\n            \r\n             # 부모의 왼쪽 자식일 때\r\n            if value &#x3C; self.par.value:\r\n                self.par.left = self.change\r\n                self.change.left = self.change.left\r\n                self.change.right = self.change.right\r\n            # 부모의 오른쪽 자식일 때\r\n            else:\r\n                self.par.right = self.cur.left\r\n                self.change.left = self.change.left\r\n                self.change.right = self.change.right\r\n        return True\r\n\r\n\r\n\r\n\r\n\r\n    # 출력\r\n    def dump(self):\r\n        def inorder(node):\r\n            if node:\r\n                inorder(node.left)\r\n                print(node.value)\r\n                inorder(node.right)\r\n        root = self.root\r\n        inorder(root)\r\n\n</code></pre>\n<h2>3. heap</h2>\n<h3>3-1. definitoin</h3>\n<p><strong>complete binary tree structure for finding the maximum of minimum node</strong></p>\n<ul>\n<li>max heap\n<ul>\n<li>parent node > child node</li>\n</ul>\n</li>\n<li>min heap\n<ul>\n<li>parent node &#x3C; child node</li>\n</ul>\n</li>\n<li>Python implementation</li>\n</ul>\n<pre><code class=\"language-python\">class Heap:\r\n    def __init__(self):\r\n        self.heap = [None]\r\n    \r\n    def insert(self, value):\r\n        self.append(value)\r\n        index = len(self.heap) - 1\r\n        while index != 1:\r\n            par_index = self.parent(index)\r\n            if self.heap[par_index] &#x3C; self.heap[index]:\r\n                self.swqp(par_index, index)\r\n                index = par_index\r\n            else:\r\n                break\r\n    \r\n    def delete(self):\r\n        index = len(self.heap) - 1\r\n        if len(heap) == 0:\r\n            return False\r\n        self.swap(1, index)\r\n        max_value = self.heap.pop()\r\n        self.maxHeapify(0)\r\n        return max_value\r\n\r\n    def maxHeapify(self, i):\r\n        left = self.left(i)\r\n        right = self.right(i)\r\n        mx_idx = i\r\n\r\n        if left &#x3C; len(self.heap) and self.heap[mx_idx] &#x3C; self.heap[left]:\r\n            mx_idx = left\r\n        if right &#x3C; len(self.heap) and self.heap[mx_idx] &#x3C; self.heap[right]:\r\n            mx_idx = right\r\n        \r\n        if mx_idx != i:\r\n            self.swap(i, mx_idx)\r\n            self.maxHeapify(mx_idx)\r\n\r\n    def swap(self, i, j):\r\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]\r\n    \r\n    def parent(self, i):\r\n        return i // 2\r\n    \r\n    def left(self.i):\r\n        return 2 * i\r\n    \r\n    def right(self.i):\r\n        return 2 * i + 1\r\n\n</code></pre>\n<h3>3-2. Djkstra with heapq</h3>\n<pre><code class=\"language-python\">import heapq\r\nimport sys\r\n\r\ndef dijkstra(start):\r\n    distance = [sys.maxsize for _ in range(N)]\r\n    distance[start] = 0\r\n    q = []\r\n    heapq.heappush(q, (0, start))\r\n    while q:\r\n        # 힙의 데이터 최단거리 추출\r\n        dist, now = heapq.heappop(q)\r\n        # 업데이트 되기 전 정보이면 무시\r\n        if dinstance[now] &#x3C; dist:\r\n            continue\r\n        for w in adjLst[now]:\r\n            cost = dist + w[1]\r\n            if cost &#x3C; distance[w[0]]:\r\n                distance[w[0]] = cost\r\n                heapq.heappush(q, (cost, w[0]))\n</code></pre>"}},"pageContext":{"pagePath":"posts/Algorithm/First/Tree.md","id":"a5b23b3e-57d7-5256-aad0-1959aa72a9f7","parent":{"id":"32062b56-a944-51a7-bc23-f518f65563f6","name":"Tree","relativePath":"Algorithm/First/Tree.md"}}},"staticQueryHashes":["1274812890","3935499650","82772122"],"slicesMap":{}}