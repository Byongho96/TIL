{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/Algorithm/First/Backtracking.md/","result":{"data":{"markdownRemark":{"id":"0ef6d409-eed6-57e9-9233-7ea61e94b5b3","html":"<h2>Backtracking</h2>\n<p>: similar to ==DFS but reduce the number of cases== with appropriate condtion(pruning)</p>\n<ul>\n<li>Recursive function: when the depth is not deep</li>\n<li>Iteration with stack: when the dpeth is deep</li>\n<li>Review of DFS with recursive\n<pre><code class=\"language-python\"># recursive\r\ndef DFS(v, N):\r\n    visited = [0] * 7\r\n    visited[v] = 1  # strat point\r\n    # print(v)\r\n    for w in adjList[v]:\r\n        if visited[w] == 0:\r\n            DFS(w)\n</code></pre>\n</li>\n<li>Sturcture\n<pre><code class=\"language-python\">def DFS(n, ...):    # n은 시작 위치. 보통 0으로 시작\r\n    # 가지치기\r\n    if :\r\n        return\r\n    # 종료조건\r\n    if n >= N:  # if n == N이지만, 노이즈 고려로 현업에서는 >= 사용.\r\n                # N은 전달 받거나, 아니면 상위함수의 변수\r\n        Process for the answer\r\n        return\r\n\r\n    # 하부함수 호출\r\n    dfs(n+1, ...)   # 경우의 수 1\r\n    dfs(n+1, ...)   # 경위의 수 2\n</code></pre>\n</li>\n</ul>\n<p><strong>Powerset</strong></p>\n<pre><code class=\"language-python\">## arr를 0부터 채워넣음\r\ndef backtrack(arr, n, N):\r\n    global MAX_CANDIDATES\r\n    c = [0] * MAX_CANDIDATES\r\n\r\n    # 종료조건\r\n    if n == N:\r\n        process_solution(arr, n)\r\n\r\n    # 하부함수 호출\r\n    else:\r\n        ncandidates = construct_candidates(arr, n, N, c)\r\n        for i in range(ncandidates):    # ncanddiates는 2로 반환될 것\r\n            arr[n] = c[i]                     # a[n]이 0 또는 1\r\n            backtrack(arr, n + 1, N)\r\n\r\ndef process_solution(arr, n):\r\n    global ans_lst\r\n    lst = []\r\n    for i in range(len(arr)):\r\n        if arr[i]:\r\n            lst.append(nums[i])\r\n    ans_lst.append(lst)\r\n\r\ndef construct_candidates(arr, n, N, c):\r\n    c[0] = True\r\n    c[1] = False\r\n    return 2\r\n\r\nnums = list(map(int, input().split()))\r\nNMAX = len(nums)\r\nMAX_CANDIDATES = 2      # 트리가 나눠지는 경우의 수\r\nbit_arr = [0] * NMAX    # bit 배열로 부분집합의 포함여부 결정\r\nans_lst = []\r\n\r\nbacktrack(bit_arr, 0, NMAX)\r\nfor ele in ans_lst:\r\n    print(ele)          \r\n# input = 1, 2, 3\r\n# [1, 2, 3] [1, 2] [1, 3] [1] [2, 3] [2] [3] []      \n</code></pre>\n<p><strong>Permutation</strong></p>\n<pre><code class=\"language-python\">## arr를 1부터 채워넣음\r\ndef backtrack(arr, n, N):\r\n    global MAX_CANDIDATES\r\n    c = [0] * MAX_CANDIDATES\r\n    # 종료조건\r\n    if n == N:\r\n        for i in range(1, N + 1):\r\n            print(arr[i], end=' ')\r\n        print()\r\n    # 후보군 가지 실행\r\n    else:\r\n        n += 1  # 0부터 시작되었으므로, 먼저 1을 증가시키고 시작\r\n        ncandidates = construct_candidates(arr, n, N, c)\r\n        for i in range(ncandidates):\r\n            arr[n] = c[i]\r\n            backtrack(arr, n, N)\r\n\r\ndef construct_candidates(arr, n, N, c):\r\n    used_check = [False] * (NMAX + 1)\r\n\r\n    for i in range(1, n):           # 해당 숫자가 이미 쓰였는지 판단하는 check_list 업데이트\r\n        used_check[arr[i]] = True       # arr에 있는 숫자가, 곧 used_check의 인덱스\r\n\r\n    ncandidates = 0                 # 후보군의 인덱스를 만드는 용도\r\n    for i in range(1, N+1):\r\n        if used_check[i] ==  False:      # 안쓰여진 숫자들을 다음 후보군, 가지들로 선택\r\n            c[ncandidates] = i\r\n            ncandidates += 1\r\n    return ncandidates\r\n\r\nNMAX = int(input())\r\nMAX_CANDIDATES = NMAX                           # 트리가 나눠지는 경우의 수: 최대는 첫번재 수 고를 때, 숫자의 갯수 만큼\r\narr = [0] * (NMAX + 1)                          # bit 배열로 부분집합의 포함여부 결정\r\nans_lst = []\r\n\r\nbacktrack(arr, 0, NMAX)\n</code></pre>\n<ul>\n<li>1~5 개 중 3개를 골라 순열 만들기</li>\n</ul>\n<pre><code class=\"language-python\">def permu_backtracking(n,r):\r\n    if n == r:\r\n        print(permu)\r\n    else:\r\n        for i in range(N):\r\n            if not used[i]:\r\n                used[i] = 1\r\n                permu[n] = arr[i]\r\n                permu_backtracking(n+1, r):\r\n                used[i] = 0\r\n\r\nN = 5\r\nr =3\r\narr = [i for i in range(1, N + 1)]\r\nused= [0] * N\r\npermu= [0] * N\r\npermu_backtracking(0, r):\n</code></pre>\n<pre><code class=\"language-python\">def backtrack(n, N):\r\n    if n == N:\r\n        print(P)\r\n    else:\r\n        for j in range(n, N):       # 본인을 포함한 뒤에 숫자들과 바꿔가며 N - n 개의 후보군 형성\r\n            P[n], P[j] = P[j], P[n]\r\n            backtrack(n+1, N)\r\n            P[n], P[j] = P[j], P[n]     # 다음 for문을 위해 원상복구\r\n\r\nP = [1, 3, 4]\r\nbacktrack(0, len(P))\r\n# [1, 3, 4] [1, 4, 3] [3, 1, 4] [3, 4, 1] [4, 3, 1] [4, 1, 3]\n</code></pre>\n<p><strong>Subset Sum</strong></p>\n<pre><code class=\"language-python\"># target을 만족하는 부분집합의 갯수만을 구하는 백트래킹 예시 \r\ndef subset_sum(n, N, sm, target):\r\n    global answer\r\n    # 종료조건\r\n    if sm == target:\r\n        answer += 1\r\n        return\r\n    elif n == N:\r\n        return\r\n    # 가지치기\r\n    elif sm > target:\r\n        return\r\n    # 후보군 실행\r\n    else:\r\n        subset_sum(n+1, N, sm + A[n], target)    # A[i]가 포함된 경우\r\n        subset_sum(n+1, N, sm, target)           # A[i]가 포함되지 않은 경우\r\n\r\nA = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\nanswer = 0\r\nsubset_sum(0, len(A), 0, 10)\r\nprint(answer)   # 10\n</code></pre>\n<ul>\n<li>Pascal</li>\n</ul>\n<p><strong>n-Queen</strong>\r\n<a href=\"../../Baekjoon/9663_N_Queen.py\">BaekJoon_9663_N-Queen</a></p>"}},"pageContext":{"pagePath":"posts/Algorithm/First/Backtracking.md","id":"0ef6d409-eed6-57e9-9233-7ea61e94b5b3","parent":{"id":"eca6d33b-f9a8-5fb7-8cbb-bef1fb1654bd","name":"Backtracking","relativePath":"Algorithm/First/Backtracking.md"}}},"staticQueryHashes":["1274812890","3935499650","82772122"],"slicesMap":{}}