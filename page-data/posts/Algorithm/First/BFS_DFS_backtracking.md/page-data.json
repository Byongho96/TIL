{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/Algorithm/First/BFS_DFS_backtracking.md/","result":{"data":{"markdownRemark":{"id":"4c60d441-29cc-5f21-9145-7e084ed0bd4b","html":"<ol>\n<li>모든 경로 탐색(가능 여부): DFS, BFS</li>\n<li>경로의 수: DFS, (BFS)</li>\n<li>최단거리 탐색: BFS, (DFS)</li>\n<li>출발이 여러개: BFS</li>\n</ol>\n<ul>\n<li>BFS와 DFS 모두 반복의 경우, while과 for사이에서 visit(v)</li>\n<li>DFS_재귀함수의 경우, 보통 넘기고 -> 종료조건이나 가지치기 체크 후 -> visit(v)</li>\n<li>DFS_재귀함수의 경우 넘길 인자를 잘 선택하고, 넘기지 않고 reset할 경우 reset할 위치를 잘 선택! for문 혹은 for문 밖</li>\n</ul>\n<h2>1. SWEA_1219_길찾기</h2>\n<p><a href=\"https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV14geLqABQCFAYD\">SWEA_1219_길찾기</a></p>\n<ul>\n<li>BFS &#x3C; DFS_recursive &#x3C; DFS_while</li>\n<li><strong>DFS_while</strong></li>\n</ul>\n<pre><code class=\"language-python\">def dfs_while(v):\r\n    visited = [0] * 100\r\n    stk = []\r\n\r\n    visited[v] = 1\r\n    while True:\r\n        # visit(v)\r\n        if v == 99:\r\n            return 1\r\n        # 기본구조\r\n        for w in adjLst[v]:\r\n            if visited[w] == 0:\r\n                stk.append(v)\r\n                v = w\r\n                visited[v] = 1\r\n                break\r\n        else:\r\n            if stk:\r\n                v = stk.pop()\r\n            else:\r\n                break\r\n    return 0\r\n\r\n\r\nwhile True:\r\n    try:\r\n        T, E = map(int, input().split())\r\n\r\n        arr = list(map(int, input().split()))\r\n        adjLst = [[] for _ in range(100)]\r\n        for i in range(E):\r\n            a, b = arr[i*2], arr[i*2 +1]\r\n            adjLst[a].append(b)\r\n\r\n        result = dfs_while(0)\r\n\r\n        print(f'#{T} {result}')\r\n    except:\r\n        break\n</code></pre>\n<ul>\n<li><strong>DFS_recursive</strong></li>\n</ul>\n<pre><code class=\"language-python\">def dfs_recursive(v):\r\n    global result\r\n    # 종료조건 or visit(v)\r\n    if v == 99:\r\n        result = 1\r\n        return\r\n    # 기본구조\r\n    else:\r\n        visited[v] = 1\r\n        for w in adjLst[v]:\r\n            if visited[w] == 0:\r\n                v = w\r\n                dfs_recursive(v)\r\n\r\nwhile True:\r\n    try:\r\n        T, E = map(int, input().split())\r\n\r\n        arr = list(map(int, input().split()))\r\n        adjLst = [[] for _ in range(100)]\r\n        for i in range(E):\r\n            a, b = arr[i*2], arr[i*2 +1]\r\n            adjLst[a].append(b)\r\n\r\n        visited = [0] * 100\r\n        stk = []\r\n        visited[0] =  1\r\n\r\n        result = 0\r\n        dfs_recursive(0)\r\n\r\n        print(f'#{T} {result}')\r\n    except:\r\n        break\n</code></pre>\n<ul>\n<li><strong>BFS</strong></li>\n</ul>\n<pre><code class=\"language-python\">def bfs(v, N, t):   # v 시작 정점,(N 마지막 정점 번호, t 찾는 정점)\r\n    visited = [0] * 100 # 100 == (N + 1)\r\n    q = []\r\n\r\n    q.append(v)\r\n    visited[v] = 1\r\n    while q:\r\n        v = q.pop()\r\n        # visit(v)\r\n        if v == 99:     # 99 == t\r\n            return 1\r\n        for w in adjLst[v]:\r\n            if visited[w] == 0:\r\n                q.append(w)\r\n                visited[w] = visited[v] + 1\r\n    return 0\r\n\r\nwhile True:\r\n    try:\r\n        T, E = map(int, input().split())\r\n\r\n        arr = list(map(int, input().split()))\r\n        adjLst = [[] for _ in range(100)]\r\n        for i in range(E):\r\n            a, b = arr[i*2], arr[i*2 +1]\r\n            adjLst[a].append(b)\r\n\r\n        result = bfs(0, 99, 99)\r\n\r\n        print(f'#{T} {result}')\r\n    except:\r\n        break\n</code></pre>\n<h2>2. miro</h2>\n<ul>\n<li>BFS &#x3C; DFS_while &#x3C; DFS_recursive</li>\n</ul>\n<p>Test Case 수\r\nN = N*N 미로\r\n13101\r\n10101\r\n10101\r\n10101\r\n10021\r\n0: 통로, 1: 벽, 2: 출발점, 3: 도착점\r\n-> 도착가능하면 1, 아니면 0</p>\n<pre><code class=\"language-python\">'''input\r\n3\r\n5\r\n13101\r\n10101\r\n10101\r\n10101\r\n10021\r\n5\r\n10031\r\n10111\r\n10101\r\n10101\r\n12001\r\n5\r\n00013\r\n01110\r\n21000\r\n01111\r\n00000\r\n'''\r\n'''output\r\n#1 1\r\n#2 1\r\n#3 0\r\n'''\n</code></pre>\n<ul>\n<li><strong>DFS_while</strong></li>\n</ul>\n<pre><code class=\"language-python\">def dfs_while(v):\r\n    visited = [0] * 100\r\n    stk = []\r\n\r\n    visited[v] = 1\r\n    while True:\r\n        # visit(v)\r\n        if v == 99:\r\n            return 1\r\n        # 기본구조\r\n        for w in adjLst[v]:\r\n            if visited[w] == 0:\r\n                stk.append(v)\r\n                v = w\r\n                visited[v] = 1\r\n                break\r\n        else:\r\n            if stk:\r\n                v = stk.pop()\r\n            else:\r\n                break\r\n    return 0\r\n\r\n\r\nwhile True:\r\n    try:\r\n        T, E = map(int, input().split())\r\n\r\n        arr = list(map(int, input().split()))\r\n        adjLst = [[] for _ in range(100)]\r\n        for i in range(E):\r\n            a, b = arr[i*2], arr[i*2 +1]\r\n            adjLst[a].append(b)\r\n\r\n        result = dfs_while(0)\r\n\r\n        print(f'#{T} {result}')\r\n    except:\r\n        break\n</code></pre>\n<ul>\n<li><strong>DFS_recursive</strong></li>\n</ul>\n<pre><code class=\"language-python\">def dfs_recursive(i, j, N):\r\n    global result\r\n    # 종료조건 or visit(v)\r\n    if maze[i][j] == 3:\r\n        result = 1\r\n        return\r\n    # 기본구조\r\n    else:\r\n        visited[i][j] = 1\r\n        # 함수호출\r\n        for di, dj in ((0, 1), (1, 0), (0, -1), (-1, 0)):\r\n            ni, nj = i+di, j+dj\r\n            if 0&#x3C;=ni&#x3C;N and 0&#x3C;=nj&#x3C;N and maze[ni][nj]!=1 and visited[ni][nj]==0:\r\n                dfs_recursive(ni, nj, N)\r\n        # visited[i][j] = 0 서로 다른 분기들의 경로가 겹치지 않게 할 때 추가!\r\n        return\r\n\r\nT = int(input())\r\nfor t in range(1, T+1):\r\n    N = int(input())\r\n    maze = [list(map(int, input())) for _ in range(N)]\r\n    \r\n    si, sj = -1, -1\r\n    for i in range(N):\r\n        for j in range(N):\r\n            if maze[i][j] == 2:\r\n                si, sj = i, j\r\n                break\r\n        if si != -1:\r\n            break\r\n    \r\n    result = 0\r\n    visited = [[0]*N for _ in range(N)]\r\n    dfs_recursive(si, sj, N)\r\n\r\n    print(f'#{t} {result}')\n</code></pre>\n<ul>\n<li><strong>BFS</strong></li>\n</ul>\n<pre><code class=\"language-python\">def bfs(i, j, N):\r\n    visited = [[0]*N for _ in range(N)]\r\n    q = []\r\n\r\n    q.append((i, j))\r\n    visited[i][j] = 1\r\n\r\n    while q:\r\n        i, j = q.pop(0)\r\n        # visit(v)\r\n        if maze[i][j] == 3:     # 99 == t\r\n            return 1\r\n        for di, dj in ((0, 1), (1, 0), (0, -1), (-1, 0)):\r\n            ni, nj = i+di, j+dj\r\n            if 0&#x3C;=ni&#x3C;N and 0&#x3C;=nj&#x3C;N and maze[ni][nj]!=1 and visited[ni][nj]==0:\r\n                q.append((ni, nj))\r\n                visited[ni][nj] = visited[i][j] + 1\r\n    return 0\r\n\r\nT = int(input())\r\nfor t in range(1, T+1):\r\n    N = int(input())\r\n    maze = [list(map(int, input())) for _ in range(N)]\r\n    \r\n    si, sj = -1, -1\r\n    for i in range(N):\r\n        for j in range(N):\r\n            if maze[i][j] == 2:\r\n                si, sj = i, j\r\n                break\r\n        if si != -1:\r\n            break\r\n    \r\n    result = bfs(si, sj, N)\r\n    print(f'#{t} {result}')\n</code></pre>"}},"pageContext":{"pagePath":"posts/Algorithm/First/BFS_DFS_backtracking.md","id":"4c60d441-29cc-5f21-9145-7e084ed0bd4b","parent":{"id":"72ea03da-1e21-5f98-909a-87d55576caa1","name":"BFS_DFS_backtracking","relativePath":"Algorithm/First/BFS_DFS_backtracking.md"}}},"staticQueryHashes":["1274812890","3935499650","82772122"],"slicesMap":{}}