{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/Algorithm/Dijkstra.md/","result":{"data":{"markdownRemark":{"id":"d152b12a-0aec-5325-87ba-b9912faae2dd","html":"<h1>Dijsktra</h1>\n<h1>1. 개요</h1>\n<p>음의 가중치가 없는 그래프의 한 노드에서 다른 모드 노드까지의 최단거리를 각각 구하는 알고리즘. 대표적으로 사용되는 <strong>그리디 알고리즘</strong>이다.</p>\n<h1>2. 동작</h1>\n<ol>\n<li>시작 노드를 선정한다.</li>\n<li>방문하지 않은 노드 중 가장 가까운 노드를 선택한다.</li>\n<li>선택된 노드를 방문하고, 인접 노드들의 거리를 갱신한다.</li>\n<li>모든 노드를 방문할 때까지 2~3의 과정을 반복한다.</li>\n</ol>\n<h1>3. 시간 복잡도</h1>\n<p>V: 노드의 갯수\r\nE: 간선의 갯수</p>\n<h2>3.1. Basic</h2>\n<p>동작 과정 2번에 의해 시간복잡도가 결정된다.</p>\n<ul>\n<li><strong>O(V^2)</strong><br>\nV개의 노드 중 가장 가까운 노드를 선형탐색하는 과정이 V번 수행 된다.</li>\n</ul>\n<h2>3.2. with Heap</h2>\n<p>heap을 사용할 경우, 시간복잡도 결정인자가 노드 갯수(V)에서 간선 갯수(E)로 바뀐다. 하지만 고전된 노드 갯수에 대해 가장 많은 간선을 가진 완전그래프를 고려하더라도 V와 E는 다음과 관계가 성립한다.\r\n<code>V &#x3C;= E(E-1)/2</code>\r\n<code>V &#x3C; E^2</code></p>\n<ul>\n<li><strong>O(E*logV)</strong><br>\nE개의 간선을 힙에 넣고 빼는 과정이 E번 이루어진다.\r\n<code>O(E*logE)</code>\r\n<code>O(E*log(V^2))</code>\r\n<code>O(2*E*logV)</code>\r\n<code>O(E*logV)</code></li>\n</ul>\n<h1>4. 구현</h1>\n<h2>4.1. Basic</h2>\n<ul>\n<li>\n<p><strong>Python 코드</strong></p>\n<pre><code class=\"language-python\">'''\r\nV     : 노드 갯수\r\nstart : 시작 노드\r\nadjLst: 특정 노드의 인접 노드들과 가중치를 알 수 있는 컨테이너 자료\r\n'''\r\ndef dijkstra(V, start, adjLst):\r\n  # 초깃값 셋팅\r\n  distance = [INF] * (V)      # 시작점부터 다른 노드까지의 거리\r\n  visited = [False] * (V)     # 거리 계산 완료 여부\r\n\r\n  # 시작점 지정\r\n  distance[start] = 0\r\n\r\n  # 메인 코드\r\n  for _ in range(V):\r\n      # 거리 계산이 완료되지 않은 노드 중 가장 가까운 노드 선정\r\n      mn = INF\r\n      nearest = -1\r\n      for node in range(V):\r\n          if not visited[node] and distance[node] &#x3C; mn:\r\n              mn = distance[node]\r\n              nearest = node\r\n\r\n      visited[nearest] = True    # 해당 노드 거리 확정\r\n\r\n      # 새로 거리 확정된 노드의 인접 노드들 거리 갱신\r\n      for adj, weight in adjLst[nearest]:\r\n          # if not visited[adj]:\r\n          distance[adj] = min(distance[adj], distance[nearest] + weight)\r\n\r\n  return distance\n</code></pre>\n</li>\n</ul>\n<h2>4.2. with Heap</h2>\n<ul>\n<li>\n<p><strong>Python 코드</strong></p>\n<pre><code class=\"language-python\">'''\r\nV     : 노드 갯수\r\nstart : 시작 노드\r\nadjLst: 특정 노드의 인접 노드들과 가중치를 알 수 있는 컨테이너 자료\r\n'''\r\ndef dijkstra(V, start, adjLst):\r\n# 초깃값 셋팅\r\ndistance = [INF] * (V+1)    # 시작점부터 다른 노드까지의 거리\r\n\r\n# 시작점 지정\r\nheap = []\r\nheapq.heappush(heap, (0, start))\r\ndistance[start] = 0\r\n\r\nwhile heap:\r\n    # 힙에서 가장 낮은 가중치를 가진 노드를 heap에서 pop\r\n    dist, nearest = heapq.heappop(heap)\r\n\r\n    # 이미 거리 계산이 완료된 노드 무시하기: Basic Dijkstra에서 visited 배열을 기능을 담당\r\n    if distance[nearest] &#x3C; dist:\r\n        continue\r\n\r\n    # 해당 노드 거리가 확정되는 시점\r\n\r\n    # 인접 노드들의 거리 재계산하여 heap에 push\r\n    for adj, weight in adjLst[nearest]:\r\n        new_dist = dist + weight\r\n        if new_dist &#x3C; distance[adj]:\r\n            distance[adj] = new_dist\r\n            heapq.heappush(heap, (new_dist, adj))\r\n\r\nreturn distance\n</code></pre>\n</li>\n</ul>"}},"pageContext":{"pagePath":"posts/Algorithm/Dijkstra.md","id":"d152b12a-0aec-5325-87ba-b9912faae2dd","parent":{"id":"982bfef7-ba07-5eb8-a421-444507bbca5f","name":"Dijkstra","relativePath":"Algorithm/Dijkstra.md"}}},"staticQueryHashes":["1274812890","3935499650","82772122"],"slicesMap":{}}