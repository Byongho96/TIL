{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/JavaScript/Promise_Await.md/","result":{"data":{"markdownRemark":{"id":"74ff40b1-0c80-50ce-82b9-769ccde21119","html":"<h1>Index</h1>\n<ul>\n<li><a href=\"#1-promise\">1. Promise</a>\n<ul>\n<li><a href=\"#11-promiseexecutor\">1.1. Promise(executor)</a></li>\n</ul>\n</li>\n<li><a href=\"#2-aysnc-await\">2. Aysnc &#x26; Await</a>\n<ul>\n<li><a href=\"#21-async\">2.1. async</a></li>\n<li><a href=\"#22-await\">2.2. await</a></li>\n<li><a href=\"#23-try--catch\">2.3. try / catch</a></li>\n</ul>\n</li>\n<li><a href=\"#3-example\">3. Example</a>\n<ul>\n<li><a href=\"#31-chaining-%EC%B2%98%EB%A6%AC-hard-code\">3.1. Chaining 처리, Hard Code</a>\n<ul>\n<li><a href=\"#311-promise\">3.1.1. Promise</a></li>\n<li><a href=\"#312-await\">3.1.2. await</a></li>\n</ul>\n</li>\n<li><a href=\"#32-chaining-%EC%B2%98%EB%A6%AC-soft-code\">3.2. Chaining 처리, Soft Code</a>\n<ul>\n<li><a href=\"#321promise\">3.2.1.Promise</a></li>\n<li><a href=\"#322-await\">3.2.2. await</a></li>\n</ul>\n</li>\n<li><a href=\"#33-all-%EC%B2%98%EB%A6%AC-%EB%B9%84-%EC%88%9C%EC%B0%A8-%EA%B2%B0%EA%B3%BC\">3.3. All 처리, 비 순차 결과</a>\n<ul>\n<li><a href=\"#331-promise\">3.3.1. Promise</a></li>\n<li><a href=\"#332-await\">3.3.2. await</a></li>\n</ul>\n</li>\n<li><a href=\"#34-all-%EC%B2%98%EB%A6%AC-%EC%88%9C%EC%B0%A8-%EA%B2%B0%EA%B3%BC\">3.4. All 처리, 순차 결과</a>\n<ul>\n<li><a href=\"#341-promise\">3.4.1. Promise</a></li>\n<li><a href=\"#342-await\">3.4.2. await</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1>1. Promise</h1>\n<h2>1.1. Promise(executor)</h2>\n<p>executor는 resolve, reject 함수를 인수를 전달할 실행 함수이다.\r\nresolve를 호출해 프로미스를 이행하거나, 오류가 발생한 경우 reject를 호출해 거부할 수 있다.</p>\n<pre><code class=\"language-js\">const myFirstPromise = new Promise((resolve, reject) => {\r\n  // do something asynchronous which eventually calls either:\r\n  //\r\n  //   resolve(someValue)        // fulfilled\r\n  // or\r\n  //   reject(\"failure reason\")  // rejected\r\n})\n</code></pre>\n<hr>\n<h1>2. Aysnc &#x26; Await</h1>\n<h2>2.1. async</h2>\n<p>async function 선언은 Promise 객체를 반환하는 비동기 함수를 선언한다. 명시적으로 Promise 객체를 반환해줄 수도 있다.</p>\n<pre><code class=\"language-js\">async function f() {\r\n  return 1\r\n}\r\nf().then(alert) // 1\r\n\r\nasync function f() {\r\n  return Promise.resolve(1)\r\n}\r\nf().then(alert) // 1\n</code></pre>\n<h2>2.2. await</h2>\n<p>await 키워드는 async 키워드가 붙어있는 함수 내부에서만 사용할 수 있으며, 비동기 함수가 리턴하는 Promise로 부터 결과값을 추출한다.</p>\n<p>async 코드 내의 await함수가 선언된 경우, 해당 함수가 끝날 때까지 다음 코드가 실행되지 않는다. <strong>즉 마치 동기적 코드블록처럼 작용한다.</strong></p>\n<h2>2.3. try / catch</h2>\n<p>async와 await 키워드를 사용하는 경우, 보통의 코드처럼 try/catch 구문을 사용하여 예외처리할 수 있다.</p>\n<hr>\n<h1>3. Example</h1>\n<pre><code class=\"language-js\">function delay_word(word, delay) {\r\n  return new Promise((resolve) => {\r\n    setTimeout(function () {\r\n      resolve(word)\r\n    }, delay)\r\n  })\r\n}\n</code></pre>\n<ul>\n<li><strong>setTimeout(functionRef, delay, params*)</strong>\n<ul>\n<li>delay 시간 이후에, functionRef를 실행한다.</li>\n<li>params는 functionRef의 인자값들이다.</li>\n</ul>\n</li>\n</ul>\n<h2>3.1. Chaining 처리, Hard Code</h2>\n<p>이전 비동기 작업을 완료한 이후에 순차적으로 다음 작업을 처리한다.</p>\n<h3>3.1.1. Promise</h3>\n<p>이전 작업이 완료된 이후에, 반환된 객체를 받아서 내부 함수를 순차 실행한다.</p>\n<pre><code class=\"language-js\">delay_word('SAMSUNG', 500).then((resolve) => {\r\n  console.log(resolve)\r\n\r\n  delay_word('SW', 490).then((resolve) => {\r\n    console.log(resolve)\r\n\r\n    delay_word('ACADEMY', 480).then((resolve) => {\r\n      console.log(resolve)\r\n\r\n      delay_word('FOR', 470).then((resolve) => {\r\n        console.log(resolve)\r\n\r\n        delay_word('YOUTH', 460).then((resolve) => {\r\n          console.log(resolve)\r\n        })\r\n      })\r\n    })\r\n  })\r\n})\n</code></pre>\n<p>위 코드는 아래와 같이 변환 가능하다.</p>\n<pre><code class=\"language-js\">delay_word('SAMSUNG', 500)\r\n  .then((resolve) => {\r\n    console.log(resolve)\r\n    return delay_word('SW', 490)\r\n  })\r\n  .then((resolve) => {\r\n    console.log(resolve)\r\n    return delay_word('ACADEMY', 480)\r\n  })\r\n  .then((resolve) => {\r\n    console.log(resolve)\r\n    return delay_word('FOR', 470)\r\n  })\r\n  .then((resolve) => {\r\n    console.log(resolve)\r\n    return delay_word('YOUTH', 460)\r\n  })\r\n  .then((resolve) => {\r\n    console.log(resolve)\r\n  })\n</code></pre>\n<h3>3.1.2. await</h3>\n<p>await 함수가 dealy_word로부터 Promise 객체를 받아 실행되며, async 내부의 코드들은 await 함수를 비동기적으로 기다린다.</p>\n<pre><code class=\"language-js\">async function test() {\r\n  const resolve_0 = await delay_word('SAMSUNG', 500)\r\n  console.log(resolve_0)\r\n  const resolve_1 = await delay_word('SW', 490)\r\n  console.log(resolve_1)\r\n  const resolve_2 = await delay_word('ACADEMY', 480)\r\n  console.log(resolve_2)\r\n  const resolve_3 = await delay_word('FOR', 470)\r\n  console.log(resolve_3)\r\n  const resolve_4 = await delay_word('YOUTH', 460)\r\n  console.log(resolve_4)\r\n}\n</code></pre>\n<h2>3.2. Chaining 처리, Soft Code</h2>\n<h3>3.2.1.Promise</h3>\n<ul>\n<li><strong>arr.reduce(callback[, initialValue])</strong>\n<ul>\n<li>callback(accumulator, currentValue)\n<ul>\n<li>accumulator: 누적값</li>\n<li>currentValue: 현재 계산값</li>\n</ul>\n</li>\n<li>initialValue\n<ul>\n<li>초깃값, 없을 경우 배열의 첫번째 값</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>array의 reduce 메소드를 활용하여 soft한 코드를 작성하였다. <code>Promise.resolve()</code>를 사용하여 초깃값으로 Promise 객체를 지정해주었다.</p>\n<pre><code class=\"language-js\">const array = [\r\n  { word: 'SAMSUNG', delay: 500 },\r\n  { word: 'SW', delay: 490 },\r\n  { word: 'ACADEMY', delay: 480 },\r\n  { word: 'FOR', delay: 470 },\r\n  { word: 'YOUTH', delay: 460 },\r\n]\r\n\r\narray.reduce((prev, item) => {\r\n  return prev.then(() =>\r\n    delay_word(item.word, item.delay).then((promise) => {\r\n      console.log(promise)\r\n    })\r\n  )\r\n}, Promise.resolve())\n</code></pre>\n<h3>3.2.2. await</h3>\n<p>반복문을 이용하여 await함수를 반복해서 실행하였다.</p>\n<pre><code class=\"language-js\">const array = [\r\n  { word: 'SAMSUNG', delay: 500 },\r\n  { word: 'SW', delay: 490 },\r\n  { word: 'ACADEMY', delay: 480 },\r\n  { word: 'FOR', delay: 470 },\r\n  { word: 'YOUTH', delay: 460 },\r\n]\r\n\r\nasync function test() {\r\n  for (const item of array) {\r\n    const resolve = await delay_word(item.word, item.delay)\r\n\r\n    console.log(resolve)\r\n  }\r\n}\n</code></pre>\n<h2>3.3. All 처리, 비 순차 결과</h2>\n<h3>3.3.1. Promise</h3>\n<p>forEach문으로 5개의 비동기함수가 실행되었다. 따라서 5개의 비동기함수가 거의 동시에 시작이 되었으므로, 결과값은 dealy시간에 따라 출력된다.</p>\n<pre><code class=\"language-js\">const array = [\r\n  { word: 'SAMSUNG', delay: 500 },\r\n  { word: 'SW', delay: 490 },\r\n  { word: 'ACADEMY', delay: 480 },\r\n  { word: 'FOR', delay: 470 },\r\n  { word: 'YOUTH', delay: 460 },\r\n]\r\n\r\n// Promise 객체로 비동기 작업을 처리했기 때문에, async 키워드는 생략 가능하다.\r\narray.forEach(async (item) => {\r\n  delay_word(item.word, item.delay).then((resolve) => {\r\n    console.log(resolve)\r\n  })\r\n})\n</code></pre>\n<h3>3.3.2. await</h3>\n<pre><code class=\"language-js\">const array = [\r\n  { word: 'SAMSUNG', delay: 500 },\r\n  { word: 'SW', delay: 490 },\r\n  { word: 'ACADEMY', delay: 480 },\r\n  { word: 'FOR', delay: 470 },\r\n  { word: 'YOUTH', delay: 460 },\r\n]\r\n\r\narray.forEach(async (item) => {\r\n  const resolve = await delay_word(item.word, item.delay)\r\n\r\n  console.log(resolve)\r\n})\n</code></pre>\n<h2>3.4. All 처리, 순차 결과</h2>\n<p><strong>Promise.all()</strong>\r\n여러개의 비동기함수를 병렬적으로 실행하고, <strong>실행순서</strong>따라 결과 Promise객체를 반환한다.</p>\n<h3>3.4.1. Promise</h3>\n<pre><code class=\"language-js\">const array = [\r\n  { word: 'SAMSUNG', delay: 500 },\r\n  { word: 'SW', delay: 490 },\r\n  { word: 'ACADEMY', delay: 480 },\r\n  { word: 'FOR', delay: 470 },\r\n  { word: 'YOUTH', delay: 460 },\r\n]\r\n\r\nconst promise_list = []\r\n\r\narray.forEach((item) => {\r\n  const promise = delay_word(item.word, item.delay)\r\n\r\n  promise_list.push(promise)\r\n})\r\n\r\nPromise.all(promise_list).then((values) => {\r\n  values.forEach((resolve) => {\r\n    console.log(resolve)\r\n  })\r\n})\n</code></pre>\n<h3>3.4.2. await</h3>\n<p>Promise객체를 병렬적으로 실행시켜서, 진행중인(pending) Promise객체를 배열에 집어넣는다.</p>\n<p>그리고 await함수를 통해 값을 할당하여 출력하면, 가장 오랜 시간이 걸리는 Promise객체의 delay시간과 유사한 지연시간을 가진다.</p>\n<pre><code class=\"language-js\">const array = [\r\n  { word: 'SAMSUNG', delay: 500 },\r\n  { word: 'SW', delay: 490 },\r\n  { word: 'ACADEMY', delay: 480 },\r\n  { word: 'FOR', delay: 470 },\r\n  { word: 'YOUTH', delay: 460 },\r\n]\r\n\r\nasync function test() {\r\n  const async_fun_list = []\r\n\r\n  for (item of array) {\r\n    const async_fun = delay_word(item.word, item.delay)\r\n\r\n    console.log(async_fun) // Promise { &#x3C;pending> }\r\n\r\n    async_fun_list.push(async_fun)\r\n  }\r\n\r\n  for (async_fun of async_fun_list) {\r\n    const resolve = await async_fun\r\n\r\n    console.log(resolve)\r\n  }\r\n}\n</code></pre>"}},"pageContext":{"pagePath":"posts/JavaScript/Promise_Await.md","id":"74ff40b1-0c80-50ce-82b9-769ccde21119","parent":{"id":"c2769af2-05f1-55fd-9f51-239823bb7b4f","name":"Promise_Await","relativePath":"JavaScript/Promise_Await.md"}}},"staticQueryHashes":["1274812890","3935499650","82772122"],"slicesMap":{}}