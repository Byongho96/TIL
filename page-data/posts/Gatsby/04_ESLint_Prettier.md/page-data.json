{"componentChunkName":"component---src-templates-post-index-tsx","path":"/posts/Gatsby/04_ESLint_Prettier.md/","result":{"data":{"markdownRemark":{"id":"97d4c090-15ea-5775-a861-8ed71d31c0d8","html":"<h1 id=\"1-개요\" style=\"position:relative;\"><a href=\"#1-%EA%B0%9C%EC%9A%94\" aria-label=\"1 개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 개요</h1>\n<h2 id=\"11-prettier--eslint란\" style=\"position:relative;\"><a href=\"#11-prettier--eslint%EB%9E%80\" aria-label=\"11 prettier  eslint란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1. Prettier &#x26; ESLint란?</h2>\n<p>Prettier와 ESLint는 각각 코드 포맷팅(Code Formatting)과 린팅(Linting)을 지원하는 도구이다. <strong>코드 포맷팅은 코드 전체에서 일관된 스타일링을 적용해 가독성을 높이는 작업</strong>을 말하며, <strong>린팅은 소스 코드를 분석하여 잠재적인 오류, 버그, 스타일 규칙 위반 등을 찾아내는 과정</strong>을 말햔다. 따라서 린팅이 코드 포맷팅의 기능도 일부 포함한다.</p>\n<p>보통 팀 단위 작업을 할 때, 여러 개발자들 간의 원활한 협업과 일관된 코드 품질을 위해 위 2가지 도구는 기본적으로 사용한다. 나는 이번에 혼자 작업하는 거라서 Prettier와 ESLint설정을 건너 뛰었는데, 참 바보같은 결정이었다.</p>\n<p>특히, ESLint는 말한 것처럼 소스 코드에 대한 잠재적인 오류를 찾아내기 때문에, <strong>혼자 작업하더라도 코드의 품질을 높이는데 중요한 역할을 한다.</strong> 예를 들어, TypeScript의 관련된 강화된 규칙을 강제하거나, 안 쓰는 모듈의 import를 제거할 수 있다. 따라서 프로젝트를 본격적으로 시작하기 전에 Prettier와 ESLint를 설정해줄 것을 강력하게 추천한다.</p>\n<h2 id=\"12-husky란\" style=\"position:relative;\"><a href=\"#12-husky%EB%9E%80\" aria-label=\"12 husky란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2. Husky란?</h2>\n<p><strong>Husky는 Git 훅 관리 도구이다.</strong> Git 이벤트(commit, push, ...) 발생 시, 이벤트 전/후에 특정 스크립트를 실행시킬 수 있다.</p>\n<p><mark>생각해보면 앞서 설정한 Prettier와 ESLint는 모두 자동으로 실행되지 않는다. CLI 명령어를 돌리거나 vsCode와 같은 코드 편집기에 관련 설정을 해줘야 한다.</mark> 만약 팀의 누군가가 관련 설정을 하지 않고, git에 커밋하면 그냥 올라가는 것이다. 이를 방지하기 위해서, Husky와 같은 도구를 사용해 Prettier와 ESLint를 커밋 시마다 강제할 수 있다.</p>\n<h1 id=\"2-prettier\" style=\"position:relative;\"><a href=\"#2-prettier\" aria-label=\"2 prettier permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Prettier</h1>\n<p>아래 내용은 <a href=\"https://prettier.io/docs/en/install.html\">prettier 공식문서</a>를 따라 작성했다.</p>\n<ol>\n<li>\n<p><strong>prettier 설치</strong></p>\n<pre><code class=\"language-bash\">npm install --save-dev --save-exact prettier\n</code></pre>\n</li>\n<li>\n<p><strong>prettier 설정파일 생성</strong></p>\n<p>프로젝트 루트 경로에 .prettierrc.json 파일을 생성하고, <a href=\"https://prettier.io/docs/en/options.html\">prettierrc 설정 옵션 문서</a>을 참고해서 원하는대로 파일을 작성하면 된다. 내가 작성한 설정 파일은 다음과 같다.</p>\n<pre><code class=\"language-json\">{\r\n  \"trailingComma\": \"es5\", // 객체, 배열의 마지막 요소 뒤에 쉼표(,) 추가\r\n  \"tabWidth\": 2,\r\n  \"semi\": false,\r\n  \"singleQuote\": true\r\n}\n</code></pre>\n</li>\n<li>\n<p><strong>.prettierignore 생성</strong><br>\n.prettierignore을 통해 <strong>prettier CLI 명령어</strong>를 적용시키지 않을 문서를 설정한다.</p>\n<pre><code class=\"language-text\"># Gatsby의 경우 빌드 결과물이 public 폴더에 저장된다\r\npublic\r\ncoverage\r\n\r\n# 다음 요소들은 기본 설정되므로 따로 추가할 필요 없다.\r\n**/.git\r\n**/.svn\r\n**/.hg\r\n**/node_modules\n</code></pre>\n</li>\n<li>\n<p><strong>prettier cli 실행 방법</strong></p>\n<p><code>--write</code> 옵션를 통해 prettier 코드 포맷팅을 적용할 수 있다.</p>\n<pre><code class=\"language-bash\"># 모든 파일\r\nnpx prettier --write .\r\n\r\n# 특정 파일 지정\r\nnpx prettier --write src/components/Button.js\n</code></pre>\n<p><code>--check</code> 옵션을 통해 prettier 포맷팅을 검사만 하고, 실제 수정하지는 않을 수 있다.</p>\n<pre><code class=\"language-bash\">npx prettier --check .\n</code></pre>\n</li>\n<li>\n<p><strong>prettier vsCode 연동</strong><br>\n헷갈리지 말아야할 것이 prettier은 설치만 한다고 해서, <strong>파일 저장 시</strong> prettier 코드 포맷팅이 적용되는 것이 아니다.\r\n<mark><strong>파일 저장 시 prettier 적용을 위해서는 코드 편집기의 도움이 필요하다.</strong></mark> vsCode의 경우 <strong>Prettier - Code formatter</strong> 플러그인을 설치하고 아래 설정을 체크해준다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/9c9332379ad0e5229ad4aa8422abbf71/c929c/prettier_vscode.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 66.85714285714286%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABJ0AAASdAHeZh94AAACTklEQVR42mWT607bQBCF8xRN0tjei727vqzt2AmBEBBNpdKWtoEGWggCBL2q/Ooj9BH6vv5xqlkwDe2PT6vVrM6cM2N3rLUoigLGGCilHFGkEAQROL9DSAUpNYTQYFxDawWlNZTkiKoZ5M1vmNUvmMkcHa010jR1QpwzBAGDFAyL1z6uVz4uTxlOj/r4cPgEJ4sutjc994YxDuZ7CHSOwcsf8N78hDc9RIdzjuFwiDiOwZiPXp/j+F0Phwcp6noT060tbIwL5DZBWRqcn/h4MRcIowRJEiM2GrHwkIgBhNdDJwxDTCYT5HkOKQWeDgQWr7pYHBjszgrszEokCTVMXezZNMRq2YXncZAZRgjpCDi/c0gzpNgUn6IYE+FyZXF9meL2u8HXTyk+X2e4/Vbj5sKgqiS41IiUQhjdoxREGKLDGEOWZW4pQRCA7owLyCiHTodQ2RB5XcJWQwzrEiYpIKIEOo6hzDqJE35wKKX8K0hN0gR5bh1ZZmFtfo9FURZufu3bdZzgaDRyDmmebYHi06IIqrVn+2nRm3UDjwSrqnKxhRAPhTSlrRbOYVmWbml1XWO8McZ4NHYNoij6X3D9st4xjGLESYk0rSCEchulhnQSlIbG1OI2/q9gC2cMs6nE1VmG02WG+Z6FzXM367zInVuCUtFoCBIkQ48E6U/p9zmWb3s4PxHY2bbY281wthxg/7kH3w8RhneOyG3rbN09CTYtgrOm1+fN+XG3OdgPm/mzonm/sM2XK918PPIbIXUTG9MopR4wxjRaa4cQovkDxa2CEce90WoAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"prettier_vscode.png\" title=\"\" src=\"/TIL/static/9c9332379ad0e5229ad4aa8422abbf71/8c557/prettier_vscode.png\" srcset=\"/TIL/static/9c9332379ad0e5229ad4aa8422abbf71/4edbd/prettier_vscode.png 175w,\n/TIL/static/9c9332379ad0e5229ad4aa8422abbf71/13ae7/prettier_vscode.png 350w,\n/TIL/static/9c9332379ad0e5229ad4aa8422abbf71/8c557/prettier_vscode.png 700w,\n/TIL/static/9c9332379ad0e5229ad4aa8422abbf71/e996b/prettier_vscode.png 1050w,\n/TIL/static/9c9332379ad0e5229ad4aa8422abbf71/c929c/prettier_vscode.png 1218w\" sizes=\"(max-width: 700px) 100vw, 700px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</li>\n</ol>\n<h1 id=\"3-eslint\" style=\"position:relative;\"><a href=\"#3-eslint\" aria-label=\"3 eslint permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. ESLint</h1>\n<p>아래 내용은 <a href=\"https://eslint.org/docs/latest/use/getting-started\">eslint 공식문서</a>에 따라 작성했다.</p>\n<ol>\n<li>\n<p><strong>ESLint 설치</strong></p>\n<pre><code class=\"language-bash\">npm install --save-dev eslint\n</code></pre>\n</li>\n<li>\n<p><strong>ESLint 설정 파일 생성</strong></p>\n<p>프로젝트 루트 경로에 ESLint 설정파일(touch .eslintrc.js)를 생성한다.</p>\n<pre><code class=\"language-bash\">touch .eslintrc.js\n</code></pre>\n</li>\n<li>\n<p><strong>ESLint 설정 파일 작성</strong></p>\n<p><a href=\"https://www.gatsbyjs.com/docs/how-to/custom-configuration/eslint/\">Gatsby 공식문서</a>와 <a href=\"https://eslint.org/docs/latest/use/getting-started\">eslint 공식문서</a>를 참고하여 다음과 같은 기본 .eslintrc.js파일을 작성했다.</p>\n<pre><code class=\"language-bash\"># Gatsby 공식문서에 따라 다음 eslint config를 설치한다.\r\n\r\nnpm install eslint-config-react-app\n</code></pre>\n<pre><code class=\"language-js\">// .eslintrc.js example\r\nmodule.exports = {\r\n  globals: {\r\n    __PATH_PREFIX__: true,\r\n  },\r\n  env: {\r\n    browser: true,\r\n    es2021: true,\r\n  },\r\n  extends: ['eslint:recommended', 'react-app']\r\n  parserOptions: {\r\n    ecmaVersion: 'latest',\r\n    sourceType: 'module',\r\n  },\r\n}\n</code></pre>\n<ul>\n<li><strong>global</strong><br>\nESLint를 수행하는 데 있어서 필요한 전역변수를 설정한다.\n<ul>\n<li><strong>PATH_PREFIX</strong>\r\ngatsby-config.js파일에 <code>pathPrefix</code>옵션이 설정되어 있음을 알려준다.</li>\n</ul>\n</li>\n<li><strong>env</strong>\n<ul>\n<li><strong>browser</strong>\r\n이 옵션은 코드가 브라우저 환경에서 실행될 것임을 나타냄으로써, 브라우저에서 제공하는 전역 객체와 API를 사용하는 코드에 대해 적절한 규칙을 적용할 수 있다.</li>\n<li><strong>es2021</strong><br>\nECMAScript 2021(ES2021)의 기능을 사용할 것임을 나타냄으로써, ES2021에서 추가된 문법을 사용하는 코드에 대해 적절한 규칙을 적용할 수 있다.</li>\n</ul>\n</li>\n<li><strong>parserOptions</strong><br>\nparser에 대한 옵션을 지정한다. paser는 ESLint가 코드의 문맥을 해석하기 위해서 사용하는 도구라고 생각하면 된다.\n<ul>\n<li><strong>ecmaVersion</strong><br>\n\"latest\"로 설정하면 ESLint는 현재 사용 가능한 최신 ECMAScript 버전에 대한 기능을 인식할 수 있다.</li>\n<li><strong>sourceType</strong><br>\n\"module\"로 설정하면 코드가 ES 모듈 형식인 것을 나타낸다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>ESLint cli 실행 방법</strong></p>\n<p>다음 cli 명령어를 통해 ESLint를 실행하고 수정할 수 있다.</p>\n<pre><code class=\"language-bash\"># 특정 파일에 대한 ESLint 실행\r\nnpx eslint --fix file1.js file2.js\r\n\r\n# 특정 디렉토리에 대한 ESLint 실행\r\nnpx eslint --fix lib/**\n</code></pre>\n</li>\n<li>\n<p><strong>ESLint vsCode 연동</strong><br>\n역시나 헷갈리지 말아야할 것이 ESLint를 설치만 한다고 해서, <strong>파일 저장 시</strong> ESLint가 적용되지는 않는다. <mark><strong>파일 저장 시 ESLint 적용을 위해서는 코드 편집기의 도움이 필요하다.</strong></mark></p>\n<p>vsCode의 경우 <strong>ESLint</strong> 플러그인을 설치하고 아래 설정을 체크해준다.</p>\n<pre><code class=\"language-json\">// ctrl+shif+P > 'settings' 검색 > User Settings (JSON)\r\n{\r\n   \"editor.formatOnSave\": true,\r\n   \"editor.codeActionsOnSave\": {\r\n      \"source.fixAll.eslint\": true // ES Lint 저장 시 자동 fix 설정\r\n   },\r\n   ...\r\n}\n</code></pre>\n</li>\n</ol>\n<h2 id=\"31-eslint--prettier\" style=\"position:relative;\"><a href=\"#31-eslint--prettier\" aria-label=\"31 eslint  prettier permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1. ESLint &#x26; Prettier</h2>\n<p>앞 서 설명한 것처럼 <strong>린팅은 코드 포맷팅 기능을 포함한다.</strong> 따라서 코드 포맷팅(스타일링)에서 ESLint와 prettier의 규칙이 충돌할 수 있기 때문에 이를 중재할 필요가 있다. <mark>보통 충돌이 일어날 때, prettier의 규칙을 따르도록 설정한다.</mark></p>\n<ol>\n<li>\n<p><strong>config 설치</strong></p>\n<p>'eslint-confing-prettier'는 prettier에 대한 규칙 패키지이다.</p>\n<pre><code class=\"language-bash\">npm install --save-dev eslint-config-prettier\n</code></pre>\n</li>\n<li>\n<p><strong>.eslintrc.js 수정</strong></p>\n<pre><code class=\"language-json\">{\r\n  \"extends\": [ ... , \"prettier\"]   // prettier을 가장 마지막에 둬야 한다.\r\n}\n</code></pre>\n</li>\n</ol>\n<h2 id=\"32-eslint--typescirpt\" style=\"position:relative;\"><a href=\"#32-eslint--typescirpt\" aria-label=\"32 eslint  typescirpt permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2. ESLint &#x26; Typescirpt</h2>\n<p>여러분의 프로젝트가 TypeScript라면, ESLint에 TypeScript에 대한 설정을 추가해줘야 한다. ESLint는 기본 설정이 JavaScript에 맞춰져 있기 때문이다.</p>\n<ol>\n<li>\n<p><strong>parser와 plugin 설치</strong></p>\n<p>'@typescript-eslint/parser'는 TypeScript 코드를 분석하고 이해하기 위한 ESLint 파서이다. ESLint의 기본 파서가 JavaScript 파서이기 때문에, ESLint가 TypeScript 코드를 해석하기 위해서 설치해줘야 한다.</p>\n<p>'@typescript-eslint/eslint-plugin'는 TypeScript 프로젝트에서 사용되는 ESLint 규칙을 제공하는 플러그인이다.</p>\n<pre><code class=\"language-bash\">npm install --save-dev @typescript-eslint/parser @typescript-eslint/eslint-plugin\n</code></pre>\n</li>\n<li>\n<p><strong>.eslintrc.js 수정</strong></p>\n<pre><code class=\"language-js\">module.exports = {\r\n  extends: ['plugin:@typescript-eslint/recommended'], // 규칙 확장\r\n  parser: '@typescript-eslint/parser',\r\n  plugins: ['@typescript-eslint'], // 플러그인 적용\r\n  root: true, // 현재 디렉토리가 루트 디렉토리임을 표시\r\n}\n</code></pre>\n</li>\n</ol>\n<h2 id=\"33-eslint--import-순서\" style=\"position:relative;\"><a href=\"#33-eslint--import-%EC%88%9C%EC%84%9C\" aria-label=\"33 eslint  import 순서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.3. ESLint &#x26; Import 순서</h2>\n<p>ESliint를 이용해서 모듈 import 순서를 관리할 수 있다. 아래 내용은 <a href=\"https://www.npmjs.com/package/eslint-plugin-import#resolvers\">eslint-plugin-import의 README</a>를 참고해서 작성했다.</p>\n<ol>\n<li>\n<p><strong>plugin 설치</strong></p>\n<pre><code class=\"language-bash\">npm install --save-dev eslint-plugin-import\n</code></pre>\n</li>\n<li>\n<p><strong>.eslintrc.js 수정</strong></p>\n<pre><code class=\"language-js\">module.exports = {\r\n  extends: ['eslint:recommended', 'plugin:import/recommended'], // 규칙 확장\r\n  plugins: ['import'], // 플러그인 적용\r\n  rules: {\r\n    'import/no-unresolved': [2, { commonjs: true, amd: true }], //CommonJS, AMD 형식의 import 허용\r\n  },\r\n}\n</code></pre>\n</li>\n<li>\n<p><strong>TypeScript 추가 설정</strong></p>\n<p>프로젝트가 TypeScript라면 다음을 추가 설정해줘야 한다.</p>\n<pre><code class=\"language-bash\">npm install --save-dev eslint-import-resolver-typescript\n</code></pre>\n<pre><code class=\"language-js\">module.exports = {\r\n  extends: ['eslint:recommended', 'plugin:import/recommended', 'plugin:import/typescript'], // 규칙 확장\r\n  settings: {\r\n    'import/resolver': {\r\n      typescript: true // tsconfig.json 파일에 설정된 경로 매핑(alias)\r\n      node: true // Node.js의 내장 모듈 및 node_modules 모듈 해석\r\n    }\r\n  },\r\n}\n</code></pre>\n</li>\n<li>\n<p><strong>import 순서 설정</strong></p>\n<p><a href=\"https://github.com/import-js/eslint-plugin-import/blob/main/docs/rules/order.md\">import/order 공식문서</a>를 참고하여 자신만의 규칙을 커스텀한다. 나는 다음과 같이 작성했다.</p>\n<pre><code class=\"language-js\">module.exports = {\r\n  rules: {\r\n    'import/order': [\r\n      2,\r\n      {\r\n        groups: ['builtin', 'external', 'internal'],\r\n        pathGroups: [\r\n          {\r\n            pattern: 'react*', // react 관련 모듈 가장 앞으로\r\n            group: 'builtin',\r\n            position: 'before',\r\n          },\r\n          {\r\n            pattern: '{./*scss, @styles/**}', // style 관련 모듈 앞으로\r\n            group: 'builtin',\r\n            position: 'before',\r\n          },\r\n        ],\r\n        pathGroupsExcludedImportTypes: [], // pathGroups에 정의한 패턴 중 제외하고 싶은 것\r\n        alphabetize: {\r\n          order: 'asc', // 알파벳 내림차순 정렬\r\n          caseInsensitive: true, // 대소문작 구분 안함\r\n        },\r\n        'newlines-between': 'never', // import문은 모두 붙이기\r\n      },\r\n    ],\r\n  },\r\n}\n</code></pre>\n</li>\n</ol>\n<h2 id=\"34-eslint--unused-import\" style=\"position:relative;\"><a href=\"#34-eslint--unused-import\" aria-label=\"34 eslint  unused import permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.4. ESLint &#x26; Unused Import</h2>\n<p>개발을 하다보면 import한 모듈이 필요없어지기도 한다. 더 이상 사용하지 않는 모듈을 'eslint-plugin-unused-imports'로 자동 삭제할 수 있다. 아래 내용은 <a href=\"https://www.npmjs.com/package/eslint-plugin-unused-imports\">eslint-plugin-unused-import의 README</a>를 참고해서 작성했다.</p>\n<ol>\n<li>\n<p><strong>plugin 설치</strong></p>\n<pre><code class=\"language-bash\">npm install eslint-plugin-unused-imports --save-dev\n</code></pre>\n</li>\n<li>\n<p><strong>.eslintrc.js 수정</strong></p>\n<pre><code class=\"language-js\">module.exports = {\r\n  plugins: ['unused-imports'], // 플러그인 추가\r\n  rules: {\r\n    // 충돌 방지를 위해 기존의 관련된 규칙을 off 한다.\r\n    'no-unused-vars': 'off', // or \"@typescript-eslint/no-unused-vars\": \"off\",\r\n    'unused-imports/no-unused-imports': 'error',\r\n    'unused-imports/no-unused-vars': [\r\n      'warn',\r\n      {\r\n        vars: 'all',\r\n        varsIgnorePattern: '^_',\r\n        args: 'after-used',\r\n        argsIgnorePattern: '^_',\r\n      },\r\n    ],\r\n  },\r\n}\n</code></pre>\n</li>\n</ol>\n<h1 id=\"4-husky\" style=\"position:relative;\"><a href=\"#4-husky\" aria-label=\"4 husky permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Husky</h1>\n<p><mark>lint-staged</mark>를 Husky와 함께 설치해서 사용할 것이다. 왜냐하면 Husky를 이용해 commit 전에 코드 검사를 실행할텐데, 그냥 <code>npx eslint --fix</code> 구문을 사용하면, 작업영역(working directory)에서 린팅이 일어난다. commit 시에 검사를 하겠다는 말은 <code>git add</code> 명령어로 올라간 staging area의 파일들을 수정하겠다는 의미이다.</p>\n<p><strong>이렇게 staged된 파일에 대해서 코드 검사를 지원하는 라이브러리가 'lint-staged'이다.</strong> 의미를 알고나니, 라이브러리의 이름이 참 직관적이다.</p>\n<p>아래 내용은 <a href=\"https://typicode.github.io/husky/getting-started.html#install\">Husky 공식문서</a>를 따라 작성했다.</p>\n<ol>\n<li>\n<p><strong>husky와 lint-staged 설치</strong></p>\n<pre><code class=\"language-bash\">npm install --save-dev husky lint-staged\n</code></pre>\n</li>\n<li>\n<p><strong>git 훅 활성화</strong></p>\n<p><code>husky install</code>은 git 훅을 활성화하는 명령어로 프로젝트에서 적어도 한 번 실행시켜줘야 한다.</p>\n<pre><code class=\"language-bash\">npx husky install\n</code></pre>\n</li>\n<li>\n<p><strong>npm scripts.prepare 추가</strong></p>\n<p><a href=\"https://docs.npmjs.com/cli/v7/using-npm/scripts\">npm script 공식문서</a>를 보면, npm 명령어들 간에도 lifecylce이 존재하다. 그 중 <code>prepare</code>는 <code>install</code>이후에 실행되는 명령어이다. 따라서 아래와 같이 설정하면, 다른 개발자들이 레포지토리를 다운받아 <code>npm install</code>를 실행시켰을 때, <code>husky install</code>도 자동으로 실행된다.</p>\n<pre><code class=\"language-json\">// pacakge.json\r\n{\r\n  \"scripts\": {\r\n    \"prepare\": \"husky install\"\r\n  }\r\n}\n</code></pre>\n</li>\n<li>\n<p><strong>lint-staged 코드 작성</strong></p>\n<p><a href=\"https://www.npmjs.com/package/lint-staged\">lint-staged의 README</a>를 참고해서 package.json에 관련 코드를 작성한다. 나는 아래와 같이 작성했다.</p>\n<pre><code class=\"language-json\">// pacakge.json\r\n{\r\n  \"lint-staged\": {\r\n    \"*.{ts,tsx}\": [\"eslint --fix\", \"prettier --write\"] // *.tx, *.tsx 파일에 대해 eslint와 prettier을 적용한다.\r\n  }\r\n}\n</code></pre>\n</li>\n<li>\n<p><strong>husky pre-commit등록</strong></p>\n<p><a href=\"https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks\">Git 공식문서</a>를 보면 어떤 git hook들이 있는지 확인할 수 있다. 아래 사용하는 'pre-commit'훅은 commit 이벤트를 감지하여, 커밋 전에 실행된다.</p>\n<p>husky의 훅들은 '.husky'디렉토리에서 git 훅과 동일한 이름의 파일에서 관리된다. 아래와 같은 명령어로 pre-commit 이벤트에 대해서 `` 명령어를 등록한다.</p>\n<pre><code class=\"language-bash\">npx husky add .husky/pre-commit \"npx lint-staged\"\n</code></pre>\n</li>\n</ol>\n<h1 id=\"5-참조\" style=\"position:relative;\"><a href=\"#5-%EC%B0%B8%EC%A1%B0\" aria-label=\"5 참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 참조</h1>\n<ul>\n<li><a href=\"https://prettier.io/docs/en/install.html\">Prettier</a></li>\n<li><a href=\"https://eslint.org/docs/latest/use/getting-started\">ESLint</a></li>\n<li><a href=\"https://typescript-eslint.io/getting-started\">TypeScript-ESLint</a></li>\n<li><a href=\"https://www.npmjs.com/package/eslint-plugin-import#resolvers\">eslint-plugin-import</a></li>\n<li><a href=\"https://github.com/import-js/eslint-plugin-import/blob/main/docs/rules/order.md\">eslint-plugin-import/order</a></li>\n<li><a href=\"https://www.npmjs.com/package/eslint-plugin-unused-imports\">eslint-plugin-unused-imports</a></li>\n<li><a href=\"https://typicode.github.io/husky/getting-started.html#install\">Husky Getting Started</a></li>\n<li><a href=\"https://docs.npmjs.com/cli/v7/using-npm/scripts\">npm scripts</a></li>\n<li><a href=\"https://www.npmjs.com/package/lint-staged\">lint-staged</a></li>\n<li><a href=\"https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks\">Git Hooks</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-%EA%B0%9C%EC%9A%94\">1. 개요</a></p>\n<ul>\n<li><a href=\"#11-prettier--eslint%EB%9E%80\">1.1. Prettier &#x26; ESLint란?</a></li>\n<li><a href=\"#12-husky%EB%9E%80\">1.2. Husky란?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-prettier\">2. Prettier</a></p>\n</li>\n<li>\n<p><a href=\"#3-eslint\">3. ESLint</a></p>\n<ul>\n<li><a href=\"#31-eslint--prettier\">3.1. ESLint &#x26; Prettier</a></li>\n<li><a href=\"#32-eslint--typescirpt\">3.2. ESLint &#x26; Typescirpt</a></li>\n<li><a href=\"#33-eslint--import-%EC%88%9C%EC%84%9C\">3.3. ESLint &#x26; Import 순서</a></li>\n<li><a href=\"#34-eslint--unused-import\">3.4. ESLint &#x26; Unused Import</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#4-husky\">4. Husky</a></p>\n</li>\n<li>\n<p><a href=\"#5-%EC%B0%B8%EC%A1%B0\">5. 참조</a></p>\n</li>\n</ul>","frontmatter":{"title":"04. Gatsby 프로젝트 Prettier & ESLint & Husky 설정","createdAt":"2023-06-25","updatedAt":"2023-06-25","tags":["gatsby","eslint","prettier","huksy","설정"],"description":"TypeScript 기반 프론트엔드 프로젝트의 Prettier, ESLint, Husky 를 설정한다.","reference":null}},"allMarkdownRemark":{"nodes":[{"id":"2c22a9fe-6e55-5cd2-be55-e902b6b6fcc6","parent":{"id":"0b9617c4-ed0a-531b-a87c-fff826b4aec4","name":"01_Gatsby","relativePath":"Gatsby/01_Gatsby.md"},"frontmatter":{"title":"01. Gatsby 렌더링 옵션과 프로젝트 구조","createdAt":"2023-06-16","updatedAt":"2023-06-16"},"excerpt":"시작하기 앞서... Gatsby로 Markdown기반의 블로그를 만들려고 한다면, Gatsby 공식문서를 보는 것을 추천한다. 맞춤형 강의라고 해도 믿을 만큼 잘 정리되어 있기 때문이다. 때문에 나는 앞으로 Gatsby…"},{"id":"1b19a664-d7dc-5413-91bf-4559af16858e","parent":{"id":"e3778e76-bb67-5f38-a2d4-47476f65b947","name":"02_Github_Pages","relativePath":"Gatsby/02_Github_Pages.md"},"frontmatter":{"title":"02. Gatsby 프로젝트 Github Pages 배포","createdAt":"2023-06-23","updatedAt":"2023-06-23"},"excerpt":"1. 프론트엔드 배포란? 프론트엔드 배포를 한 마디로 정리하면, 특정 url을 통한 GET요청에 대해 index.html…"},{"id":"edb1ecbe-8696-5631-9034-74899cfc6482","parent":{"id":"2378d91b-1037-5ac3-b8d7-e86a0fdfce88","name":"03_Import_Settings","relativePath":"Gatsby/03_Import_Settings.md"},"frontmatter":{"title":"03. Gatsby 프로젝트(TypeScript) import 경로 설정","createdAt":"2023-06-24","updatedAt":"2023-06-24"},"excerpt":"1. import 경로 프로젝트를 진행하다 보면, import 절대경로를 설정하지 않을 수 없다.\r\n심지어 어쩌다가 한 번, IDE에서 자동 import…"},{"id":"97d4c090-15ea-5775-a861-8ed71d31c0d8","parent":{"id":"986ad4bf-2d04-5918-b8b2-4a5f9c68c383","name":"04_ESLint_Prettier","relativePath":"Gatsby/04_ESLint_Prettier.md"},"frontmatter":{"title":"04. Gatsby 프로젝트 Prettier & ESLint & Husky 설정","createdAt":"2023-06-25","updatedAt":"2023-06-25"},"excerpt":"1. 개요 1.1. Prettier & ESLint란? Prettier와 ESLint는 각각 코드 포맷팅(Code Formatting)과 린팅(Linting…"},{"id":"52cf22c3-7db9-5e31-a0dc-9e837e7ba723","parent":{"id":"dc66ae82-c929-5dca-8e6a-f74309c1d21e","name":"05_Dark_Mode","relativePath":"Gatsby/05_Dark_Mode.md"},"frontmatter":{"title":"05. Gatsby 다크모드 구현하기 (feat. Sass)","createdAt":"2023-06-26","updatedAt":"2023-06-26"},"excerpt":"아래 내용은 주관적인 의견이고, 카카오 FE 기술 블로그의 내용을 참조했습니다. 1. Sass 다크모드 한동안 다크모드를 공부한 적이 있다. Styled Component와 같은 CSS-in-JS…"},{"id":"95c61d11-080e-5fa5-bc12-2a210ff8f291","parent":{"id":"b7e5ab1e-e98e-5af9-930b-e6efdc6c441f","name":"06_Navigation_Layout","relativePath":"Gatsby/06_Navigation_Layout.md"},"frontmatter":{"title":"06. Gatsby 네비게이션 레이아웃 설정","createdAt":"2023-06-27","updatedAt":"2023-06-27"},"excerpt":"1. SSG 렌더링 React에서는 Nested Route로 손 쉽게 레이아웃을 구현할 수 있다. 그런데 Gatsby는 Single Page Application이 아니다! Gatsby는 정적 사이트 생성기(SSG)로 빌드 시에, 모든 url…"},{"id":"04ce1246-e6ef-5a01-9225-9edc678c87ab","parent":{"id":"bb17b51e-d008-5e91-a110-1b8410cdaafa","name":"07_Custom_Pages","relativePath":"Gatsby/07_Custom_Pages.md"},"frontmatter":{"title":"07. Gatsby 커스텀 페이지 생성","createdAt":"2023-06-27","updatedAt":"2023-06-27"},"excerpt":"1. 튜토리얼 방식의 한계 Gatsby 튜토리얼 Part6 를 보면 file system routes라고 해서 파일시스템에 있는 파일들에 대해서 동적으로 페이지를 생성하는 방법을 소개한다. 예를 들어 아래 그림처럼 src/pages/아래에 {mdx…"},{"id":"80a66559-06f8-5281-adc2-489adcdafc98","parent":{"id":"3f3d3e65-adff-5bd2-b242-11fbcbc30966","name":"08_Diretory_Based_Category","relativePath":"Gatsby/08_Diretory_Based_Category.md"},"frontmatter":{"title":"08. 폴더 구조 기반 Gatsby 카테고리 바 생성","createdAt":"2023-06-28","updatedAt":"2023-06-28"},"excerpt":"틀린 내용이 있거나, 제가 모르는 방법이 있다면 제발 알려주세요 1. GraphQL 아직 GraphQL을 파일시스템에 대해서 밖에 사용하지 않아, 정확히 GraphQL이 뭔지는 감이 안잡힌다. 하지만 그 제한된 경험으로도 GrqphQL이 기존 API…"}]}},"pageContext":{"pagePath":"posts/Gatsby/04_ESLint_Prettier.md","regex":"/^(?!.*README).*Gatsby.*$/","relativeDirectory":"Gatsby","id":"97d4c090-15ea-5775-a861-8ed71d31c0d8","parent":{"id":"986ad4bf-2d04-5918-b8b2-4a5f9c68c383","name":"04_ESLint_Prettier","relativePath":"Gatsby/04_ESLint_Prettier.md"}}},"staticQueryHashes":["3300660363","3571427910","82772122"],"slicesMap":{}}