{"componentChunkName":"component---src-templates-post-index-tsx","path":"/posts/DevOps/Kubernetes/k3s_4_back/","result":{"data":{"markdownRemark":{"id":"105f9b57-232d-5894-b19b-9530e548ea7a","html":"<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/093ff517666b3653fd78d3e28b98a1d9/2bef9/architecture-back.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 70.28571428571428%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB9UlEQVR42oWU227UMBCG+/4PwR0vwQXiDpDKBQiBql6wZbttl2wO3vjs8XwoTktL1cNIVmJ7/PmfyUxOAOWR1VoxxhCL0HltDrVEUozUcoVq5BnTk39vtaDZo5LRHInWUKLH+QCSyWHGL2t+jxbf1pD0/0A5uZcl6PE3HDcQBjSMaBggDqjvwQ9U1yN2gDBCHMEfHox+Ce0BUCu4G7R0LaQcjnhvqBpRMpAo4hCNiOvJ3QUQoTpQD/nYRD0ACoQJkHZYl8PZYpLjOtm2Vkturv3HD1y+fXOrY8lnvgemFLHWUiUjc4eII2XLlAIxzSgFL6FddH44ZTN8R6KnBEOpERePSF0UziuwlEJK6VbhsCrRyJQ8uUQmv+PgNiDCWfeZ7fSDnCIx2TU1Eqiangt5bMAVuqraTWdsxm/t649+hysHdpdbttsLRHzza2V0p/A5oEhcn9WTytTK5OvVe877U65312w2v4jZ4ZJFangZKDVxsU9kWeGqmSqBOe4JZcDOE8YM1AW07PNiyJmqmdGu4GWurTyEL5fv+Nl9QqSQxVM04ZNd0/OkQteD2DZ0qS9x67zMoJGQBnKaYFEm674Uiy4+cXoEXDr2toVUEsEekeTWFqsZrEG6P0xhpLzSek/8HJTeLPWY764CY+Bmz15nfEvFk1b/AhYdRkDAhuXnAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/TIL/static/093ff517666b3653fd78d3e28b98a1d9/c54d4/architecture-back.webp 175w,\n/TIL/static/093ff517666b3653fd78d3e28b98a1d9/a3432/architecture-back.webp 350w,\n/TIL/static/093ff517666b3653fd78d3e28b98a1d9/426ac/architecture-back.webp 700w,\n/TIL/static/093ff517666b3653fd78d3e28b98a1d9/a9a89/architecture-back.webp 1024w\" sizes=\"(max-width: 700px) 100vw, 700px\" type=\"image/webp\">\n          <source srcset=\"/TIL/static/093ff517666b3653fd78d3e28b98a1d9/4edbd/architecture-back.png 175w,\n/TIL/static/093ff517666b3653fd78d3e28b98a1d9/13ae7/architecture-back.png 350w,\n/TIL/static/093ff517666b3653fd78d3e28b98a1d9/8c557/architecture-back.png 700w,\n/TIL/static/093ff517666b3653fd78d3e28b98a1d9/2bef9/architecture-back.png 1024w\" sizes=\"(max-width: 700px) 100vw, 700px\" type=\"image/png\">\n          <img class=\"gatsby-resp-image-image\" src=\"/TIL/static/093ff517666b3653fd78d3e28b98a1d9/8c557/architecture-back.png\" alt=\"프로젝트 아키텍쳐 구상도\" title=\"\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span>\n<blockquote>\n<p>본래 DB의 아이디와 패스워드는 쿠버네티스에서 Secret 등으로 관리해야 한다. Secret 생성과 적용은 이후 포스팅에서 따로 다룰 예정이다.</p>\n</blockquote>\n<h1 id=\"1-msa-구조\" style=\"position:relative;\"><a href=\"#1-msa-%EA%B5%AC%EC%A1%B0\" aria-label=\"1 msa 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. MSA 구조</h1>\n<p>백엔드는 MSA 구조로 설계되어 총 3개의 Spring Boot 앱을 사용한다. 앞단에서 Spring Cloud 게이트웨이가 사용자 요청을 Prefix에 따라 라우팅해준다.</p>\n<p>처음 사용자가 로그인에 성공하면 Member 서비스가 JWT 토큰을 발급하고, 이를 Redis에 저장한다. 그리고 다른 서비스들은 Redis에서 JWT 토큰을 확인함으로써 사용자를 인식한다.</p>\n<p>그 외 서비스간 소통은 Kafka를 통해 이루어진다. 원래는 API를 직접 호출하도록 설계했는데, 이렇게 하니까 서비스간 결합도가 높아져 MSA를 도입한 의미가 옅어졌다. 그러던 중 우아콘의 <a href=\"https://www.youtube.com/watch?v=DY3sUeGu74M\">Kafka를 이용한 이벤트 기반 아키텍쳐 구축 영상</a>을 접하게 되었고, 이를 적용하기로 했다.</p>\n<h1 id=\"2-redis\" style=\"position:relative;\"><a href=\"#2-redis\" aria-label=\"2 redis permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Redis</h1>\n<p>Redis 도커 이미지를 이용해서 간편하게 실행했다. 이미지 설명에 비밀번호 설정에 대한 설명이 없어 방황하는데, <a href=\"https://github.com/docker-library/redis/issues/176#issuecomment-1620310639\">누군가가 올린 Github 이슈</a>에서 방법을 찾을 수 있었다.</p>\n<pre><code class=\"language-yml\">apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: redis-dp\nspec:\n  selector:\n    matchLabels:\n      app: redis\n  template:\n    metadata:\n      labels:\n        app: redis\n    spec:\n      containers:\n        - name: redis\n          image: redis:latest\n          ports:\n            - containerPort: 6379\n              protocol: TCP\n          env:\n            - name: REDIS_PASSWORD\n              value: { Redis 패스워드 }\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: redis-svc\nspec:\n  selector:\n    app: redis\n  ports:\n    - protocol: TCP\n      port: 6379\n</code></pre>\n<h1 id=\"4-spring\" style=\"position:relative;\"><a href=\"#4-spring\" aria-label=\"4 spring permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Spring</h1>\n<p>3개의 Spring Boot 마이크로 서비스 어플리케이션과, Spring Cloud 게이트웨이 하나로 이루어져 있다. 각각의 도커 이미지는 빌드하여 도커허브에 푸쉬했다.</p>\n<h2 id=\"41-도커-이미지-빌드\" style=\"position:relative;\"><a href=\"#41-%EB%8F%84%EC%BB%A4-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B9%8C%EB%93%9C\" aria-label=\"41 도커 이미지 빌드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.1. 도커 이미지 빌드</h2>\n<p>Spring Boot의 Dockerfile은 다음과 같은 형식이다.</p>\n<pre><code class=\"language-Dockerfile\"># 기반 이미지 선택\nFROM openjdk:11\n\n# 작업 디렉토리 생성\nWORKDIR /app\n\n# 빌드된 JAR 파일을 Docker 이미지 내 /app 디렉토리로 복사\nCOPY build/libs/gallery-0.0.1-SNAPSHOT.jar /app/app.jar\n\n# 특정 포트로 Listen\nEXPOSE { 포트 번호 }\n\n# JAR 파일 실행\nCMD [\"java\", \"-jar\", \"app.jar\"]\n</code></pre>\n<h2 id=\"42-환경변수-정의\" style=\"position:relative;\"><a href=\"#42-%ED%99%98%EA%B2%BD%EB%B3%80%EC%88%98-%EC%A0%95%EC%9D%98\" aria-label=\"42 환경변수 정의 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.2. 환경변수 정의</h2>\n<p>다른 서비스에 접근하기 위해서는 IP/Port를 알아야한다. 예를 들어, 게이트웨이가 라우팅을 하려면 각 Spring Boot 서버의 IP 주소 정보가 있어야 한다. 그런데 쿠버네티스에는 IP 주소가 동적으로 할당되기 때문에 service 이름으로 접근한다. 그런데 어플리케이션 수준에서 쿠버네티스의 정보(서비스 이름)를 사용하는 것은 이상하다. 그래서 반대로 가기로 했다.</p>\n<p>먼저 SpringBoot의 application.properties 파일에서 필요한 정보를 <mark>하드코딩하지 않고 환경변수로 정의했다.</mark></p>\n<pre><code class=\"language-properties\">spring.redis.host=${REDIS_HOST}\nspring.redis.port=${REDIS_PORT}\n</code></pre>\n<p>그리고 이후에 쿠버네티스의 yaml 파일을 쟉성할 때, 환경 변수에 대응하는 값을 넘겨주었다.</p>\n<pre><code class=\"language-yml\">apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  ...\nspec:\n  selector:\n    matchLabels:\n      ...\n  template:\n    metadata:\n      ...\n    spec:\n      containers:\n        - env:\n          - name: REDIS_HOST\n            value: { redis 서비스 이름 } # 위 3번 항목 설정대로라면 \"redis-svc\"\n          - name: REDIS_PORT\n            value: { redis 클러스터 포트 } # 위 3번 항목 설정대로라면 6379\n        ...\n</code></pre>\n<h2 id=\"43-spring-boot-마이크로-서버\" style=\"position:relative;\"><a href=\"#43-spring-boot-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EC%84%9C%EB%B2%84\" aria-label=\"43 spring boot 마이크로 서버 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.3. Spring Boot 마이크로 서버</h2>\n<p>아래 예시 코드에서 환경변수는 application.properties에서 어떤 식으로 정의했느냐에 따라 달라진다. 예를 들어, REDIS는 Host(IP주소)와 Port를 따로따로 정의했지만, MySQL같은 경우에는 한번에 내려줬다.</p>\n<pre><code class=\"language-yml\">apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: member-dp\nspec:\n  selector:\n    matchLabels:\n      app: member\n  template:\n    metadata:\n      labels:\n        app: member\n    spec:\n      containers:\n        - image: { Member 마이크로 서버 이미지 }\n          name: member\n          env:\n            - name: REDIS_HOST\n              value: { Redis 서비스 이름 } # 위 3번 항목 설정대로라면 \"redis-svc\"\n            - name: REDIS_PORT\n              value: { Redis 클러스터 포트 } # 위 3번 항목 설정대로라면 6379\n            - name: REDIS_PASSWORD\n              value: { Redis 패스워드 }\n            - name: MYSQL_SERVER\n              value: { MySQL 서비스 이름: MySQL 클러스터 포트 }\n            - name: MYSQL_USER\n              value: { MySQL 아이디 }\n            - name: MYSQL_PASSWORD\n              value: { MySQL 패스워드 }\n            - name: KAFKA_SERVER\n              value: { Kafka 서비스 이름: Kafka 클러스터 포트 }\n          ports:\n            - containerPort: 8001\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: member-svc\nspec:\n  ports:\n    - port: 8001\n  selector:\n    app: member\n</code></pre>\n<h2 id=\"42-spring-cloud-게이트웨이\" style=\"position:relative;\"><a href=\"#42-spring-cloud-%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4\" aria-label=\"42 spring cloud 게이트웨이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.2. Spring Cloud 게이트웨이</h2>\n<p>Spring Cloud도 Spring Boot 서버와 동일한 방식으로 작성했다.</p>\n<pre><code class=\"language-yml\">apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: gateway-dp\n\nspec:\n  selector:\n    matchLabels:\n      app: gateway\n  template:\n    metadata:\n      labels:\n        app: gateway\n    spec:\n      containers:\n        - image: { 게이트웨이 이미지 }\n          name: gateway\n          env:\n            - name: MEMBER_SERVER\n              value: { Member 마이크로 서비스 이름: 클러스터 포트 } # 위 4.3.번 항목 설정대로라면 \"member-svc:8001\"\n            - name: GALLERY_SERVER\n              value: { Gallery 마이크로 서비스 이름: 클러스터 포트 }\n            - name: POST_SERVER\n              value: { Post 마이크로 서비스 이름: 클러스터 포트 }\n            - name: REDIS_HOST\n              value: { Redis 서비스 이름 } # 위 3번 항목 설정대로라면 \"redis-svc\"\n            - name: REDIS_PORT\n              value: { Redis 클러스터 포트 } # 위 3번 항목 설정대로라면 6379\n            - name: REDIS_PASSWORD\n              value: { Redis 패스워드 }\n          ports:\n            - containerPort: 8000\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: gateway-svc\nspec:\n  ports:\n    - port: 8000\n  selector:\n    app: gateway\n</code></pre>\n<h1 id=\"5-kafka\" style=\"position:relative;\"><a href=\"#5-kafka\" aria-label=\"5 kafka permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. Kafka</h1>\n<p>Kafka를 쿠버네티스에 올리는 것은 다른 어플리케이션과 다른 모양이다. 이를 위해서\nConfluent나 Strimzi와 같은 오픈소스 프로젝트도 따로 제공된다. 따라서 이 부분에서는 아직 부족한점이 있을 것으로 생각된다. 일단 <a href=\"https://docs.confluent.io/platform/current/installation/docker/config-reference.html\">Confluent 도커 설정</a>을 참고하여 작성했다.</p>\n<h2 id=\"51-zookeeper\" style=\"position:relative;\"><a href=\"#51-zookeeper\" aria-label=\"51 zookeeper permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5.1. Zookeeper</h2>\n<p><code>ZOOKEEPER_CLIENT_PORT</code>는 Kafka의 요청을 수신할 포트로, Zookeeper 자기 자신의 클러스터 포트와 일치시키면 된다. <code>ZOOKEEPER_TICK_TIME</code>는 주키퍼 하트비트로 시간(ms)로, 이 클럭에 따라 주키퍼 내의 각 서버(노드) 간에 정보가 교환된다.</p>\n<pre><code class=\"language-yml\">apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: zookeeper-dp\n\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: zookeeper\n  template:\n    metadata:\n      labels:\n        app: zookeeper\n    spec:\n      containers:\n        - name: zookeeper\n          image: confluentinc/cp-zookeeper:7.0.1\n          ports:\n            - containerPort: 2181\n          env:\n            - name: ZOOKEEPER_CLIENT_PORT\n              value: 2181 # Zookeeper 자신의 서비스 포트와 일치\n            - name: ZOOKEEPER_TICK_TIME\n              value: 2000\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: zookeeper-svc\nspec:\n  selector:\n    app: zookeeper\n  ports:\n    - protocol: TCP\n      port: 2181\n</code></pre>\n<h2 id=\"52-kafka-broker\" style=\"position:relative;\"><a href=\"#52-kafka-broker\" aria-label=\"52 kafka broker permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5.2. Kafka Broker</h2>\n<p><code>KAFKA_ZOOKEEPER_CONNECT</code>는 연결할 Zookeeper 의 IP/Port 정보를 기입한다. <code>KAFKA_ADVERTISED_LISTENERS</code>는 외부에서 접근할 수 있는 Kafka의 IP/Port 정보를 기입한다.</p>\n<pre><code class=\"language-yml\">apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: kafka-dp\n\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: kafka\n  template:\n    metadata:\n      labels:\n        app: kafka\n    spec:\n      containers:\n        - name: broker\n          image: confluentinc/cp-kafka:7.0.1\n          ports:\n            - containerPort: 9092\n          env:\n            - name: KAFKA_BROKER_ID\n              value: '1'\n            - name: KAFKA_ZOOKEEPER_CONNECT\n              value: { Zookeeper 서비스 이름: 클러스터 포트 } # 위 5.1 항목 설정대로라면 \"zookeeper-svc:2181\"\n            - name: KAFKA_LISTENER_SECURITY_PROTOCOL_MAP\n              value: PLAINTEXT:PLAINTEXT,\n            - name: KAFKA_ADVERTISED_LISTENERS\n              value: PLAINTEXT://{ Kafka 서비스 이름: 클러스터 포트 } # 현재 설정대로라면 \"kafka-svc:9092\"\n            - name: KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR\n              value: '1'\n            - name: KAFKA_TRANSACTION_STATE_LOG_MIN_ISR\n              value: '1'\n            - name: KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR\n              value: '1'\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: kafka-svc\nspec:\n  selector:\n    app: kafka\n  ports:\n    - protocol: TCP\n      port: 9092\n</code></pre>\n<h1 id=\"참고자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\" aria-label=\"참고자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고자료</h1>\n<ul>\n<li><a href=\"https://github.com/docker-library/redis/issues/176#issuecomment-1620310639\">Redis 도커 패스워드 설정 Issue</a></li>\n<li><a href=\"https://docs.confluent.io/platform/current/installation/docker/config-reference.html#\">Confluent 플랫폼 도커 사용 설명서</a></li>\n<li><a href=\"https://www.confluent.io/blog/apache-kafka-kubernetes-could-you-should-you/\">Confluent : \"Apache Kafka on Kubernetes – Could You? Should You?\"</a></li>\n<li><a href=\"https://kgw7401.tistory.com/106\">오몰내알 : \"쿠버네티스에서 카프카(kafka on k8s) 정말 좋은 선택일까?\"</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-msa-%EA%B5%AC%EC%A1%B0\">1. MSA 구조</a></p>\n</li>\n<li>\n<p><a href=\"#2-redis\">2. Redis</a></p>\n</li>\n<li>\n<p><a href=\"#4-spring\">4. Spring</a></p>\n<ul>\n<li><a href=\"#41-%EB%8F%84%EC%BB%A4-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B9%8C%EB%93%9C\">4.1. 도커 이미지 빌드</a></li>\n<li><a href=\"#42-%ED%99%98%EA%B2%BD%EB%B3%80%EC%88%98-%EC%A0%95%EC%9D%98\">4.2. 환경변수 정의</a></li>\n<li><a href=\"#43-spring-boot-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EC%84%9C%EB%B2%84\">4.3. Spring Boot 마이크로 서버</a></li>\n<li><a href=\"#42-spring-cloud-%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4\">4.2. Spring Cloud 게이트웨이</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#5-kafka\">5. Kafka</a></p>\n<ul>\n<li><a href=\"#51-zookeeper\">5.1. Zookeeper</a></li>\n<li><a href=\"#52-kafka-broker\">5.2. Kafka Broker</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\">참고자료</a></p>\n</li>\n</ul>","frontmatter":{"title":"k3s 배포하기 (4) : 백엔드(Redis, Spring, Kafka) 배포","createdAt":"2024-01-21","updatedAt":"2024-01-21","tags":["kubernetes","k3s","AWS","lightsail","DevOps","백엔드","Redis","Spring Boot","Kafka","MSA"],"description":"AWS 인스턴스에 k3s 단일 노드 클러스터를 구축해본다.  MSA 구조를 가진 백엔드 아키텍쳐를 k3s에 등록해보자","reference":null}},"allMarkdownRemark":{"nodes":[{"id":"353ab996-d3e6-5556-8c06-077b7b2f6370","excerpt":"1. 프로젝트 개요 백엔드 개발자 친구와 함께 쿠버네티스를 연습하기 위한 토이프로젝트를 만들었다. 명색이 쿠버네티스 프로젝트인데 MSA를 안할 수 없었다. 백엔드가 MSA로 바쁜데, 프론트가 가만히 있을 수 없어 Three.js…","parent":{"id":"9922ca6f-2e24-5b46-af05-3d732bdc680a","name":"k3s_1_intro","relativePath":"DevOps/Kubernetes/k3s_1_intro.md"},"frontmatter":{"title":"k3s 배포하기 (1) : 프로젝트 개요 & 사전 준비","createdAt":"2024-01-21","updatedAt":"2024-01-21"},"fields":{"slug":"/posts/DevOps/Kubernetes/k3s_1_intro/"}},{"id":"8d4891d2-35c4-5d9e-ba8b-cbd3586aa466","excerpt":"프론트는 너무 간단하다. Next.js같은 풀스텍 프레임워크를 사용하면 좀 더 흥미로울 것 같다. 1. 도커 이미지 리액트 프로젝트를 빌드하면 정적 파일이 생성된다. 이러한 정적 컨텐츠를 서비스하기 위해서는 웹서버가 필요하다. 그래서 Nginx…","parent":{"id":"78f25f94-3f4b-51ed-8127-3ba754a426e0","name":"k3s_2_front","relativePath":"DevOps/Kubernetes/k3s_2_front.md"},"frontmatter":{"title":"k3s 배포하기 (2) : 프론트(React) 배포","createdAt":"2024-01-21","updatedAt":"2024-01-21"},"fields":{"slug":"/posts/DevOps/Kubernetes/k3s_2_front/"}},{"id":"4fc2f125-d6bf-558f-a3ac-450a8111a5aa","excerpt":"본래 DB의 아이디와 패스워드는 쿠버네티스에서 Secret 등으로 관리해야 한다. Secret 생성과 적용은 이후 포스팅에서 따로 다룰 예정이다. 1. PV, PVC 쿠버네티스에서는 파드가 죽으면 알아서 다시 띄워준다. 그런데 MySQL…","parent":{"id":"497e574b-50c4-5789-b252-f5e123645d29","name":"k3s_3_mysql","relativePath":"DevOps/Kubernetes/k3s_3_mysql.md"},"frontmatter":{"title":"k3s 배포하기 (3) : 데이터베이스(MySQL) 배포","createdAt":"2024-01-21","updatedAt":"2024-01-21"},"fields":{"slug":"/posts/DevOps/Kubernetes/k3s_3_mysql/"}},{"id":"105f9b57-232d-5894-b19b-9530e548ea7a","excerpt":"본래 DB의 아이디와 패스워드는 쿠버네티스에서 Secret 등으로 관리해야 한다. Secret 생성과 적용은 이후 포스팅에서 따로 다룰 예정이다. 1. MSA 구조 백엔드는 MSA 구조로 설계되어 총 3개의 Spring Boot…","parent":{"id":"fc9e8efe-87a2-5ae4-9522-a7be3b623338","name":"k3s_4_back","relativePath":"DevOps/Kubernetes/k3s_4_back.md"},"frontmatter":{"title":"k3s 배포하기 (4) : 백엔드(Redis, Spring, Kafka) 배포","createdAt":"2024-01-21","updatedAt":"2024-01-21"},"fields":{"slug":"/posts/DevOps/Kubernetes/k3s_4_back/"}}]}},"pageContext":{"pagePath":"/posts/DevOps/Kubernetes/k3s_4_back/","siblingPostsPathRegex":"/^(?!.*README).*DevOps\\/Kubernetes\\/.*$/","relativeDirectory":"Kubernetes","id":"105f9b57-232d-5894-b19b-9530e548ea7a","parent":{"id":"fc9e8efe-87a2-5ae4-9522-a7be3b623338","name":"k3s_4_back","relativePath":"DevOps/Kubernetes/k3s_4_back.md"},"fields":{"slug":"/posts/DevOps/Kubernetes/k3s_4_back/"}}},"staticQueryHashes":["24302420","4059933791"],"slicesMap":{}}