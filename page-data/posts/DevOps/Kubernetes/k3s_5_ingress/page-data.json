{"componentChunkName":"component---src-templates-post-index-tsx","path":"/posts/DevOps/Kubernetes/k3s_5_ingress/","result":{"data":{"markdownRemark":{"id":"b074c93c-6fee-597f-84a0-4ae2ca498c4e","html":"<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/c6d88d67d00854eaafdfb5ad9420fe8f/2bef9/architecture-ingress.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 70.28571428571428%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAAByUlEQVR42n2UC27bQAxEc/+zFegR+kGR2hUkW9J+uSRfsCvXDoI4CwwgccnRDAnqBXA+HDNjXVdKU6bkI8FaoZaCtVfcC0+Ov9yfrOGScBVcCiWstJKIKYMKkndSj6XzyKMJtPqA1qHt5SFL8e03bD8hL1i+4HmBsuBphrRgcUbDAvkycnrsgblbe0foBvGEt2lYkryR0op5wRGgoppQK7gmrIYRu0O2IeodoUK+AjoSepFKYKuJv7di1Qw06nwi//lx5HonlAdhrYUQAqZC2ydMI7HufPs3s+dtqIuawAt7mdjyRK0BbYlmhVg21BLIfhC21qi13hQuQ0nVzPdBGGhtRzokDsLULrRONtRWRDPmTy1f7j3pfXSvpLoQZaFJQnRHLZJTJOc4+muWccpD4TNC1XIQUzDPg/CaT4fKFAe6ulACavlrQrXKr3O3c1PbY8NmQD0hcgDK/f4Ly4K5cAkH8ZgggrbMJb2ylolS+0AyrbdEwnDwucI4g4YBtwgab+87dNstYL2wT12Pe20B7znl+oGwb6weK+RayWFDaxxrhwn0tZvOXPMx5RG/5d9xW71Pfg7OvEaqyP9PwbrC6czZd9JoxafH3gAh2EsnGsQx6QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/TIL/static/c6d88d67d00854eaafdfb5ad9420fe8f/c54d4/architecture-ingress.webp 175w,\n/TIL/static/c6d88d67d00854eaafdfb5ad9420fe8f/a3432/architecture-ingress.webp 350w,\n/TIL/static/c6d88d67d00854eaafdfb5ad9420fe8f/426ac/architecture-ingress.webp 700w,\n/TIL/static/c6d88d67d00854eaafdfb5ad9420fe8f/a9a89/architecture-ingress.webp 1024w\" sizes=\"(max-width: 700px) 100vw, 700px\" type=\"image/webp\">\n          <source srcset=\"/TIL/static/c6d88d67d00854eaafdfb5ad9420fe8f/4edbd/architecture-ingress.png 175w,\n/TIL/static/c6d88d67d00854eaafdfb5ad9420fe8f/13ae7/architecture-ingress.png 350w,\n/TIL/static/c6d88d67d00854eaafdfb5ad9420fe8f/8c557/architecture-ingress.png 700w,\n/TIL/static/c6d88d67d00854eaafdfb5ad9420fe8f/2bef9/architecture-ingress.png 1024w\" sizes=\"(max-width: 700px) 100vw, 700px\" type=\"image/png\">\n          <img class=\"gatsby-resp-image-image\" src=\"/TIL/static/c6d88d67d00854eaafdfb5ad9420fe8f/8c557/architecture-ingress.png\" alt=\"프로젝트 아키텍쳐 구상도\" title=\"\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span>\n<h1 id=\"1-인그레스-삽질기️\" style=\"position:relative;\"><a href=\"#1-%EC%9D%B8%EA%B7%B8%EB%A0%88%EC%8A%A4-%EC%82%BD%EC%A7%88%EA%B8%B0%EF%B8%8F\" aria-label=\"1 인그레스 삽질기️ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 인그레스 삽질기⚒️</h1>\n<blockquote>\n<p>이 항목은 k3s를 사용할 경우 참고하지 않아도 되는 삽질기입니다.</p>\n</blockquote>\n<p>우리는 k3s가 그저 쿠버네티스의 경량화 버전인줄로만 알았다. 그래서 <strong>추가 편의 기능이 구현</strong>되어있을 줄 꿈에도 몰랐다. 그저 쿠버네티스 공식문서를 따라 인그레스 컨트롤러를 설치했을 뿐인데 희한한 에러를 경험했고, 나중에 가서야 <mark>이것이 k3s의 기본 탑재된 Traefik 인그레스 컨트롤러 때문이었음을 깨달았다.</mark></p>\n<h2 id=\"11-인그레스-컨트롤러-설치\" style=\"position:relative;\"><a href=\"#11-%EC%9D%B8%EA%B7%B8%EB%A0%88%EC%8A%A4-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC-%EC%84%A4%EC%B9%98\" aria-label=\"11 인그레스 컨트롤러 설치 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1. 인그레스 컨트롤러 설치</h2>\n<p><a href=\"https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/\">쿠버네티스 공식문서</a>를 보면, 인그레스 사용하기 위해서는 인그레스 컨트롤러를 추가 설치하라고 한다. 많은 컨트롤러 중에 가장 익숙해 보이는 Nginx Ingress Controller를 선택했다.</p>\n<p>Nginx Ingress Controller는 사용 환경에 따라 다양한 설치방법을 제공한다. 그 중에서 AWS와 Bare Metal 두가지 방식이 있는데, AWS 인스턴스에 직접 클러스트를 구성하는 경우에는 어떤 것을 선택해야하는지 아직도 확신이 안선다. 일단 우리는 <a href=\"https://kubernetes.github.io/ingress-nginx/deploy/#bare-metal-clusters\">Bare Metal 방식</a>으로 진행했다.</p>\n<p>아래 명령어를 실행하면 30000-32767 중 임의의 NodePort로 인그레스가 노출된다.</p>\n<pre><code class=\"language-sh\">kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.2/deploy/static/provider/baremetal/deploy.yaml\n</code></pre>\n<h2 id=\"12-인그레스-컨트롤러-nodeport-고정\" style=\"position:relative;\"><a href=\"#12-%EC%9D%B8%EA%B7%B8%EB%A0%88%EC%8A%A4-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC-nodeport-%EA%B3%A0%EC%A0%95\" aria-label=\"12 인그레스 컨트롤러 nodeport 고정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2. 인그레스 컨트롤러 NodePort 고정</h2>\n<p>MetalLB를 사용해서 인그레스가 열리는 NodePort를 80번으로 고정시킬 수 있다. 그런데 <a href=\"https://kubernetes.github.io/ingress-nginx/deploy/baremetal/\">문서</a>를 읽어보면 신세계가 열린다. Layer2 설정까지 내려가는데 무엇인가 잘못되었음을 직감했다.</p>\n<p>이 때 잠시 멈춰 되돌아 보았어야 했는데, 우리는 열심히 직진 페달을 밟았다. 위에 1.1 항목의 <code>deploy.yml</code>파일을 다운받아 분석한 다음, 일부를 수정해서 인그레스가 열리는 NodePort를 30000번으로 고정해내고야 만다. (NodePort는 30000번 이상의 포트로만 열수 있기 때문에 80번 포트로는 열지 못했다.)</p>\n<pre><code class=\"language-yml\"># deploy.yml 356번째 줄\nnodePort: 30000 # 30000번 포트로 고정해서 오픈\n</code></pre>\n<h2 id=\"12-간이-로드-밸런서-구현\" style=\"position:relative;\"><a href=\"#12-%EA%B0%84%EC%9D%B4-%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%84%9C-%EA%B5%AC%ED%98%84\" aria-label=\"12 간이 로드 밸런서 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2. 간이 로드 밸런서 구현</h2>\n<p><a href=\"https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#external-load-balancer-providers\">로드 밸런서</a>는 쿠버네티스의 외부에서 동작하며, 보통 클라우드 서비스 EKS, GKE 등에서 제공한다. 하지만 우리는 Ligthsail 인스턴스에서 단일 노드 클러스터를 구축했다. 그리고 1.2.항목에서 MetalLB를 사용하지 않고 인그레스를 30000번으로 열어두었다. 또 한번의 질주로 결심하고, 호스트에 Nginx를 설치해 80번 포트로 수신하는 모든 요청을 인그레스로 넘겨주기로 했다.</p>\n<pre><code class=\"language-bash\"># Nginx 설치\nsudo apt-get update\nsudo apt-get install -y nginx\n</code></pre>\n<pre><code class=\"language-conf\"># nginx.conf\nupstream ingress {\n\tserver 127.0.0.1:30000; # 30000번으로 열린 인그레스로 전달\n}\n\nserver {\n\tlisten 80;\n\tlisten [::]:80;\n\n\tserver_name 3.35.238.150 thegallery.site;\n\n\tlocation / {\n\t\tproxy_pass http://ingress;\n\t\tproxy_set_header Host $host;\n\t\tproxy_set_header X-Real-IP $remote_addr;\n\t\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n\t\tproxy_set_header X-Forwarded-Proto $scheme;\n\t}\n}\n</code></pre>\n<h2 id=\"13-이상-동작과-원인\" style=\"position:relative;\"><a href=\"#13-%EC%9D%B4%EC%83%81-%EB%8F%99%EC%9E%91%EA%B3%BC-%EC%9B%90%EC%9D%B8\" aria-label=\"13 이상 동작과 원인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.3. 이상 동작과 원인</h2>\n<p>그런데 요청이 아예 호스트 Nginx에 도달하지 않았다. 프로세스를 검색해봐도 80번 포트를 점유하고 있는 것은 호스트에 설치한 Nginx 뿐이었다. 몇 번의 테스트 끝에, k3s가 실행되는 즉시 Nginx의 80번 포트 수신이 막히는 것을 확인했다. 구글링한 결과 알게 된 사실은 <mark>'k3s에는 Traefik 인그레스 컨트롤러가 기본 탑재되어 80과 443 포트를 점유한다는 것'이었다..</mark></p>\n<h1 id=\"2-traefik-인그레스-컨트롤러\" style=\"position:relative;\"><a href=\"#2-traefik-%EC%9D%B8%EA%B7%B8%EB%A0%88%EC%8A%A4-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC\" aria-label=\"2 traefik 인그레스 컨트롤러 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Traefik 인그레스 컨트롤러</h1>\n<p><a href=\"https://docs.k3s.io/kr/networking\">Traefik 인그레스 컨트롤러</a>는 포트 80과 443을 사용하는 로드밸런서 서비스를 배포한다. 이를 이용해서 HTTP 역방향 프록시 및 로드밸런서가 손쉽게 구현된다. 서버를 시작할 때 기본적으로 Traefik이 실행되기 때문에 80과 443포트는 다른 서비스에서 사용할 수 없다. 이를 비활성화 하려면 <code>--disable=traefik</code> 플래그를 사용해서 k3s를 시작해야한다.</p>\n<h2 id=\"21-traefik-인그레스-규칙\" style=\"position:relative;\"><a href=\"#21-traefik-%EC%9D%B8%EA%B7%B8%EB%A0%88%EC%8A%A4-%EA%B7%9C%EC%B9%99\" aria-label=\"21 traefik 인그레스 규칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. Traefik 인그레스 규칙</h2>\n<p><a href=\"https://doc.traefik.io/traefik/providers/kubernetes-ingress/\">Traefik 공식문서</a>에서 쿠버네티스 인그레스 설정을 확인할 수 있다. Nginx 파일과 유사한 형식으로 쉽게 설정할 수 있다.</p>\n<pre><code class=\"language-yml\"># traefik-ingress.yml\n\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: myingress\n  annotations:\n    traefik.ingress.kubernetes.io/router.entrypoints: web\nspec:\n  rules:\n    - host: { 도메인 네임 }\n      http:\n        paths:\n          - path: /\n            pathType: Prefix\n            backend:\n              service:\n                name: react-svc # 프론트 서비스 이름\n                port:\n                  number: 80\n          - path: /api\n            pathType: Prefix\n            backend:\n              service:\n                name: gateway-svc # 백엔드 게이트웨이 서비스 이름\n                port:\n                  number: 8000\n</code></pre>\n<pre><code class=\"language-bash\"># 인그레스 규칙 적용\nkubectl apply -f traefik-ingress.yml\n</code></pre>\n<h1 id=\"참고자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\" aria-label=\"참고자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고자료</h1>\n<ul>\n<li><a href=\"https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/\">kubernetes : \"Intress Controllers\"</a></li>\n<li><a href=\"https://kubernetes.github.io/ingress-nginx/deploy/#bare-metal-clusters\">Ingress Nginx : \"Getting Started\"</a></li>\n<li><a href=\"https://docs.k3s.io/networkings\">k3s : \"Networking\"</a></li>\n<li><a href=\"https://doc.traefik.io/traefik/providers/kubernetes-ingress/\">traefiklabs : \"Traefik &#x26; Kubernetes\"</a></li>\n<li><a href=\"https://stackoverflow.com/questions/45079988/ingress-vs-load-balancer\">Stack Overflow : \"Ingress vs Load Balancer\"</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-%EC%9D%B8%EA%B7%B8%EB%A0%88%EC%8A%A4-%EC%82%BD%EC%A7%88%EA%B8%B0%EF%B8%8F\">1. 인그레스 삽질기⚒️</a></p>\n<ul>\n<li><a href=\"#11-%EC%9D%B8%EA%B7%B8%EB%A0%88%EC%8A%A4-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC-%EC%84%A4%EC%B9%98\">1.1. 인그레스 컨트롤러 설치</a></li>\n<li><a href=\"#12-%EC%9D%B8%EA%B7%B8%EB%A0%88%EC%8A%A4-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC-nodeport-%EA%B3%A0%EC%A0%95\">1.2. 인그레스 컨트롤러 NodePort 고정</a></li>\n<li><a href=\"#12-%EA%B0%84%EC%9D%B4-%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%84%9C-%EA%B5%AC%ED%98%84\">1.2. 간이 로드 밸런서 구현</a></li>\n<li><a href=\"#13-%EC%9D%B4%EC%83%81-%EB%8F%99%EC%9E%91%EA%B3%BC-%EC%9B%90%EC%9D%B8\">1.3. 이상 동작과 원인</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-traefik-%EC%9D%B8%EA%B7%B8%EB%A0%88%EC%8A%A4-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC\">2. Traefik 인그레스 컨트롤러</a></p>\n<ul>\n<li><a href=\"#21-traefik-%EC%9D%B8%EA%B7%B8%EB%A0%88%EC%8A%A4-%EA%B7%9C%EC%B9%99\">2.1. Traefik 인그레스 규칙</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\">참고자료</a></p>\n</li>\n</ul>","frontmatter":{"title":"k3s 배포하기(5) : Traefik 인그레스 설정","createdAt":"2024-01-23","updatedAt":"2024-01-23","tags":["kubernetes","k3s","AWS","lightsail","DevOps","Ingress","Traefik","프록시 패스"],"description":"AWS 인스턴스에 k3s 단일 노드 클러스터를 구축해본다. Traefik 인그레스 설정을 통해 요청을 프록시패스 해보자","reference":null}},"allMarkdownRemark":{"nodes":[{"id":"b074c93c-6fee-597f-84a0-4ae2ca498c4e","excerpt":"1. 인그레스 삽질기⚒️ 이 항목은 k3s를 사용할 경우 참고하지 않아도 되는 삽질기입니다. 우리는 k3s…","parent":{"id":"cf6e57cc-27bd-5a23-a936-4c1be07c330f","name":"k3s_5_ingress","relativePath":"DevOps/Kubernetes/k3s_5_ingress.md"},"frontmatter":{"title":"k3s 배포하기(5) : Traefik 인그레스 설정","createdAt":"2024-01-23","updatedAt":"2024-01-23"},"fields":{"slug":"/posts/DevOps/Kubernetes/k3s_5_ingress/"}},{"id":"6f01b89a-ec71-5dfa-b6a3-8bf60f330a93","excerpt":"1. Cert Manager Cert Manager는 쿠버네티스에서 SSL/TLS 인증서를 관리하기 위한 오픈 소스 도구이다. Let's Encrypt와 같은 인증 기관을 사용하여 인증서를 발급하고 갱신하는 작업을 자동화한다. 개인적으로 Certbot…","parent":{"id":"fee655a1-4c88-55d5-b977-a0a4688b4e3b","name":"k3s_6_cert_manager","relativePath":"DevOps/Kubernetes/k3s_6_cert_manager.md"},"frontmatter":{"title":"k3s 배포하기(6) : Cert Manager 등록","createdAt":"2024-01-23","updatedAt":"2024-01-23"},"fields":{"slug":"/posts/DevOps/Kubernetes/k3s_6_cert_manager/"}},{"id":"4fc2f125-d6bf-558f-a3ac-450a8111a5aa","excerpt":"본래 DB의 아이디와 패스워드는 쿠버네티스에서 Secret 등으로 관리해야 한다. Secret 생성과 적용은 이후 포스팅에서 따로 다룰 예정이다. 1. PV, PVC 쿠버네티스에서는 파드가 죽으면 알아서 다시 띄워준다. 그런데 MySQL…","parent":{"id":"497e574b-50c4-5789-b252-f5e123645d29","name":"k3s_3_mysql","relativePath":"DevOps/Kubernetes/k3s_3_mysql.md"},"frontmatter":{"title":"k3s 배포하기(3) : 데이터베이스(MySQL) 배포","createdAt":"2024-01-22","updatedAt":"2024-01-22"},"fields":{"slug":"/posts/DevOps/Kubernetes/k3s_3_mysql/"}},{"id":"105f9b57-232d-5894-b19b-9530e548ea7a","excerpt":"본래 DB의 아이디와 패스워드는 쿠버네티스에서 Secret 등으로 관리해야 한다. Secret 생성과 적용은 이후 포스팅에서 따로 다룰 예정이다. 1. MSA 구조 백엔드는 MSA 구조로 설계되어 총 3개의 Spring Boot…","parent":{"id":"fc9e8efe-87a2-5ae4-9522-a7be3b623338","name":"k3s_4_back","relativePath":"DevOps/Kubernetes/k3s_4_back.md"},"frontmatter":{"title":"k3s 배포하기(4) : 백엔드(Redis, Spring, Kafka) 배포","createdAt":"2024-01-22","updatedAt":"2024-01-22"},"fields":{"slug":"/posts/DevOps/Kubernetes/k3s_4_back/"}},{"id":"353ab996-d3e6-5556-8c06-077b7b2f6370","excerpt":"1. 프로젝트 개요 백엔드 개발자 친구와 함께 쿠버네티스를 연습하기 위한 토이프로젝트를 만들었다. 명색이 쿠버네티스 프로젝트인데 MSA를 안할 수 없었다. 백엔드가 MSA로 바쁜데, 프론트가 가만히 있을 수 없어 Three.js…","parent":{"id":"9922ca6f-2e24-5b46-af05-3d732bdc680a","name":"k3s_1_intro","relativePath":"DevOps/Kubernetes/k3s_1_intro.md"},"frontmatter":{"title":"k3s 배포하기(1) : 프로젝트 개요 & 사전 준비","createdAt":"2024-01-21","updatedAt":"2024-01-21"},"fields":{"slug":"/posts/DevOps/Kubernetes/k3s_1_intro/"}},{"id":"8d4891d2-35c4-5d9e-ba8b-cbd3586aa466","excerpt":"프론트는 너무 간단하다. Next.js같은 풀스텍 프레임워크를 사용하면 좀 더 흥미로울 것 같다. 1. 도커 이미지 리액트 프로젝트를 빌드하면 정적 파일이 생성된다. 이러한 정적 컨텐츠를 서비스하기 위해서는 웹서버가 필요하다. 그래서 Nginx…","parent":{"id":"78f25f94-3f4b-51ed-8127-3ba754a426e0","name":"k3s_2_front","relativePath":"DevOps/Kubernetes/k3s_2_front.md"},"frontmatter":{"title":"k3s 배포하기(2) : 프론트(React) 배포","createdAt":"2024-01-21","updatedAt":"2024-01-21"},"fields":{"slug":"/posts/DevOps/Kubernetes/k3s_2_front/"}}]}},"pageContext":{"pagePath":"/posts/DevOps/Kubernetes/k3s_5_ingress/","siblingPostsPathRegex":"/^(?!.*README).*DevOps\\/Kubernetes\\/.*$/","relativeDirectory":"Kubernetes","id":"b074c93c-6fee-597f-84a0-4ae2ca498c4e","parent":{"id":"cf6e57cc-27bd-5a23-a936-4c1be07c330f","name":"k3s_5_ingress","relativePath":"DevOps/Kubernetes/k3s_5_ingress.md"},"fields":{"slug":"/posts/DevOps/Kubernetes/k3s_5_ingress/"}}},"staticQueryHashes":["24302420","4059933791"],"slicesMap":{}}