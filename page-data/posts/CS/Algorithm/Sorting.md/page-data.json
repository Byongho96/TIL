{"componentChunkName":"component---src-templates-post-index-tsx","path":"/posts/CS/Algorithm/Sorting.md/","result":{"data":{"markdownRemark":{"id":"47f2e077-42da-5fa8-a10c-8f6d807ef529","html":"<blockquote>\n<p>면접에서 탈탈 털린 후 작성한 정렬 관련 알고리즘을 총정리</p>\n</blockquote>\n<ul>\n<li><a href=\"#1-bubble-sort-%EA%B1%B0%ED%92%88-%EC%A0%95%EB%A0%AC\">1. Bubble Sort (거품 정렬)</a>\n<ul>\n<li><a href=\"#11-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">1.1. 동작 과정</a></li>\n<li><a href=\"#12-%EB%B3%B5%EC%9E%A1%EB%8F%84\">1.2. 복잡도</a></li>\n<li><a href=\"#13-python-%EA%B5%AC%ED%98%84\">1.3. Python 구현</a></li>\n</ul>\n</li>\n<li><a href=\"#2-selection-sort-%EC%84%A0%ED%83%9D-%EC%A0%95%EB%A0%AC\">2. Selection Sort (선택 정렬)</a>\n<ul>\n<li><a href=\"#21-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">2.1. 동작 과정</a></li>\n<li><a href=\"#22-%EB%B3%B5%EC%9E%A1%EB%8F%84\">2.2. 복잡도</a></li>\n<li><a href=\"#23-python-%EA%B5%AC%ED%98%84\">2.3. Python 구현</a></li>\n</ul>\n</li>\n<li><a href=\"#3-insertion-sort-%EC%82%BD%EC%9E%85-%EC%A0%95%EB%A0%AC\">3. Insertion Sort (삽입 정렬)</a>\n<ul>\n<li><a href=\"#31-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">3.1. 동작 과정</a></li>\n<li><a href=\"#32-%EB%B3%B5%EC%9E%A1%EB%8F%84\">3.2. 복잡도</a></li>\n<li><a href=\"#33-python-%EA%B5%AC%ED%98%84\">3.3. Python 구현</a></li>\n</ul>\n</li>\n<li><a href=\"#4-shell-sort-%EC%85%B8-%EC%A0%95%EB%A0%AC\">4. Shell Sort (셸 정렬)</a>\n<ul>\n<li><a href=\"#41-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">4.1. 동작 과정</a></li>\n<li><a href=\"#42-%EB%B3%B5%EC%9E%A1%EB%8F%84\">4.2. 복잡도</a></li>\n<li><a href=\"#43-python-%EA%B5%AC%ED%98%84\">4.3. Python 구현</a></li>\n</ul>\n</li>\n<li><a href=\"#5-heap-sort-%ED%9E%99-%EC%A0%95%EB%A0%AC\">5. Heap Sort (힙 정렬)</a></li>\n<li><a href=\"#6-merge-sort-%EB%B3%91%ED%95%A9-%EC%A0%95%EB%A0%AC\">6. Merge Sort (병합 정렬)</a>\n<ul>\n<li><a href=\"#61-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">6.1. 동작 과정</a></li>\n<li><a href=\"#62-%EB%B3%B5%EC%9E%A1%EB%8F%84\">6.2. 복잡도</a></li>\n<li><a href=\"#63-python-%EA%B5%AC%ED%98%84\">6.3. Python 구현</a></li>\n</ul>\n</li>\n<li><a href=\"#7-quick-sort-%ED%80%B5-%EC%A0%95%EB%A0%AC\">7. Quick Sort (퀵 정렬)</a>\n<ul>\n<li><a href=\"#71-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">7.1. 동작 과정</a></li>\n<li><a href=\"#72-%EB%B3%B5%EC%9E%A1%EB%8F%84\">7.2. 복잡도</a></li>\n<li><a href=\"#73-python-%EA%B5%AC%ED%98%84\">7.3. Python 구현</a></li>\n</ul>\n</li>\n<li><a href=\"#8-counting-sort-%EA%B3%84%EC%88%98-%EC%A0%95%EB%A0%AC\">8. Counting Sort (계수 정렬)</a>\n<ul>\n<li><a href=\"#81-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">8.1. 동작 과정</a></li>\n<li><a href=\"#82-%EB%B3%B5%EC%9E%A1%EB%8F%84\">8.2. 복잡도</a></li>\n<li><a href=\"#83-python-%EA%B5%AC%ED%98%84\">8.3. Python 구현</a></li>\n</ul>\n</li>\n<li><a href=\"#9-%EB%B3%B5%EC%9E%A1%EB%8F%84-%EB%B9%84%EA%B5%90\">9. 복잡도 비교</a></li>\n</ul>\n<h1 id=\"1-bubble-sort-거품-정렬\" style=\"position:relative;\"><a href=\"#1-bubble-sort-%EA%B1%B0%ED%92%88-%EC%A0%95%EB%A0%AC\" aria-label=\"1 bubble sort 거품 정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Bubble Sort (거품 정렬)</h1>\n<p>가장 시간복잡도가 높은 알고리즘이기 때문에 사용을 추천하지 않는다.<br>\n단 정렬이 완료되었는지를 루프마다 판단할 수 있어서, 거의 정렬이 된 데이터에 대해서는 유효한 성능을 낼 수 있다.</p>\n<h2 id=\"11-동작-과정\" style=\"position:relative;\"><a href=\"#11-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\" aria-label=\"11 동작 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1. 동작 과정</h2>\n<ol>\n<li>0 ~ n-1 번 인덱스에 대해서 현재 숫자와 뒤의 숫자를 비교한다. 현재 숫자가 더 클 경우 스왑한다.<br>\n그 결과 뒤에서 첫번째 수는 배열에서 첫번째로 큰 수가 자리한다.</li>\n<li>0 ~ n-2 번 인덱스에 대해서 현재 숫자와 뒤의 숫자를 비교한다. 현재 숫자가 더 클 경우 스왑한다.<br>\n그 결과 뒤에서 두번째 수는 배열에서 두번째로 큰 수가 자리한다.<br>\n...</li>\n<li>0 ~ 0 번 인덱스에 대해서 대해서 현재 숫자와 뒤의 숫자를 비교한다. 현재 숫자가 더 클 경우 스왑한다.<br>\n그 결과 뒤에서 N-1 번째 수는 배열에서 N-1번째로 큰 수가 자리한다.</li>\n</ol>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 652px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/43fda64724febd98f63199eb005c6bcf/a6d32/bubble_sort_image.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 114.85714285714286%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAXABQDASIAAhEBAxEB/8QAGQABAAMBAQAAAAAAAAAAAAAAAAIEBQED/8QAFgEBAQEAAAAAAAAAAAAAAAAAAQID/9oADAMBAAIQAxAAAAHSlw53GcWfoDaBX//EABoQAAMBAQEBAAAAAAAAAAAAAAABAhESExT/2gAIAQEAAQUCdMi9oWi62fozyZCro//EABoRAAICAwAAAAAAAAAAAAAAAAACARIQMWH/2gAIAQMBAT8B7BYVa6x//8QAGhEBAAEFAAAAAAAAAAAAAAAAAQAQEiExQf/aAAgBAgEBPwEeMtjndP/EAB0QAAEDBQEAAAAAAAAAAAAAAAIAEBEBITEyQpH/2gAIAQEABj8CvUfFEi3a6bUVgYb/xAAdEAADAAICAwAAAAAAAAAAAAAAAREhQTGRgaHh/9oACAEBAAE/IV89kO6UkxcGmeUFTFs45ZDY9wf1WJrgjVFwf//aAAwDAQACAAMAAAAQcDCA/8QAGREBAAIDAAAAAAAAAAAAAAAAAQARECFB/9oACAEDAQE/EEdM1C3GDZw//8QAGxEAAQQDAAAAAAAAAAAAAAAAAQAQESFhcfD/2gAIAQIBAT8QsI77aOQRxpMN/8QAHhABAAMAAgIDAAAAAAAAAAAAAQARITFBUWGRodH/2gAIAQEAAT8QSaPyp3kLBxuxlqNdc2kVlJq3BANW7Ssubu1/r93CCtW/JGVMVqt6hTXNrP/Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"bubble sort image\" title=\"\" src=\"/TIL/static/43fda64724febd98f63199eb005c6bcf/a6d32/bubble_sort_image.jpg\" srcset=\"/TIL/static/43fda64724febd98f63199eb005c6bcf/e52aa/bubble_sort_image.jpg 175w,\n/TIL/static/43fda64724febd98f63199eb005c6bcf/70ebb/bubble_sort_image.jpg 350w,\n/TIL/static/43fda64724febd98f63199eb005c6bcf/a6d32/bubble_sort_image.jpg 652w\" sizes=\"(max-width: 652px) 100vw, 652px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<h2 id=\"12-복잡도\" style=\"position:relative;\"><a href=\"#12-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"12 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2. 복잡도</h2>\n<ul>\n<li><strong>공간복잡도 O(1)</strong><br>\n주어진 배열 내에서 스왑하며 연산이 이뤄지기 때문에 추가 메모리를 필요로 하지 않는다.</li>\n<li><strong>시간복잡도 O(n**2)</strong><br>\n비교와 스왑 연산이 (n-1 + n-2 + n-3 + .... + 3 + 2 + 1)회 일어난다.<br>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 608px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/640be/bubble_sort_time_complexity.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 20%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAEABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3QUH/8QAFhABAQEAAAAAAAAAAAAAAAAAABFB/9oACAEBAAEFAtR//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFRABAQAAAAAAAAAAAAAAAAAAARD/2gAIAQEABj8CL//EABkQAAIDAQAAAAAAAAAAAAAAAAABESFBcf/aAAgBAQABPyFrRkXp0z//2gAMAwEAAgADAAAAEHPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxAAAgIDAQAAAAAAAAAAAAAAAAERgSFBUWH/2gAIAQEAAT8QgV22NY5axeiz/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"bubble sort time complexity\" title=\"\" src=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/640be/bubble_sort_time_complexity.jpg\" srcset=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/e52aa/bubble_sort_time_complexity.jpg 175w,\n/TIL/static/6612efa9c4891b8a1e34a1d50906b391/70ebb/bubble_sort_time_complexity.jpg 350w,\n/TIL/static/6612efa9c4891b8a1e34a1d50906b391/640be/bubble_sort_time_complexity.jpg 608w\" sizes=\"(max-width: 608px) 100vw, 608px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span><br>\n(단, 최선의 경우 O(n)의 복잡도를 가진다.)</li>\n</ul>\n<h2 id=\"13-python-구현\" style=\"position:relative;\"><a href=\"#13-python-%EA%B5%AC%ED%98%84\" aria-label=\"13 python 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.3. Python 구현</h2>\n<pre><code class=\"language-python\">def bubble_sort(nums):\n    N = len(nums)\n\n    # 배열의 길이에 대응하는 횟수만큼 루프를 돈다.\n    for i in range(N):\n        is_swapped = False  # 루프에 대해서 스왑여부를 판단하는 플래그\n\n        # 스왑여부를 탐색하는 배열 길이를 하나씩 줄여나간다.\n        # 루프를 돌 때마다, 탐색한 배열에서 가장 큰 숫자가 순서대로 뒷쪽에 쌓이기 때문.\n        for j in range(N - i -1):\n            if nums[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j] # 현재 숫자가 뒤의 숫자보다 클 경우, 스왑\n                is_swapped = True   # 플래그를 바꿔준다\n\n        if not is_swapped:  # 루프에 대해서 한 번도 스왑이 일어나지 않았으면, 정렬 완료\n            return nums\n\n    return nums\n</code></pre>\n<h1 id=\"2-selection-sort-선택-정렬\" style=\"position:relative;\"><a href=\"#2-selection-sort-%EC%84%A0%ED%83%9D-%EC%A0%95%EB%A0%AC\" aria-label=\"2 selection sort 선택 정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Selection Sort (선택 정렬)</h1>\n<h2 id=\"21-동작-과정\" style=\"position:relative;\"><a href=\"#21-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\" aria-label=\"21 동작 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. 동작 과정</h2>\n<ol>\n<li>0 ~ n-1번 인덱스 중 가장 작은 값을 찾아 0번 인덱스와 스왑한다.</li>\n<li>1 ~ n-1번 인덱스 중 가장 작은 값을 찾아 1번 인덱스와 스왑한다.<br>\n...</li>\n<li>n-2 ~ n-1번 인덱스 중 가장 작은 값을 찾아 n-2번 인덱스와 스왑한다.</li>\n</ol>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 512px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/73b4107b21dbe5e28b41a1735c712afe/36dd4/selection_sort_image.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 141.7142857142857%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAcABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAEDAgX/xAAVAQEBAAAAAAAAAAAAAAAAAAABAP/aAAwDAQACEAMQAAAB9tZGiJZ0nYH/xAAYEAEBAQEBAAAAAAAAAAAAAAABEDEAAv/aAAgBAQABBQJ2MOYZ6v8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGBAAAgMAAAAAAAAAAAAAAAAAIDEQEUH/2gAIAQEABj8CdBkof//EABwQAAIDAAMBAAAAAAAAAAAAAAABESExQWGBUf/aAAgBAQABPyGgK7fYsPM9nsvhixJUFw1xMqglOiSgWH//2gAMAwEAAgADAAAAEDzHDP/EABcRAAMBAAAAAAAAAAAAAAAAAAEQEUH/2gAIAQMBAT8Q1WmL/8QAFxEAAwEAAAAAAAAAAAAAAAAAARARQf/aAAgBAgEBPxDFIKv/xAAeEAEAAwACAwEBAAAAAAAAAAABABEhMUFRYXGBof/aAAgBAQABPxBgU89l3C22ngY/2cE9XDMRUOL4US1cX3XEJEXZPSMd78govw8TICCuCKNl5CACf//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"selection sort image\" title=\"\" src=\"/TIL/static/73b4107b21dbe5e28b41a1735c712afe/36dd4/selection_sort_image.jpg\" srcset=\"/TIL/static/73b4107b21dbe5e28b41a1735c712afe/e52aa/selection_sort_image.jpg 175w,\n/TIL/static/73b4107b21dbe5e28b41a1735c712afe/70ebb/selection_sort_image.jpg 350w,\n/TIL/static/73b4107b21dbe5e28b41a1735c712afe/36dd4/selection_sort_image.jpg 512w\" sizes=\"(max-width: 512px) 100vw, 512px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<h2 id=\"22-복잡도\" style=\"position:relative;\"><a href=\"#22-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"22 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2. 복잡도</h2>\n<ul>\n<li><strong>공간복잡도 O(1)</strong><br>\n주어진 배열 내에서 스왑하며 연산이 이뤄지기 때문에 추가 메모리를 필요로 하지 않는다.</li>\n<li><strong>시간복잡도 O(n**2)</strong><br>\n비교 연산이 (n-1 + n-2 + n-3 + .... + 3 + 2 + 1)회 일어나고, n-1번의 스왑 연산이 일어난다.<br>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 608px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/640be/bubble_sort_time_complexity.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 20%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAEABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3QUH/8QAFhABAQEAAAAAAAAAAAAAAAAAABFB/9oACAEBAAEFAtR//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFRABAQAAAAAAAAAAAAAAAAAAARD/2gAIAQEABj8CL//EABkQAAIDAQAAAAAAAAAAAAAAAAABESFBcf/aAAgBAQABPyFrRkXp0z//2gAMAwEAAgADAAAAEHPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxAAAgIDAQAAAAAAAAAAAAAAAAERgSFBUWH/2gAIAQEAAT8QgV22NY5axeiz/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"bubble sort time complexity\" title=\"\" src=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/640be/bubble_sort_time_complexity.jpg\" srcset=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/e52aa/bubble_sort_time_complexity.jpg 175w,\n/TIL/static/6612efa9c4891b8a1e34a1d50906b391/70ebb/bubble_sort_time_complexity.jpg 350w,\n/TIL/static/6612efa9c4891b8a1e34a1d50906b391/640be/bubble_sort_time_complexity.jpg 608w\" sizes=\"(max-width: 608px) 100vw, 608px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span></li>\n</ul>\n<h2 id=\"23-python-구현\" style=\"position:relative;\"><a href=\"#23-python-%EA%B5%AC%ED%98%84\" aria-label=\"23 python 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3. Python 구현</h2>\n<pre><code class=\"language-python\">def selection_sort(nums):\n    N = len(nums)\n\n    # N-1 번 최솟값을 찾아낸다.\n    for i in range(N - 1):\n        min_idx = i # i번째 숫자를 포함(기준으로 삼음)\n\n        # i+1번째부터 순회하며 i번째 가장 작은 값을 탐색\n        for j in range(i + 1, N):\n            if nums[j] &#x3C; nums[min_idx]:\n                min_idx = j\n\n        nums[i], nums[min_idx] = nums[min_idx], nums[i] # i번째 숫자와 i번째 작은 숫자를 스왑\n    return nums\n</code></pre>\n<h1 id=\"3-insertion-sort-삽입-정렬\" style=\"position:relative;\"><a href=\"#3-insertion-sort-%EC%82%BD%EC%9E%85-%EC%A0%95%EB%A0%AC\" aria-label=\"3 insertion sort 삽입 정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Insertion Sort (삽입 정렬)</h1>\n<p>간단하게 말해 배열의 앞부분을 정렬된 배열, 뒷 부분을 정렬되지 않은 배열로 구분한다. 그리고 정렬되지 않은 배열의 가장 앞에 수를 꺼내서 정렬된 배열의 적절한 위치로 삽입한다.</p>\n<h2 id=\"31-동작-과정\" style=\"position:relative;\"><a href=\"#31-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\" aria-label=\"31 동작 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1. 동작 과정</h2>\n<ol>\n<li>0 ~ 1번 인덱스 중 1번 인덱스 값이 들어갈 위치를 찾아 넣는다.</li>\n<li>0 ~ 2번 인덱스 중 2번 인덱스 값이 들어갈 위치를 찾아 넣는다.<br>\n...</li>\n<li>0 ~ n-1번 인덱스 중 n-1번 인덱스 값이 들어갈 위치를 찾아 넣는다.</li>\n</ol>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 485px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/613f10142617d0d176187dfbfc351b98/0d3a1/insertion_sort_image.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 101.71428571428571%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAIDBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAABAP/aAAwDAQACEAMQAAAB9TbPMelJEhSI/8QAGxAAAwACAwAAAAAAAAAAAAAAAAERAhASEyH/2gAIAQEAAQUC7Kz0uQso9NU4o//EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/ASP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAZEAACAwEAAAAAAAAAAAAAAAAAERAhMTL/2gAIAQEABj8CueRJTZh//8QAHhAAAgEDBQAAAAAAAAAAAAAAAAERIUFREDGxwdH/2gAIAQEAAT8hVCnL60nIc3ss4xgVVKuN1FRhsJI//9oADAMBAAIAAwAAABCAyIP/xAAYEQEAAwEAAAAAAAAAAAAAAAABABExEP/aAAgBAwEBPxBWhy6yUM//xAAYEQACAwAAAAAAAAAAAAAAAAAAEQEQMf/aAAgBAgEBPxBrbUH/xAAfEAEAAgICAgMAAAAAAAAAAAABABEhMUHhUXFhkaH/2gAIAQEAAT8QdKIKCFmagvk/Op8z66lhlt4+fXiZKcA3Kvbeow8gLGupkYNwMWWspStwGgOtq8e5/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"insertion sort image\" title=\"\" src=\"/TIL/static/613f10142617d0d176187dfbfc351b98/0d3a1/insertion_sort_image.jpg\" srcset=\"/TIL/static/613f10142617d0d176187dfbfc351b98/e52aa/insertion_sort_image.jpg 175w,\n/TIL/static/613f10142617d0d176187dfbfc351b98/70ebb/insertion_sort_image.jpg 350w,\n/TIL/static/613f10142617d0d176187dfbfc351b98/0d3a1/insertion_sort_image.jpg 485w\" sizes=\"(max-width: 485px) 100vw, 485px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<h2 id=\"32-복잡도\" style=\"position:relative;\"><a href=\"#32-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"32 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2. 복잡도</h2>\n<ul>\n<li><strong>공간복잡도 O(1)</strong><br>\n주어진 배열 내에서 스왑하며 연산이 이뤄지기 때문에 추가 메모리를 필요로 하지 않는다.</li>\n<li><strong>시간복잡도 O(n**2)</strong><br>\n비교 연산이 최대 (1 + 2 + 3 + .... + n-3 + n-2 + n-1)회 일어나고, n-1번의 스왑 연산이 일어난다.<br>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 608px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/640be/bubble_sort_time_complexity.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 20%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAEABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3QUH/8QAFhABAQEAAAAAAAAAAAAAAAAAABFB/9oACAEBAAEFAtR//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFRABAQAAAAAAAAAAAAAAAAAAARD/2gAIAQEABj8CL//EABkQAAIDAQAAAAAAAAAAAAAAAAABESFBcf/aAAgBAQABPyFrRkXp0z//2gAMAwEAAgADAAAAEHPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxAAAgIDAQAAAAAAAAAAAAAAAAERgSFBUWH/2gAIAQEAAT8QgV22NY5axeiz/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"bubble sort time complexity\" title=\"\" src=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/640be/bubble_sort_time_complexity.jpg\" srcset=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/e52aa/bubble_sort_time_complexity.jpg 175w,\n/TIL/static/6612efa9c4891b8a1e34a1d50906b391/70ebb/bubble_sort_time_complexity.jpg 350w,\n/TIL/static/6612efa9c4891b8a1e34a1d50906b391/640be/bubble_sort_time_complexity.jpg 608w\" sizes=\"(max-width: 608px) 100vw, 608px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span><br>\n(단, 정렬되어 있는 값의 경우 비교 연산만 n-1번 이루어져 O(n)의 시간복잡도를 가진다.)</li>\n</ul>\n<h2 id=\"33-python-구현\" style=\"position:relative;\"><a href=\"#33-python-%EA%B5%AC%ED%98%84\" aria-label=\"33 python 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.3. Python 구현</h2>\n<pre><code class=\"language-python\">def insertion_sort(nums):\n    N = len(nums)\n\n    # 1 ~ n-1 번 인덱스에 대해서 반복\n    for i in range(1, N):\n        cur_num = nums[i]\n        j = i - 1\n\n        # 왼쪽 배열에서 i번째 숫자가 들어갈 위치를 찾는다.\n        while j >= 0 and cur_num &#x3C; array[j]:\n            array[j + 1] = array[j] # 숫자를 하나씩 오른쪽으로 민다.\n            j = j - 1\n\n        array[j + 1] = cur_num  # i번째 숫자를 삽입\n\n    return nums\n</code></pre>\n<h1 id=\"4-shell-sort-셸-정렬\" style=\"position:relative;\"><a href=\"#4-shell-sort-%EC%85%B8-%EC%A0%95%EB%A0%AC\" aria-label=\"4 shell sort 셸 정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Shell Sort (셸 정렬)</h1>\n<p>삽입정렬을 보완하기 위한 알고리즘이다. 앞서 살펴본 것 처럼 쉘 알고리즘은 <strong>정렬이 잘 되어 있을수록 시간복잡도가 줄어든다.</strong> 비교연산을 해야할 횟수(거리)가 줄어들기 때문이다. 반대로 생각하면, <strong>정렬을 위해 비교해야할 거리가 클 수록 시간 복잡도가 늘어난다.</strong></p>\n<p>위와 같은 특징에서 착안해서, 쉘 정렬은 배열의 전체적인 정렬도를 점차 높이는 방법으로 삽입 정렬을 수행한다. gap만큼 떨어진 숫자들을 하나의 부분 배열로 간주해서 삽입 정렬을 수행하고, 이 gap을 점차 1까지 줄여나간다.</p>\n<h2 id=\"41-동작-과정\" style=\"position:relative;\"><a href=\"#41-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\" aria-label=\"41 동작 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.1. 동작 과정</h2>\n<ol>\n<li>gap의 초기 크기를 n // 2로 결정한다.</li>\n<li>gap ~ n-1번째 인덱스를 기준점으로 왼쪽 숫자들에 대해서 gap의 간격으로 부분배열을 만들고, 삽입정렬을 수행한다.</li>\n<li>gap의 크기를 2로 나눈다.</li>\n<li>gap의 크기가 1이 될 때까지 2 ~ 3의 과정을 반복한다.</li>\n</ol>\n<h2 id=\"42-복잡도\" style=\"position:relative;\"><a href=\"#42-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"42 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.2. 복잡도</h2>\n<ul>\n<li><strong>공간복잡도 O(1)</strong><br>\n주어진 배열 내에서 스왑하며 연산이 이뤄지기 때문에 추가 메모리를 필요로 하지 않는다.</li>\n<li><strong>시간복잡도 O(n**2)</strong><br>\n쉘 정렬과 동일하게 O(n**2)의 복잡도를 가진다.\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 608px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/640be/bubble_sort_time_complexity.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 20%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAEABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3QUH/8QAFhABAQEAAAAAAAAAAAAAAAAAABFB/9oACAEBAAEFAtR//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFRABAQAAAAAAAAAAAAAAAAAAARD/2gAIAQEABj8CL//EABkQAAIDAQAAAAAAAAAAAAAAAAABESFBcf/aAAgBAQABPyFrRkXp0z//2gAMAwEAAgADAAAAEHPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxAAAgIDAQAAAAAAAAAAAAAAAAERgSFBUWH/2gAIAQEAAT8QgV22NY5axeiz/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"bubble sort time complexity\" title=\"\" src=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/640be/bubble_sort_time_complexity.jpg\" srcset=\"/TIL/static/6612efa9c4891b8a1e34a1d50906b391/e52aa/bubble_sort_time_complexity.jpg 175w,\n/TIL/static/6612efa9c4891b8a1e34a1d50906b391/70ebb/bubble_sort_time_complexity.jpg 350w,\n/TIL/static/6612efa9c4891b8a1e34a1d50906b391/640be/bubble_sort_time_complexity.jpg 608w\" sizes=\"(max-width: 608px) 100vw, 608px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span><br>\n그러나 최선과 평균 시간 복잡도가 O(n*log n)이다.</li>\n</ul>\n<h2 id=\"43-python-구현\" style=\"position:relative;\"><a href=\"#43-python-%EA%B5%AC%ED%98%84\" aria-label=\"43 python 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.3. Python 구현</h2>\n<pre><code class=\"language-python\">def shell_sort(nums):\n    N = len(nums)\n\n    gap = N // 2    # 첫 gap은 배열 크기의 반으로 지정한다.\n    while gap > 0:  # gap이 1이 될 때까지 줄여나간다.\n\n        # gap의 크기만큼 간격을 띄고 shell 정렬을 수행한다.\n        for i in range(gap, N):\n            cur_num = nums[i]\n            j = i - gap\n\n            cur_num &#x3C; array[j]:\n            while j >= gap and cur_num &#x3C; nums[j]:\n                array[j] = array[j - gap]\n                j -= gap\n\n            array[j] = cur_num\n        gap //= 2   # gap은 2로 나눈 몫으로 줄여나간다\n</code></pre>\n<h1 id=\"5-heap-sort-힙-정렬\" style=\"position:relative;\"><a href=\"#5-heap-sort-%ED%9E%99-%EC%A0%95%EB%A0%AC\" aria-label=\"5 heap sort 힙 정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. Heap Sort (힙 정렬)</h1>\n<p><a href=\"https://github.com/Byongho96/TIL/blob/master/Data%20Structure/Heap.md\">자료구조 힙</a>을 이용한 정렬 방법이다.</p>\n<p>길이가 n인 heap 배열은 depth가 log n 이다.</p>\n<ul>\n<li>pop 연산 시, logN 번의 비교 및 치환이 일어난다.(Heapify)</li>\n<li>정렬을 위해서 N번의 pop 연산이 일어난다.</li>\n</ul>\n<p>따라서 힙을 이용한 연산의 시간 복잡도는 O(n * log n)dlek.</p>\n<h1 id=\"6-merge-sort-병합-정렬\" style=\"position:relative;\"><a href=\"#6-merge-sort-%EB%B3%91%ED%95%A9-%EC%A0%95%EB%A0%AC\" aria-label=\"6 merge sort 병합 정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. Merge Sort (병합 정렬)</h1>\n<p><strong>분할 정복법</strong> 중 하나의 큰 문제를 여러 개의 작은 문제로 쪼개서, 작은 문제를 해결한 결과를 모아서 큰 문제의 답을 얻는다. 분할 정복 특징 상, 재귀로 구현된다.</p>\n<h2 id=\"61-동작-과정\" style=\"position:relative;\"><a href=\"#61-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\" aria-label=\"61 동작 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6.1. 동작 과정</h2>\n<ol>\n<li>배열의 길이가 1이 될 때 까지, 반으로 쪼갠다.(분할)</li>\n<li>쪼개진 배열을 2개씩 비교 정렬하며 합친다.(병합)</li>\n</ol>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 632px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/327e829fdcf866ae04fa8b5dccfab88f/84f0d/merge_sort_image.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 101.14285714285714%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGQABAAIDAAAAAAAAAAAAAAAAAAECAwQF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAgH/2gAMAwEAAhADEAAAAezMkbIS46iOwA//xAAcEAACAgIDAAAAAAAAAAAAAAAAAQIREBIhIjH/2gAIAQEAAQUCZVC5z6T6kXsz/8QAFREBAQAAAAAAAAAAAAAAAAAAEEH/2gAIAQMBAT8BKf/EABURAQEAAAAAAAAAAAAAAAAAABBB/9oACAECAQE/ASH/xAAbEAACAgMBAAAAAAAAAAAAAAAAERAhASJRYf/aAAgBAQAGPwK0jVR7HB4Lj//EAB0QAAICAgMBAAAAAAAAAAAAAAERACExURBBYZH/2gAIAQEAAT8hU3DZQNuEAYjS70cw2T9gBsX4cOgA9qY6CvOP/9oADAMBAAIAAwAAABCLD7z/xAAYEQADAQEAAAAAAAAAAAAAAAAAAREQQf/aAAgBAwEBPxCFY+c//8QAGBEBAQADAAAAAAAAAAAAAAAAAQAQEUH/2gAIAQIBAT8Q3IR3j//EABoQAQEAAwEBAAAAAAAAAAAAAAERACExQRD/2gAIAQEAAT8QUbi6o24hFAODzBK0fcoRQXc1uJAFoineCXZ8cZ3RsVtzGmEKfH//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"merge sort image\" title=\"\" src=\"/TIL/static/327e829fdcf866ae04fa8b5dccfab88f/84f0d/merge_sort_image.jpg\" srcset=\"/TIL/static/327e829fdcf866ae04fa8b5dccfab88f/e52aa/merge_sort_image.jpg 175w,\n/TIL/static/327e829fdcf866ae04fa8b5dccfab88f/70ebb/merge_sort_image.jpg 350w,\n/TIL/static/327e829fdcf866ae04fa8b5dccfab88f/84f0d/merge_sort_image.jpg 632w\" sizes=\"(max-width: 632px) 100vw, 632px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<h2 id=\"62-복잡도\" style=\"position:relative;\"><a href=\"#62-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"62 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6.2. 복잡도</h2>\n<ul>\n<li><strong>공간복잡도 O(n)</strong><br>\n배열을 병합할 때, 병합 결과를 담을 배열이 필요하므로 공간 복잡도 는 O(n)이다.</li>\n<li><strong>시간복잡도 O(n*log n)</strong><br>\n크기가 n인 데이터를 절반 씩 분할 했을 경우, 병합하는 깊이는 log n이다. 각 depth에 대해 병합 시에는 모든 데이터에 대해서 한 번씩 비교연산이 일어난다. O(n * log n)</li>\n</ul>\n<h2 id=\"63-python-구현\" style=\"position:relative;\"><a href=\"#63-python-%EA%B5%AC%ED%98%84\" aria-label=\"63 python 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6.3. Python 구현</h2>\n<pre><code class=\"language-python\">def merge_sort(nums):\n    # 베이스 반환 조건: 1개 이하의 배열이 되면 반환한다.\n    if len(nums) &#x3C; 2:\n        return nums\n\n    # 배열을 반으로 나눠서, 왼쪽과 오른쪽 배열에 대해 각각 재귀호출 한다.\n    mid = len(nums) // 2\n    left_arr = merge_sort(nums[:mid])  # left_arr는 왼쪽 배열이 정렬된 값이다.\n    right_arr = merge_sort(nums[mid:])   # right_arr는 오른쪽 배열이 정렬된 값이다.\n\n    # left_arr와 right_arr는 각 정렬된 값이다.\n    # left_arr와 right_arr를 앞에서부터 서로 비교하며 merged_arr에 작은 값을 merged_arr에 채워 넣는다.\n    l = r = 0\n    merged_arr = []\n    while l &#x3C; len(left_arr) and r &#x3C; len(right_arr): # 양 배열 중 적어도 하나를 탐색 완료할 때까지\n        if left_arr[l] &#x3C; right_arr[h]:\n            merged_arr.append(left_arr[l])\n            l += 1\n        else:\n            merged_arr.append(right_arr[r])\n            r += 1\n    merged_arr += left_arr[l:]\n    merged_arr += right_arr[r:]\n\n    return merged_arr   # left_arr와 right_arr를 병합해서 정렬한 값 반환\n</code></pre>\n<h1 id=\"7-quick-sort-퀵-정렬\" style=\"position:relative;\"><a href=\"#7-quick-sort-%ED%80%B5-%EC%A0%95%EB%A0%AC\" aria-label=\"7 quick sort 퀵 정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7. Quick Sort (퀵 정렬)</h1>\n<p>병합 정렬과 비슷하게 문제를 분할하면서 이뤄진다. 단 다음과 같은 차이점이 있다.</p>\n<ol>\n<li>배열의 중간에 위치한 값 아닌 pivot값을 기준으로 분할한다. pivot 값을 기준으로 큰 숫자와 작은 숫자의 갯수가 동일할 수록 알고리즘이 효율적이다.</li>\n<li>배열을 <strong>분할 할 때, 비교연산</strong>이 일어난다.</li>\n</ol>\n<p>1번 기준에 따라 pivot값을 어떻게 선택하느냐에 따라서 시간 복잡도가 달라진다. 최대 O(n**2)까지 커질 수 있는 불안정한 정렬 알고리즘이다.</p>\n<h2 id=\"71-동작-과정\" style=\"position:relative;\"><a href=\"#71-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\" aria-label=\"71 동작 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7.1. 동작 과정</h2>\n<ol>\n<li>배열의 pivot을 설정한다.</li>\n<li>pivot과 나머지 숫자를 비교 연산하여, pivot보다 작은 숫자 배열과, 큰 숫자 배열을 얻는다.</li>\n<li>작은 숫자 배열과, 큰 숫자 배열에 대해서 (1 ~ 2)의 과정을 반복한다.</li>\n<li>배열의 길이가 1이하로 쪼개지면 그대로 다시 합친다.</li>\n</ol>\n<h2 id=\"72-복잡도\" style=\"position:relative;\"><a href=\"#72-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"72 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7.2. 복잡도</h2>\n<ul>\n<li>\n<p><strong>공간 복잡도</strong><br>\n인메모리 정렬 방식을 사용할 경우, O(log n)의 공간복잡도로 구현 가능하다. <del>뭔소린지 모르겠다</del></p>\n</li>\n<li>\n<p><strong>시간 복잡도</strong><br>\npivot값이 이상적으로 선택되었을 경우, 병합정렬과 마찬가지로 (log n)의 깊이의 대해서, 각각 n번의 비교 연산이 일어나므로 <strong>O(n*log n)의 복잡도</strong>를 가진다.</p>\n<p>그러나 최악의 경우 분할정복이 (n)의 깊이를 가지므로 <strong>O(n**2)의 복잡도</strong>를 가진다.</p>\n</li>\n</ul>\n<h2 id=\"73-python-구현\" style=\"position:relative;\"><a href=\"#73-python-%EA%B5%AC%ED%98%84\" aria-label=\"73 python 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7.3. Python 구현</h2>\n<pre><code class=\"language-python\"># 이 코드에서는 pivot을 병합 정렬과 동일하게 배열의 중간위치 값으로 설정한다.\ndef quick_sort(nums):\n    # 베이스 반환 조건: 1개 이하의 배열이 되면 반환한다.\n    if len(nums) &#x3C;= 2:\n        return nums\n\n    pivot = nums[len(nums) // 2]    # pivot 설정\n    lesser_arr, equal_arr, greater_arr = [], [], [] # 각각 pivot보다) 작은 숫자 배열, 동일한 숫자 배열, 큰 숫자 배열\n    for num in arr:\n        if num &#x3C; pivot:\n            lesser_arr.append(num)\n        elif num > pivot:\n            greater_arr.append(num)\n        else:\n            equal_arr.append(num)\n\n    # pivot보다 작은 숫자배열과, pivot보다 큰 숫자 배열을 quick_sort에 재귀호출 한다.\n    # 결과를 그대로 이어 붙여 반환한다.\n    return quick_sort(lesser_arr) + equal_arr + quick_sort(greater_arr)\n</code></pre>\n<h1 id=\"8-counting-sort-계수-정렬\" style=\"position:relative;\"><a href=\"#8-counting-sort-%EA%B3%84%EC%88%98-%EC%A0%95%EB%A0%AC\" aria-label=\"8 counting sort 계수 정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>8. Counting Sort (계수 정렬)</h1>\n<p>특정한 조건이 만족할 때, O(n + k)의 시간복잡도로 정렬할 수 있다. 이 때 k는 배열에 존재하는 숫자의 크기 범위이다. 즉 k가 데이터의 갯수 n보다 작으면, **O(n)**의 정렬이 가능하다.</p>\n<ul>\n<li>배열에 존재하는 모든 숫자가 0이상의 정수여야 한다.</li>\n<li>배열에 존재하는 숫자의 크기 범위(k)가 지나치게 커서는 안된다.</li>\n</ul>\n<h2 id=\"81-동작-과정\" style=\"position:relative;\"><a href=\"#81-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\" aria-label=\"81 동작 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>8.1. 동작 과정</h2>\n<ol>\n<li>배열의 숫자 범위(k)에 해당하는 <code>[0] * k</code>의 누적합 예비 배열을 만든다.</li>\n<li>배열을 1회 순회하며, 숫자를 인덱스로 하는 누적합 예비 배열의 값을 +1 한다.</li>\n<li>누적합 예비 배열을 누적합하여 누적합 배열을 만든다.</li>\n<li>누적합 배열을 1회 순회하며, 값만큼 인덱스를 출력한다.</li>\n</ol>\n<h2 id=\"82-복잡도\" style=\"position:relative;\"><a href=\"#82-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"82 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>8.2. 복잡도</h2>\n<ul>\n<li><strong>공간 복잡도 O(k)</strong><br>\n숫자 범위(k)에 해당하는 배열을 생성해야 한다.</li>\n<li><strong>시간 복잡도 O(n+k)</strong><br>\n배열을 1회 순회 O(n)하고, 누적합 배열을 1회 순회 O(k)한다.</li>\n</ul>\n<h2 id=\"83-python-구현\" style=\"position:relative;\"><a href=\"#83-python-%EA%B5%AC%ED%98%84\" aria-label=\"83 python 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>8.3. Python 구현</h2>\n<pre><code class=\"language-python\">def counting_sort(nums, K):\n    N = len(nums)\n\n    # 누적합 예비 배열을 생성한다.\n    count_sum = [0] * (K)\n    for i in range(0, N):\n        count_sum[nums[i - 1]] += 1\n\n    # 누적합 배열을 만든다. (인덱스에 해당하는 값이 들어가야할 마지막 인덱스 번호를 가리킨다.)\n    for i in range(1, K):\n        counts[i] += counts[i-1]\n\n    # 배열의 값을 인덱스로 하는 누적합 배열을 찹조한다. -> 해당 값이 들어가야할 마지막 인덱스 번호\n    # 결과 배열의 해당 인덱스에 숫자를 집어넣는다.\n    # 다음 값을 위해 해당 값을 인덱스로 하는 누적합 배열의 값을 -1 한다.\n    # 내가 그린 기린 그림은 잘 그린 기린 그림이고...\n    result = [0] * N\n    for num in nums:\n        idx = count_sum [num]\n        result[idx - 1] = num\n        count_sum[num] -= 1\n</code></pre>\n<h1 id=\"9-복잡도-비교\" style=\"position:relative;\"><a href=\"#9-%EB%B3%B5%EC%9E%A1%EB%8F%84-%EB%B9%84%EA%B5%90\" aria-label=\"9 복잡도 비교 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>9. 복잡도 비교</h1>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/72436f978a4796a5ec76606551c2baa1/fba02/sortings_complexity.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 65.71428571428571%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAQAF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAL/2gAMAwEAAhADEAAAAdpmRMf/xAAXEAADAQAAAAAAAAAAAAAAAAAAAREg/9oACAEBAAEFAiEWP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABcRAAMBAAAAAAAAAAAAAAAAAAABElH/2gAIAQIBAT8BlYSj/8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAHRAAAgEEAwAAAAAAAAAAAAAAAAERECExQVFhsf/aAAgBAQABPyFJQ7EONHQhYZPlP//aAAwDAQACAAMAAAAQ7/8A/8QAFhEAAwAAAAAAAAAAAAAAAAAAAAER/9oACAEDAQE/EKys/8QAFhEBAQEAAAAAAAAAAAAAAAAAAGEB/9oACAECAQE/EJk8f//EABsQAAIDAAMAAAAAAAAAAAAAAAABESExUXGh/9oACAEBAAE/ELckxI5XUOjiPEaVaG6XR//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"sortings complexity\" title=\"\" src=\"/TIL/static/72436f978a4796a5ec76606551c2baa1/29d31/sortings_complexity.jpg\" srcset=\"/TIL/static/72436f978a4796a5ec76606551c2baa1/e52aa/sortings_complexity.jpg 175w,\n/TIL/static/72436f978a4796a5ec76606551c2baa1/70ebb/sortings_complexity.jpg 350w,\n/TIL/static/72436f978a4796a5ec76606551c2baa1/29d31/sortings_complexity.jpg 700w,\n/TIL/static/72436f978a4796a5ec76606551c2baa1/fba02/sortings_complexity.jpg 935w\" sizes=\"(max-width: 700px) 100vw, 700px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/b5c0bd27b95b94aa6421c2b377adc475/7e509/Big_O_graph.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 61.142857142857146%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAAC20lEQVR42lXRT2iTdxzH8Uc2T4MdxYMHYbcdN6aCTpuk1f05iffB2G0IMqYLtQouT/M8T5609bQpwhw6ioeuQpthG23UJu2aDkfpVpY29ckfzb8+TQr50+dJnuZ53qNJV+bhw+fwgxd8fl+h3mjQqlap5vNUi0WaGxtYlQrb2Qz62ENKofuUViQSKxJjvw/w25/DtDY3sDbLWGW9081CGSyTtWQSYdtxqIVC5L69TPHGDWxVpakoFK9fxxRFHFnCCYi0FZGWLGIpgxBUYUgF+SYER7B//hIyd9GyhT1wcoLa1auYigxqgKrPx44i4wQC+6ETtfPuSEEc/xDObS+EL2DHPoD8j6Qyxf/ASar9/RiStA/+H+tG6bZ/GG5+Dw+/gAU3xD3Yz0/A61tomQJCw7apTUx0QFOWsWSZhiiCqr6JSUOd5pevIXoOO36a1qybnehZ6tMfQeoHUtkiQq5SIT86Sv3aNQxZxvT7Mfz+PVDBkYNd7PZ3ED4Pi2cg7saIuMmOn6Iy5aI1cwxyt7qT06US2Xv3qA4MYAUUaqKP9u7/KQGcwRGcEd/ePA9O3MXOrIfGjIvtiIt2zAMLZ7GjXVDbBbdMk/L4OJteL01Fpr47VxrugNy/CLOfYS+cofncRWOmh0akh52oB+Z7IdYH0U+xH5+C7J03r6x7r1ATJaxBFe54ccLnseZPU5/poRb2YDzpxX52DmKfwFwfzlwvzh8f4/x1nPbqETAG0dKl7lGqkyEK3/RjBH0w9hWtp32Yz1w0I70w54alk5D4ELT3IXcUtg6B8Q60DwJvYzYF4BLptI7QBFIPRkn6P2fzyXFy8+9RfHEUPXEYPfsupY2D5MoHyFQE1rcEEmWBFV1gqSjwoiDwdPUtfl0UWNUv8SqrI2wbBq9TSVaWH5FcD6Olp1h/FWItE+Kf9COW1iaZiv5EJD7KsjbNshZmSZvez2IiTOzvEPlKkpfrL/kX0or3SLDTFYoAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Big O graph\" title=\"\" src=\"/TIL/static/b5c0bd27b95b94aa6421c2b377adc475/8c557/Big_O_graph.png\" srcset=\"/TIL/static/b5c0bd27b95b94aa6421c2b377adc475/4edbd/Big_O_graph.png 175w,\n/TIL/static/b5c0bd27b95b94aa6421c2b377adc475/13ae7/Big_O_graph.png 350w,\n/TIL/static/b5c0bd27b95b94aa6421c2b377adc475/8c557/Big_O_graph.png 700w,\n/TIL/static/b5c0bd27b95b94aa6421c2b377adc475/7e509/Big_O_graph.png 745w\" sizes=\"(max-width: 700px) 100vw, 700px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-bubble-sort-%EA%B1%B0%ED%92%88-%EC%A0%95%EB%A0%AC\">1. Bubble Sort (거품 정렬)</a></p>\n<ul>\n<li><a href=\"#11-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">1.1. 동작 과정</a></li>\n<li><a href=\"#12-%EB%B3%B5%EC%9E%A1%EB%8F%84\">1.2. 복잡도</a></li>\n<li><a href=\"#13-python-%EA%B5%AC%ED%98%84\">1.3. Python 구현</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-selection-sort-%EC%84%A0%ED%83%9D-%EC%A0%95%EB%A0%AC\">2. Selection Sort (선택 정렬)</a></p>\n<ul>\n<li><a href=\"#21-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">2.1. 동작 과정</a></li>\n<li><a href=\"#22-%EB%B3%B5%EC%9E%A1%EB%8F%84\">2.2. 복잡도</a></li>\n<li><a href=\"#23-python-%EA%B5%AC%ED%98%84\">2.3. Python 구현</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-insertion-sort-%EC%82%BD%EC%9E%85-%EC%A0%95%EB%A0%AC\">3. Insertion Sort (삽입 정렬)</a></p>\n<ul>\n<li><a href=\"#31-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">3.1. 동작 과정</a></li>\n<li><a href=\"#32-%EB%B3%B5%EC%9E%A1%EB%8F%84\">3.2. 복잡도</a></li>\n<li><a href=\"#33-python-%EA%B5%AC%ED%98%84\">3.3. Python 구현</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#4-shell-sort-%EC%85%B8-%EC%A0%95%EB%A0%AC\">4. Shell Sort (셸 정렬)</a></p>\n<ul>\n<li><a href=\"#41-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">4.1. 동작 과정</a></li>\n<li><a href=\"#42-%EB%B3%B5%EC%9E%A1%EB%8F%84\">4.2. 복잡도</a></li>\n<li><a href=\"#43-python-%EA%B5%AC%ED%98%84\">4.3. Python 구현</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#5-heap-sort-%ED%9E%99-%EC%A0%95%EB%A0%AC\">5. Heap Sort (힙 정렬)</a></p>\n</li>\n<li>\n<p><a href=\"#6-merge-sort-%EB%B3%91%ED%95%A9-%EC%A0%95%EB%A0%AC\">6. Merge Sort (병합 정렬)</a></p>\n<ul>\n<li><a href=\"#61-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">6.1. 동작 과정</a></li>\n<li><a href=\"#62-%EB%B3%B5%EC%9E%A1%EB%8F%84\">6.2. 복잡도</a></li>\n<li><a href=\"#63-python-%EA%B5%AC%ED%98%84\">6.3. Python 구현</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#7-quick-sort-%ED%80%B5-%EC%A0%95%EB%A0%AC\">7. Quick Sort (퀵 정렬)</a></p>\n<ul>\n<li><a href=\"#71-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">7.1. 동작 과정</a></li>\n<li><a href=\"#72-%EB%B3%B5%EC%9E%A1%EB%8F%84\">7.2. 복잡도</a></li>\n<li><a href=\"#73-python-%EA%B5%AC%ED%98%84\">7.3. Python 구현</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#8-counting-sort-%EA%B3%84%EC%88%98-%EC%A0%95%EB%A0%AC\">8. Counting Sort (계수 정렬)</a></p>\n<ul>\n<li><a href=\"#81-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">8.1. 동작 과정</a></li>\n<li><a href=\"#82-%EB%B3%B5%EC%9E%A1%EB%8F%84\">8.2. 복잡도</a></li>\n<li><a href=\"#83-python-%EA%B5%AC%ED%98%84\">8.3. Python 구현</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#9-%EB%B3%B5%EC%9E%A1%EB%8F%84-%EB%B9%84%EA%B5%90\">9. 복잡도 비교</a></p>\n</li>\n</ul>","frontmatter":{"title":"정렬(Sorting) 알고리즘 정리","createdAt":"2023-05-02","updatedAt":"2023-05-03","tags":null,"description":null,"reference":null}},"allMarkdownRemark":{"nodes":[{"id":"45697052-8508-5538-b08e-3d2066d4d6c2","parent":{"id":"bb894824-c4ac-58f0-ad91-96e82bbe68dd","name":"DFS","relativePath":"CS/Algorithm/DFS.md"},"frontmatter":{"title":"깊이 우선 탐색(Depth-First Search) 알고리즘","createdAt":"2023-03-14","updatedAt":"2023-04-17"},"excerpt":"1. 개요 상태공간이나 그래프를 출발점에서 시작하여 모든 리프노드까지 순서대로 탐색하는 완전탐색 기반의 알고리즘이다. 1.…"},{"id":"415348c2-e152-5eea-ac4b-4da9ac52ef9a","parent":{"id":"0f2cd9fd-d664-5260-b1b4-c7120379a272","name":"BFS","relativePath":"CS/Algorithm/BFS.md"},"frontmatter":{"title":"너비 우선 탐색(Breadth-First Search) 알고리즘","createdAt":"2023-03-05","updatedAt":"2023-04-17"},"excerpt":"1. 개요 상태공간이나 그래프를 출발점으로부터 가까운 순으로 탐색해가는 완전탐색 기반의 알고리즘이다. 1.…"},{"id":"4ee23bf3-1c05-5399-ba0a-307c82321b8e","parent":{"id":"918cda61-2019-5511-a096-165d209acc1e","name":"Dijkstra","relativePath":"CS/Algorithm/Dijkstra.md"},"frontmatter":{"title":"다익스트라(Dijkstra) 알고리즘","createdAt":"2023-02-27","updatedAt":"2023-04-17"},"excerpt":"1. 개요 음의 가중치가 없는 그래프의 한 노드에서 다른 모드 노드까지의 최단거리를 각각 구하는 알고리즘. 대표적으로 사용되는 그리디 알고리즘이다.…"},{"id":"022dd3ff-bd38-532e-b9dc-e650aa49cfcd","parent":{"id":"255d5c3b-5673-54be-9a6b-0f9e762a66f0","name":"DP","relativePath":"CS/Algorithm/DP.md"},"frontmatter":{"title":"동적 계획법(Dynamic Programming) 알고리즘","createdAt":"2023-03-27","updatedAt":"2023-04-03"},"excerpt":"…"},{"id":"002a4016-b02c-553f-925e-60631f5ea662","parent":{"id":"c863c1e2-dd6a-53f6-8345-ec42e67f8f96","name":"Backtracking","relativePath":"CS/Algorithm/Backtracking.md"},"frontmatter":{"title":"백트래킹(Backtracking) 알고리즘","createdAt":"2022-08-23","updatedAt":"2023-04-17"},"excerpt":"1. 개요 상태공간이나 그래프의 노드를 모두 탐색하는 완전탐색 기반의 알고리즘이다. 다만, 가지 치기를 통해 탐색할 필요성이 없는 노드(상태)들을 탐색 대상에서 제외함으로써 효율을 높인다.…"},{"id":"46f81dd1-03c7-5b88-8f92-60a991ef38f0","parent":{"id":"56e87fde-1078-5eb0-9195-7bc58a6b4213","name":"BinarySearch","relativePath":"CS/Algorithm/BinarySearch.md"},"frontmatter":{"title":"이진탐색(Binary Search) 알고리즘","createdAt":"2023-04-11","updatedAt":"2023-04-11"},"excerpt":"1. 개요 정렬된 데이터에서 검색 범위를 줄여 나가면서 목적 값을 찾는 알고리즘이다. 데이터가 정렬되어 있을 경우, 데이터를 크기가 같은 두 부분으로 나누고 유효한 데이터집합을 선 1.…"},{"id":"47f2e077-42da-5fa8-a10c-8f6d807ef529","parent":{"id":"d8ebbf19-8fe5-5e82-96cc-a3dff93b3979","name":"Sorting","relativePath":"CS/Algorithm/Sorting.md"},"frontmatter":{"title":"정렬(Sorting) 알고리즘 정리","createdAt":"2023-05-02","updatedAt":"2023-05-03"},"excerpt":"면접에서 탈탈 털린 후 작성한 정렬 관련 알고리즘을 총정리 1. Bubble Sort (거품 정렬) 1.1. 동작 과정 1.2. 복잡도 1.3. Python 구현 2. Selection Sort (선택 정렬) 2.1. 동작 과정 2.2. 복잡도 2.…"},{"id":"160ea840-e0d0-5cca-a2dc-02a3cedafdfb","parent":{"id":"eade735b-b1e5-5b43-bea9-8492dd37ae6d","name":"MST","relativePath":"CS/Algorithm/MST.md"},"frontmatter":{"title":"최소 신장 트리(Minimum Spaaning Tree) 알고리즘","createdAt":"2023-04-17","updatedAt":"2023-04-17"},"excerpt":"1. 개요 신장 트리(Spanning Tree)는 그래프 내의 모든 노드를 포함하는 트리를 의미하며, **최소 신장 트리(Minimum Spanning Tree)**란 간선의 가중치 합이 최소가 되는 신장 트리를 말한다. 최소 신장 트리는 Greedy…"}]}},"pageContext":{"pagePath":"posts/CS/Algorithm/Sorting.md","regex":"/^(?!.*README).*CS\\/Algorithm.*$/","relativeDirectory":"Algorithm","id":"47f2e077-42da-5fa8-a10c-8f6d807ef529","parent":{"id":"d8ebbf19-8fe5-5e82-96cc-a3dff93b3979","name":"Sorting","relativePath":"CS/Algorithm/Sorting.md"}}},"staticQueryHashes":["3300660363","3571427910"],"slicesMap":{}}