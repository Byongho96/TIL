{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/Tools/Docker.md/","result":{"data":{"markdownRemark":{"id":"8254ebd4-de42-51b7-95fc-3a27f3cbf722","html":"<h1>Docker <!-- omit from toc --></h1>\n<h2>Index <!-- omit from toc --></h2>\n<ul>\n<li><a href=\"#0-docker\">0. Docker</a></li>\n<li><a href=\"#1-docker-image\">1. Docker Image</a>\n<ul>\n<li><a href=\"#11-%EA%B0%9C%EC%9A%94\">1.1. 개요</a></li>\n<li><a href=\"#12-dockerfile\">1.2. Dockerfile</a></li>\n<li><a href=\"#13-%EB%AA%85%EB%A0%B9%EC%96%B4\">1.3. 명령어</a></li>\n</ul>\n</li>\n<li><a href=\"#2-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88\">2. 컨테이너</a>\n<ul>\n<li><a href=\"#21-%EA%B0%9C%EC%9A%94\">2.1. 개요</a></li>\n<li><a href=\"#22-%EB%AA%85%EB%A0%B9%EC%96%B4\">2.2. 명령어</a></li>\n</ul>\n</li>\n<li><a href=\"#3-dockerhub\">3. DockerHub</a>\n<ul>\n<li><a href=\"#31-%EA%B0%9C%EC%9A%94\">3.1. 개요</a></li>\n<li><a href=\"#32-%EB%AA%85%EB%A0%B9%EC%96%B4\">3.2. 명령어</a></li>\n</ul>\n</li>\n<li><a href=\"#4-volume\">4. Volume</a>\n<ul>\n<li><a href=\"#41-%EA%B0%9C%EC%9A%94\">4.1. 개요</a></li>\n<li><a href=\"#42-%EB%AA%85%EB%A0%B9%EC%96%B4\">4.2. 명령어</a></li>\n</ul>\n</li>\n<li><a href=\"#5-docker-compose\">5. Docker Compose</a>\n<ul>\n<li><a href=\"#51-%EA%B0%9C%EC%9A%94\">5.1. 개요</a></li>\n<li><a href=\"#52-yaml-%ED%8C%8C%EC%9D%BC\">5.2. YAML 파일</a></li>\n<li><a href=\"#53-%EB%AA%85%EB%A0%B9%EC%96%B4\">5.3. 명령어</a></li>\n</ul>\n</li>\n</ul>\n<h1>0. Docker</h1>\n<p>Docker는 어플리케이션 소프트웨어를 컨테이너라 부르는 독립된 환경에서 실행시킬 수 있도록 한다. 컨테이너 내부에는 운영체제를 제외하고, 어플리케이션을 구동하기 위한 모든 정보를 담고 있다.</p>\n<p>Docker를 이용하면 환경에 구애받지 않고, 정형화된 방식으로 어플리케이션 배포를 진행할 수 있다. 또한 가상환경과 다르게 여러개에 컨테이너가 하나의 운영체제의 자원을 공유해서 사용할 수 있기 때문에, 보다 효율적으로 컴퓨터 자원을 사용할 수 있다.</p>\n<h1>1. Docker Image</h1>\n<h2>1.1. 개요</h2>\n<p>도커 이미지는 어플리케이션을 실행하기 위한 코드, 라이브러리, 런타임 환경 등의 모든 정보에 더해, 컨테이너를 실행시켰을 때 수행할 명령어 정보도 담고 있다.</p>\n<p>다르게 설명하자면 도커 이미지는 실행하고자 하는 어플리케이션 프로젝트의 특정 시점을 담아 파일화 한것이며, 해당 이미지를 컨테이너로 실행시킴으로써 동일한 형태의 프로젝트를 여러 개 실행시킬 수 있다.</p>\n<p>도커 이미지는 DockeFile을 빌드함으로써 생성할 수 있다.</p>\n<h2>1.2. Dockerfile</h2>\n<p>도커 파일은 Docker Image를 만드는 명령문을 가지는 문서이다. 모든 도커 파일은 base 이미지를 바탕으로 생성되며, 이미 생성된 이미지를 확장하여 사용할 수도 있다.</p>\n<pre><code class=\"language-c\">// base 이미지 지정\r\nFROM &#x3C;이미지>:&#x3C;태그>\r\n\r\n// 컨테이너 내부 작업 디렉토리 지정\r\n// 이후 명령문들의 기준\r\nWORKDIR &#x3C;내부 디렉토리>\r\n\r\n// shell 커맨드\r\nRUN [\"&#x3C;커맨드>\", \"&#x3C;파라미터1>\", \"&#x3C;파라미터2>\"]\r\nRUN &#x3C;전체 커맨드>\r\n\r\n// 파일 및 폴더 복사\r\nCOPY &#x3C;src> &#x3C;dest>\r\n\r\n// 빌드 및 컨테이너 동작 시 유효한 환경변수 지정\r\nENV &#x3C;키> &#x3C;값>\r\nENV &#x3C;키>=&#x3C;값>\r\n\r\n// docker build 커맨드에서 --build-arg 옵션을 통해 넘길 수 있는 인자를 정의\r\nARG &#x3C;이름>\r\nARG &#x3C;이름>=&#x3C;기본값>\r\n\r\n// 컨테이너로 들어오는 트래픽을 리스닝할 포트 지정\r\n// 프로토콜 TCP(default) / UDP\r\nEXPOSE &#x3C;포트>\r\nEXPOSE &#x3C;포트>/&#x3C;프로토콜>\r\n\r\n// 컨테이너를 실행시킬 때 default로 실행시킬 shell 커맨드\r\n// docker run과 함께 커맨드 인자를 입력하면, 실행되지 않음\r\nCMD [\"&#x3C;커맨드>\",\"&#x3C;파라미터1>\",\"&#x3C;파라미터2>\"]\r\nCMD &#x3C;전체 커맨드>\r\n\r\n// 컨테이너를 실행시킬 때 항상 실행되어야 하는 shell 커맨드\r\nENTRYPOINT [\"&#x3C;커맨드>\", \"&#x3C;파라미터1>\", \"&#x3C;파라미터2>\"]\r\nENTRYPOINT &#x3C;전체 커맨드>\r\n\r\n// CMD와 ENTRYPOINT 혼합\r\n// docker run docker_image -> index.js 실행\r\n// docker run docker_image main.js -> main.js 실행\r\nENTRYPOINT [\"node\"]\r\nCMD [\"index.js\"]\n</code></pre>\n<h2>1.3. 명령어</h2>\n<table>\n<thead>\n<tr>\n<th>명령어</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>docker build -t [이미지명] [이미지 경로]</td>\n<td>Dockerfile로 이미지 빌드</td>\n</tr>\n<tr>\n<td>docker image inspect [이미지명]</td>\n<td>Docker이미지 상세 정보 조회</td>\n</tr>\n<tr>\n<td>docker image ls [옵션]</td>\n<td>Docker 이미지 목록 출력</td>\n</tr>\n<tr>\n<td>docker image pull [이미지명]</td>\n<td>Docker 이미지 다운로드</td>\n</tr>\n<tr>\n<td>docker image push [사용자명/이미지명]</td>\n<td>Docker 이미지 푸시</td>\n</tr>\n<tr>\n<td>docker image rm [이미지명]</td>\n<td>Docker 이미지 삭제</td>\n</tr>\n<tr>\n<td>docker image prune [옵션]</td>\n<td>사용하지 않는 docker 이미지 삭제</td>\n</tr>\n</tbody>\n</table>\n<h1>2. 컨테이너</h1>\n<h2>2.1. 개요</h2>\n<p>도커 컨테이너는 하나의 독립적인 어플리케이션 구동 환경이다. 하나의 이미지를 통해 여러 개의 컨테이너를 실행시킬 수 있다.</p>\n<h2>2.2. 명령어</h2>\n<table>\n<thead>\n<tr>\n<th>명령어</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>docker run [옵션] [이미지명]</td>\n<td>Docker 임지로 컨테이너 실행</td>\n</tr>\n<tr>\n<td>docker ps</td>\n<td>실행중인 Docker 컨테이너 목록 출력</td>\n</tr>\n<tr>\n<td>docker ps -a</td>\n<td>모든 Docker 컨테이너 목록 출력</td>\n</tr>\n<tr>\n<td>docker start [컨테이너명/ID]</td>\n<td>Docker 컨테이너 실행</td>\n</tr>\n<tr>\n<td>docker stop [컨테이너명/ID]</td>\n<td>Docker 컨테이너 멈춤</td>\n</tr>\n<tr>\n<td>docker restart [컨테이너명/ID]</td>\n<td>Docker 컨테이너 재시작</td>\n</tr>\n<tr>\n<td>docker attach [컨테이너명/ID]</td>\n<td>Docker 컨테이너 접속</td>\n</tr>\n<tr>\n<td>docker exec -it [컨테이너명/ID] /bin/bash</td>\n<td>bash 언어를 사용하여 Docker 컨테이너 접속</td>\n</tr>\n<tr>\n<td>docker image pull [이미지명]</td>\n<td>Docker 이미지 다운로드</td>\n</tr>\n<tr>\n<td>docker image push [사용자명/이미지명]</td>\n<td>Docker 이미지 푸시</td>\n</tr>\n<tr>\n<td>docker rm [컨테이너명/ID]</td>\n<td>Docker 컨테이너 삭제</td>\n</tr>\n<tr>\n<td>docker prune [컨테이너명/ID]</td>\n<td>사용되지 않는 Docker 컨테이너 삭제</td>\n</tr>\n<tr>\n<td>docker logs [컨테이너명/ID]</td>\n<td>실행중인 Docker 로그 기록 조회</td>\n</tr>\n<tr>\n<td>docker logs -f [컨테이너명/ID]</td>\n<td>Docker 로그 기록 강제 조회</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>docker run 옵션\n<ul>\n<li><strong>-i, --interactive</strong><br>\n표준 입력(stdin)을 활성화</li>\n<li><strong>--name</strong><br>\n컨테이너 이름 설정</li>\n</ul>\n<ul>\n<li><strong>-d, --detach</strong><br>\nDetached 모드. 컨테이너를 백그라운드로 실행</li>\n<li><strong>-p, --publish</strong><br>\n호스트와 컨테이너의 포트를 연결\r\n[호스트 포트]:[컨테이너 포트]</li>\n<li><strong>-v, --volume</strong><br>\n컨테이너 마운트 설정\r\n[호스트 경로/볼륨]:[컨테이너 경로]</li>\n<li><strong>-u, --user</strong><br>\n컨테이너의 리눅스 사용자 계정 설정</li>\n<li><strong>-e, --env</strong><br>\n컨테이너 내 환경 변수를 설정</li>\n<li><strong>--restart</strong><br>\n프로세스 종료시 재시작 정책 설정</li>\n</ul>\n</li>\n</ul>\n<h1>3. DockerHub</h1>\n<h2>3.1. 개요</h2>\n<p>대표적인 도커 이미지 서버로써 도커 이미지를 서버에 저장하고, 필요 시에 다운받아 사용할 수 있따.</p>\n<h2>3.2. 명령어</h2>\n<table>\n<thead>\n<tr>\n<th>명령어</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>docker login -u [ID]</td>\n<td>DockerHub 로그인</td>\n</tr>\n<tr>\n<td>docker search [이미지명]</td>\n<td>DockerHub에서 이미지 검색</td>\n</tr>\n<tr>\n<td>docker push [도커 허브 ID/이미지 명]:[태그]</td>\n<td>DockerHub에 이미지 업로드</td>\n</tr>\n<tr>\n<td>docker pull [이미지명]</td>\n<td>DockerHub에서 이미지 다운로드</td>\n</tr>\n<tr>\n<td>docker loguout</td>\n<td>DockerHub 로그아웃</td>\n</tr>\n</tbody>\n</table>\n<h1>4. Volume</h1>\n<h2>4.1. 개요</h2>\n<p>바인드 마운트와 도커 볼륨은 거의 유사하다. 두 방식 모드 호스트의 경로(디렉토리)를 도커 컨테이너 내부에서 공유해서 사용할 수 있다는 공통점이 있따. 다만 바인드 마운트는 호스트의 특정 경로를 설정해서 매핑해줄수 있는 한편, 볼륨은 지정된 경로 <code>/var/lib/docker/volumes/[볼륨이름]/_data</code> 에만 매핑이 가능하다. 볼륨은 장점은 도커 명령어를 통해 더 간편하게 관리가 가능하다.</p>\n<h2>4.2. 명령어</h2>\n<table>\n<thead>\n<tr>\n<th>명령어</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>docker volume create --name [볼륨 이름]</td>\n<td>도커 볼륨 생성</td>\n</tr>\n<tr>\n<td>docker volume ls</td>\n<td>도커 볼륨 조회</td>\n</tr>\n<tr>\n<td>docker volume inspect [볼륨 이름]</td>\n<td>도커 볼륨 정보 조회</td>\n</tr>\n<tr>\n<td>docker run -v [볼륨이름:컨테이너 경로] ...</td>\n<td>도커 볼륨 마운트</td>\n</tr>\n<tr>\n<td>docker container inspect [컨테이너 이름]</td>\n<td>도커 컨테이너의 볼륨 정보 조회</td>\n</tr>\n<tr>\n<td>ddocker volume rm [볼륨 이름]</td>\n<td>도커 볼륨 삭제</td>\n</tr>\n<tr>\n<td>docker volume prune</td>\n<td>사용하지 않는 도커 볼륨 삭제</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p><strong>도커 볼륨 정보 조회 결과</strong></p>\n<pre><code class=\"language-bash\">[\r\n\t{\r\n\t\t\"CreatedAt\": \"\",\r\n\t\t\"Driver\": \"\",\r\n\t\t\"Labels\": {},\r\n\t\t\"Mountpoint\": [볼륨의 호스트 소스 경로],\r\n\t\t\"Name\": [볼륨 이름],\r\n\t\t\"Options\": {},\r\n\t\t\"Scope\": \"\",\r\n\t}\r\n]\n</code></pre>\n</li>\n<li>\n<p><strong>도커 컨테이너의 볼륨 정보 조회 결과</strong></p>\n<pre><code class=\"language-bash\">\"Mounts\": [\r\n\t{\r\n\t\t\"Type\": \"volume\",\r\n\t\t\"Name\": [볼륨 이름],\r\n\t\t\"Source\": [볼륨 호스트 경로],\r\n\t\t\"Destination\": [볼륨 컨테이너 마운트 경로],\r\n\t\t...\r\n\t},\r\n  {\r\n    \"Type\": \"bind\",\r\n    \"Source\": [호스트 경로],\r\n    \"Destination\": [컨테이너 내부 경로],\r\n    ...\r\n  }\r\n]\n</code></pre>\n</li>\n</ul>\n<h1>5. Docker Compose</h1>\n<h2>5.1. 개요</h2>\n<p>Docker Compose는 여러 개의 도커 컨테이너를 관리할 수 있는 명령어를 제공한다.\r\nYAML 파일을 작성함으로써 여러 개의 도커 컨테이너를 묶고, 컨테이너 간의 관계를 정의할 수 있고, Docker Compose는 이 yaml 파일을 인자로 받는 명령어를 제공한다.</p>\n<h2>5.2. YAML 파일</h2>\n<pre><code class=\"language-yaml\"># 사용하는 도커 버전에 따라 yaml 파일 포맷의 버전을 설정한다.\r\nversion: '3.2'\r\n\r\n# 어플리 케이션에 사용할 service 목록을 정의한다\r\nservices:\r\n  # 기본 컨테이너 이름 (container_name 옵션이 없을 경우)\r\n  back:\r\n    # 의존 관계 설정, 컨테이너 이름\r\n    depends_on:\r\n      - mysql\r\n\r\n    # 빌드 옵션\r\n    build:\r\n      context: . # 빌드할 파일들이 존재하는 경로를 지정\r\n      dockerfile: ./dir # dockerfile이 여러개거나 context의 위치와 다를 경우\r\n\r\n    # 컨테이너를 실행할 이미지 이름 설정\r\n    # 빌드 옵션이 있을 경우, 빌드한 결과 이미지 이름으로 사용\r\n    image: imfine-back\r\n\r\n    # 컨테이너 이름 지정\r\n    container_name: imfine-back\r\n\r\n    # 포트 매핑\r\n    ports:\r\n      - 8000:8000\r\n\r\n    # 볼륨 마운팅\r\n    volumes:\r\n      - /etc/localtime:/etc/localtime\r\n\r\n    # 환경변수 설정\r\n    environment:\r\n      - WORDPRESS_DB_HOST:db:3306\r\n      - WORDPRESS_DB_NAME:db:word\r\n      - WORDPRESS_DB_USER:word_user\r\n      - WORDPRESS_DB_PASSWORD=123456\r\n\r\n  mysql:\r\n    image: mysql:5.7\r\n    volumes:\r\n      - ./db_data:/var/lib/mysql\r\n    environment:\r\n      - MYSQL_ROOT_PASSWROD=123456\r\n      - MYSQL_DATABASE=word\r\n      - MYSQL_USER=word_user\r\n      - MYSQL_PASSWORD=123456\n</code></pre>\n<h2>5.3. 명령어</h2>\n<p>docker-compose 명령어는 참조할 수 있는 docker-compose.yaml 파일이 존재해야 한다. 특정 yaml파일에 대한 결과를 보고 싶으면 인자로 넘겨준다.</p>\n<table>\n<thead>\n<tr>\n<th>명령어</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>docker-compose build</td>\n<td>docker-compose 파일에 정의된 이미지를 빌드</td>\n</tr>\n<tr>\n<td>docker-compose up</td>\n<td>docker-compose 파일에 정의된 서비스를 실행</td>\n</tr>\n<tr>\n<td>docker-compose down</td>\n<td>docker-compose 파일에 정의된 서비스를 종료 (컨테이너 제거)</td>\n</tr>\n<tr>\n<td>docker-compose down --rmi</td>\n<td>docker-compose 파일에 정의된 서비스를 종료하고 이미지까지 제거</td>\n</tr>\n<tr>\n<td>docker-compose start</td>\n<td>docker-compose 파일에 정의된 서비스를 시작 (컨테이너 시작)</td>\n</tr>\n<tr>\n<td>docker-compose stop</td>\n<td>docker-compose 파일에 정의된 서비스를 정지 (컨테이너 정지)</td>\n</tr>\n<tr>\n<td>docker-compose restart</td>\n<td>docker-compose 파일에 정의된 서비스를 재시작 (컨테이너 재시작)</td>\n</tr>\n<tr>\n<td>docker-compose ps</td>\n<td>docker-compose 파일에 정의된 실행중인 서비스 상태 확인 (컨테이너 목록)</td>\n</tr>\n<tr>\n<td>docker-compose ps -a</td>\n<td>docker-compose 파일에 정의된 모든 서비스 상태 확인 (컨테이너 목록)</td>\n</tr>\n<tr>\n<td>docker-compose logs</td>\n<td>docker-compose 파일에 정의된 서비스들의 로그를 확인</td>\n</tr>\n</tbody>\n</table>\n<p><strong>docker-compose ps 출력 예시</strong></p>\n<pre><code class=\"language-bash\">\r\ndocker compose ps\r\nNAME            IMAGE     COMMAND           SERVICE    CREATED         STATUS          PORTS\r\nexample-foo-1   alpine    \"/entrypoint.…\"   foo        4 seconds ago   Up 2 seconds    0.0.0.0:8080->80/tcp\r\n\r\n\r\ndocker compose ps --all\r\nNAME            IMAGE     COMMAND           SERVICE    CREATED         STATUS          PORTS\r\nexample-foo-1   alpine    \"/entrypoint.…\"   foo        4 seconds ago   Up 2 seconds    0.0.0.0:8080->80/tcp\r\nexample-bar-1   alpine    \"/entrypoint.…\"   bar        4 seconds ago   exited (0)\n</code></pre>"}},"pageContext":{"pagePath":"posts/Tools/Docker.md","id":"8254ebd4-de42-51b7-95fc-3a27f3cbf722","parent":{"id":"1ec4b023-8a4f-524b-b3a4-3aa40c039b98","name":"Docker","relativePath":"Tools/Docker.md"}}},"staticQueryHashes":["1274812890","3935499650","82772122"],"slicesMap":{}}