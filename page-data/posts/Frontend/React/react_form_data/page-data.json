{"componentChunkName":"component---src-templates-post-index-tsx","path":"/posts/Frontend/React/react_form_data/","result":{"data":{"markdownRemark":{"id":"c919c895-9bcb-5e95-83ac-31a2a09d0a7c","html":"<h1 id=\"1-usestate란-무엇인가\" style=\"position:relative;\"><a href=\"#1-usestate%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" aria-label=\"1 usestate란 무엇인가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. useState란 무엇인가</h1>\n<p>리액트의 useState는 대표적으로 2가지 기능을 제공한다. <mark>1. 컴포넌트가 리렌더링 되더라도 값을 유지하고</mark>, <mark>2. 값이 업데이트 되면 컴포넌트를 리렌더링한다</mark>. 프론트의 데이터 변화는 대부분 화면 업데이트를 요구하기 때문에, useState는 가장 유용한 리액트 훅이 되었다. 하지만 같은 이유로 가장 <strong>남용되는 훅</strong>이기도 하다.</p>\n<p>useState 두번째 기능, 컴포넌트를 리렌더링하는 것은 결국 자원 소모를 말한다. 따라서 useState 불필요하게 사용하지 않도록 주의할 필요가 있다. useRef는 useState의 가장 대표적인 대체재이다. <mark>useRef로 생성된 객체의 current 속성은 컴포넌트가 리렌더링 되어도 값을 유지하고, 값이 업데이트 되어도 컴포넌트를 리렌더링 하지 않는다.</mark> 즉 useState의 첫번째 기능만을 가지는 셈이다.</p>\n<p>아래 예시코드를 통해 useState와 useRef의 쓰임새를 더 명확히 구분할 수 있다. <code>count</code>는 현재 카운트를 화면에 보여준다. 따라서 화면 렌더링과 관련된 변수이기 때문에 useState로 선언해야 한다. 반면 <code>isStop</code>은 화면과 관계없이 내부 로직에서 쓰이는 변수이면서, 컴포넌트가 리렌더링되더라도 값이 초기화되서는 안된다. 따라서 useRef로 선언해야한다.</p>\n<pre><code class=\"language-javascript\">import { useState, useRef, useEffect, useCallback } from 'react'\n\nexport default function Component() {\n  const [count, setCount] = useState(1) // 화면에 보여지는 값\n  const isStop = useRef(false) // 컴포넌트 내부 로직에서 쓰이는 값\n\n  // 1초마다 count의 값을 1씩 증가하는 interval 실행\n  useEffect(() => {\n    setInterval(() => {\n      if (isStop.current) return // 단, isStop이 가리키는 변수가 true이면 증가시키지 않음\n      setCounter((cnt) => cnt + 1)\n    }, 1000)\n  }, [])\n\n  // 클릭할 때마다 isStop이 가리키는 변수를 토글\n  const handleClick = useCallback(() => {\n    isStop.current = !isStop.current\n  }, [])\n\n  return (\n    &#x3C;div>\n      &#x3C;p>{count}&#x3C;/p>\n      &#x3C;button onClick={handleClick}>카운터 토글&#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p><img src=\"/TIL/b6c8e8d9e460140fba504bb11fe951d5/counter-example.gif\" alt=\"카운터 예시코드 화면\"></p>\n<h1 id=\"2-usestate-양방향-바인딩\" style=\"position:relative;\"><a href=\"#2-usestate-%EC%96%91%EB%B0%A9%ED%96%A5-%EB%B0%94%EC%9D%B8%EB%94%A9\" aria-label=\"2 usestate 양방향 바인딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. useState 양방향 바인딩</h1>\n<p>useState가 자주 쓰이지만 useRef로 대체하기 어려운 상황도 있다. 바로 <code>&#x3C;input></code>의 값을 양방향 바인딩할 때이다. 리액트로 처음 배우면, 보통 아래와 같이 <code>&#x3C;input</code>>의 값을 useState로 선언하고 onChange로 바인딩한다. 이 방법이 잘못되었다는 말은 아니다. 실제 <a href=\"https://react.dev/learn/reacting-to-input-with-state#step-5-connect-the-event-handlers-to-set-state\">리액트 공식문서</a>에서도 이러한 방법을 예시 코드로 보여주고 있다.</p>\n<p>공식문서에서는 이를 선언적(declarative) 방식이라 표현하며, 명령적(imperative) 방식보다 편의성과 직관성이 뛰어나고 소개한다. 그리고 좀 더 찾아보니 useState를 사용하면, 단일 진실 공급원(Single Source of Truth)을 확보할 수 있다고 한다. 한 마디로 표현하면 <strong>변수의 origin을 보장</strong>한다는 말인데, 겨우 하나의 컴포넌트 내에서 데이터의 공급원을 보장하는게 정말 중요할지는 의문이다.</p>\n<pre><code class=\"language-javascript\">import { useState } from 'react'\n\nexport default function Component() {\n  const [answer, setAnswer] = useState('') // input의 값\n\n  // input 변화를 감지해서 answer 업데이트 (양방향 바인딩)\n  const handleChange = (event) => {\n    setAnswer(event.target.value)\n  }\n\n  // form 제출\n  const handleSubmit = (event) => {\n    e.preventDefault()\n    submit(answer) // answer 값을 제출\n  }\n\n  return (\n    &#x3C;form onSubmit={handleSubmit}>\n      &#x3C;input type=\"text\" value={answer} onChange={handleChange} />\n      &#x3C;button type=\"submit\">제출&#x3C;/button>\n    &#x3C;/form>\n  )\n}\n</code></pre>\n<h2 id=\"21-form-항목-증가에-따른-문제\" style=\"position:relative;\"><a href=\"#21-form-%ED%95%AD%EB%AA%A9-%EC%A6%9D%EA%B0%80%EC%97%90-%EB%94%B0%EB%A5%B8-%EB%AC%B8%EC%A0%9C\" aria-label=\"21 form 항목 증가에 따른 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. form 항목 증가에 따른 문제</h2>\n<p>아무튼 편리한 useState의 사용이, form에서 관리해야할 데이터가 많아지만 단점이 되어버린다. form에서 관리해야하는 데이터가 한 50개 정도라고 가정해보자. 아래 코드처럼 단순히 <strong>데이터를 선언하고, 바인딩하는 코드만 200줄</strong>이다. 무슨 하나의 form에서 50개의 값을 제출하냐 싶겠지만, 목록형 데이터를 다루면 가뿐하게 뛰어넘을 수 있다. 실제 가장 최근에 진행한 프로젝트에서 5개의 값을 가진 10개의 목록 데이터를 제출해야했다.</p>\n<p>이로 인한 문제를 다시 정리하자면, <mark>1. 코드의 복잡도가 증가한다</mark>. 일단 코드가 길어지니까 당연히 코드가 복잡해질 수 밖에 없다. <mark>2. 불필요한 리렌더링이 빈번하게 발생한다</mark>. 50개의 변수 중 하나라도 값이 바뀌면, 해당 컴포넌트가 리렌더링된다. 더군다나 50개의 데이터를 다루는 컴포넌트는 간단하지도 않을 것이다.</p>\n<pre><code class=\"language-javascript\">import { useState } from 'react'\n\nexport default function Component() {\n  // 50줄\n  const [answer1, setAnswer1] = useState('')\n  ...\n  const [answer50, setAnswer50] = useState('')\n\n  // 150줄\n  const handleChange1 = (event) => {\n    setAnswer1(event.target.value)\n  }\n  ...\n  const handleChange50 = (event) => {\n    setAnswer50(event.target.value)\n  }\n\n  ...\n\n  return (\n    &#x3C;form onSubmit={handleSubmit}>\n      &#x3C;input type=\"text\" value={answer1} onChange={handleChange1} />\n      ...\n      &#x3C;input type=\"text\" value={answer50} onChange={handleChange50} />\n      &#x3C;button type=\"submit\">제출&#x3C;/button>\n    &#x3C;/form>\n  )\n}\n</code></pre>\n<h1 id=\"3-formdata로의-전환\" style=\"position:relative;\"><a href=\"#3-formdata%EB%A1%9C%EC%9D%98-%EC%A0%84%ED%99%98\" aria-label=\"3 formdata로의 전환 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. formData로의 전환</h1>\n<p>웹페이지의 3요소는 html, css, javaScript이고, 이 중에서 html은 가장 유구한 전통을 자랑한다. <del>반면 javaScript은 요즘 어떻게든 줄이려고들 난리이다.</del> 때문에 html은 그 자체만으로도 웹페이지를 운영할 수 있도록 기본적인 기능을 가지고 있다. 그 중에 하나가 <code>&#x3C;input></code>과 <code>&#x3C;form></code>의 조합을 이용한 데이터 제출이다.</p>\n<h2 id=\"21-input-태그-활용\" style=\"position:relative;\"><a href=\"#21-input-%ED%83%9C%EA%B7%B8-%ED%99%9C%EC%9A%A9\" aria-label=\"21 input 태그 활용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. input 태그 활용</h2>\n<p><code>&#x3C;input></code>는 사용자의 입력값을 받을 수 있는 태그이다. 브라우저가 자체적으로 input의 변화를 감지해서 화면에 반영하기 때문에, 컴포넌트 리렌더링을 따로 고려하지 않아도 된다.</p>\n<input/>\n<p>위에 있는 텍스트 필드가 그냥 <code>&#x3C;input></code>을 선언한 것이다. 별도의 javaScript 코드가 없지만, 자유롭게 텍스트를 입력할 수 있고, 그 값이 화면에 반영된다.</p>\n<h2 id=\"22-formdata-활용\" style=\"position:relative;\"><a href=\"#22-formdata-%ED%99%9C%EC%9A%A9\" aria-label=\"22 formdata 활용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2. formData 활용</h2>\n<p><code>&#x3C;input></code>의 값들은 <code>&#x3C;form></code>으로 모을 수 있다. JavaScript의 <code>FormData</code> 생성자에 <code>&#x3C;form></code> 요소에 넣어 객체를 생성하면, <mark>해당 form 내부에 있는 입력값들을 모은 FormData 객체가 생성된다</mark>. 참고로 formData 객체는 콘솔에 찍어도 내부 값을 확인할 수 없다. 번거롭지만 for문을 돌려서 안에 있는 요소를 확인해야 한다.</p>\n<pre><code class=\"language-javascript\">export default function Component() {\n  const handleSubmit = async (e: React.FormEvent&#x3C;HTMLFormElement>) => {\n    e.preventDefault()\n    e.stopPropagation()\n\n    const form = e.currentTarget // HTML form 요소\n    const formData = new FormData(form) // FormData 객체 생성\n\n    // 내부 값 출력\n    for (let key of formData.keys()) {\n      console.log(key, ':', formData.get(key))\n    }\n\n    // 콘솔 예시\n    // name : 홍길동\n    // age : 25\n    // phone : 01012345678\n  }\n\n  return (\n    &#x3C;form onSubmit={handleSubmit}>\n      &#x3C;input type=\"text\" name=\"name\" />\n      &#x3C;input type=\"number\" name=\"age\" />\n      &#x3C;input type=\"text\" name=\"phone\" />\n      &#x3C;button type=\"submit\">제출&#x3C;/button>\n    &#x3C;/form>\n  )\n}\n</code></pre>\n<h2 id=\"23-유효성-검사\" style=\"position:relative;\"><a href=\"#23-%EC%9C%A0%ED%9A%A8%EC%84%B1-%EA%B2%80%EC%82%AC\" aria-label=\"23 유효성 검사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3. 유효성 검사</h2>\n<p>formData에 대한 유효성 검사는 정해진 방법이 없다. 아래는 내가 사용한 유효성 검사 방식 중 하나이다.</p>\n<pre><code class=\"language-javaScript\">export function validate(formData: FormData) {\n  // 이름 유효성 검사\n  const name = formData.get('name') as string\n  if (!/^[A-Za-z\\dㄱ-ㅎㅏ-ㅣ가-힣]{2,10}$/.test(name)) {\n    return false\n  }\n\n  // 나이 유효성 검사\n  const age = formData.get('age') as string\n  if (!/^[0-9]{1,3}$/.test(age)) {\n    return false\n  }\n\n  // 휴대폰 유효성 검사\n  const phone = formData.get('phone') as string\n  if (/^(010)-?[0-9]{3,4}-?[0-9]{4}$/.test(phone)) {\n    return false\n  }\n\n  return formData\n}\n</code></pre>\n<h2 id=\"24-서버-전송\" style=\"position:relative;\"><a href=\"#24-%EC%84%9C%EB%B2%84-%EC%A0%84%EC%86%A1\" aria-label=\"24 서버 전송 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.4. 서버 전송</h2>\n<p>formData 형식 그대로 서버에 전송할 때는 Content-Type을 <code>'multipart/form-data'</code>으로 설정해야한다. 그래야지만 백서버에서 데이터를 추출할 수 있다.</p>\n<pre><code class=\"language-javaScript\">import axios from 'axios'\n\nexport async function submit(formData: FormData) {\n  return axios.post('/api', formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data',\n        },\n      })\n}\n</code></pre>\n<h1 id=\"3-추가-고려사항\" style=\"position:relative;\"><a href=\"#3-%EC%B6%94%EA%B0%80-%EA%B3%A0%EB%A0%A4%EC%82%AC%ED%95%AD\" aria-label=\"3 추가 고려사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 추가 고려사항</h1>\n<h2 id=\"31-checkbox\" style=\"position:relative;\"><a href=\"#31-checkbox\" aria-label=\"31 checkbox permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1. checkbox</h2>\n<p>보통 체크박스를 사용해서 불리언 값을 다룬다. 체크박스가 체크되었을 때의 값은 value 속성을 이용해서 <code>true</code> 외에도 마음대로 지정해줄 수 있다. 그런데 문제는 체크박스가 체크되지 않았을 때이다. 보통 체크가 되지 않으면 <code>false</code>나 <code>null</code>등의 값으로 formData에 수집되길 기대할텐데, 실제로는 아예 formData에서 제외된다. 이에 대해 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#value\">MDN 공식문서</a>는 javaScript를 이용해서 <mark>unchecked 상태일 때의 값을 <code>&#x3C;input type=\"hidden\"></code>로 동적으로 추가</mark>하라고 한다. 그래서 체크박스에 한해 useState를 사용할 수 밖에 없었다.</p>\n<pre><code class=\"language-javaSCript\">import { useState } from 'react'\n\nexport default function Component() {\n  const [isAdult, setIsAdult] = useState(false)\n\n  const handleChange = (e) => {\n    setIsAdult(e.target.checked)\n  }\n\n  return (\n    &#x3C;form onSubmit={handleSubmit}>\n      &#x3C;input type=\"checkbox\" name=\"isAdult\" value={isAdult} onChange={handleChange}/>\n      {!isActive &#x26;&#x26; &#x3C;input type=\"hidden\" name=\"isAdult\" value={isAdult} />}\n      &#x3C;button type=\"submit\">제출&#x3C;/button>\n    &#x3C;/form>\n  )\n}\n</code></pre>\n<h2 id=\"32-목록-데이터\" style=\"position:relative;\"><a href=\"#32-%EB%AA%A9%EB%A1%9D-%EB%8D%B0%EC%9D%B4%ED%84%B0\" aria-label=\"32 목록 데이터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2. 목록 데이터</h2>\n<p>목록 데이터를 수집하기 위해서는 아래 코드와 같이 인덱싱 <code>[]</code> 을 사용하면 된다.</p>\n<pre><code class=\"language-javaScript\">&#x3C;form>\n  &#x3C;input type=\"text\" name=\"names[0]\"/>\n  &#x3C;input type=\"text\" name=\"names[1]\"/>\n  &#x3C;input type=\"text\" name=\"names[2]\"/>\n&#x3C;/form>\n\n// javaScript 객체로 표현하면 다음과 같다.\ndata : {\n  names: [\"name0\", \"name1\", \"name2\"]\n}\n</code></pre>\n<p>아래와 같은 방식으로 <strong>객체 목록 데이터</strong>를 수집할 수도 있다.</p>\n<pre><code class=\"language-javaScript\">&#x3C;form>\n  &#x3C;input type=\"text\" name=\"people[0].name\"/>\n  &#x3C;input type=\"number\" name=\"people[0].age\"/>\n  &#x3C;input type=\"phone\" name=\"people[0].phone\"/>\n  &#x3C;input type=\"text\" name=\"people[1].name\"/>\n  &#x3C;input type=\"number\" name=\"people[1].age\"/>\n  &#x3C;input type=\"phone\" name=\"people[1].phone\"/>\n&#x3C;/form>\n\n// javaScript 객체로 표현하면 다음과 같다.\ndata : {\n  people: [\n    {\n      name: \"홍길동\",\n      number: 25,\n      phone: \"01012345678\"\n    },\n    {\n      name: \"고길동\",\n      number: 45,\n      phone: \"01087654321\"\n    },\n  ]\n}\n</code></pre>\n<h1 id=\"4-한계점\" style=\"position:relative;\"><a href=\"#4-%ED%95%9C%EA%B3%84%EC%A0%90\" aria-label=\"4 한계점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 한계점</h1>\n<p>입력값이 <code>&#x3C;input></code>이외에서도 사용된다면 useState를 사용해야 한다.</p>\n<pre><code class=\"language-javaScript\">import { useState } from 'react'\n\nexport default function Component() {\n  const [color, setColor] = useState('')\n\n  const handleChange = (e) => {\n    setColor(e.target.value)\n  }\n\n  return (\n    &#x3C;div>\n      &#x3C;form>\n        &#x3C;input type=\"text\" name=\"color\" onChange={handleChange} />\n        &#x3C;button type=\"submit\">제출&#x3C;/button>\n      &#x3C;/form>\n      &#x3C;p style={{ color: color, fontSize: '2rem', fontWeight: 800 }}>{color}&#x3C;/p>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p><img src=\"/TIL/61a22a586db4c87fe5bc76b2003d28c1/useState.gif\" alt=\"useState 활용 예시\"></p>\n<h1 id=\"5-참고자료\" style=\"position:relative;\"><a href=\"#5-%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\" aria-label=\"5 참고자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 참고자료</h1>\n<ul>\n<li><a href=\"https://react.dev/learn/state-a-components-memory\">React 공식문서 \"State: A Component's Memory\" </a></li>\n<li><a href=\"https://react.dev/learn/reacting-to-input-with-state\">React 공식문서 \"Reacting to Input with State\"</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FormData/FormData\">MDN \"FormData() constructor\"</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#value\">MDN \"&#x3C;input type=\"checkbox\">\"</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-usestate%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\">1. useState란 무엇인가</a></p>\n</li>\n<li>\n<p><a href=\"#2-usestate-%EC%96%91%EB%B0%A9%ED%96%A5-%EB%B0%94%EC%9D%B8%EB%94%A9\">2. useState 양방향 바인딩</a></p>\n<ul>\n<li><a href=\"#21-form-%ED%95%AD%EB%AA%A9-%EC%A6%9D%EA%B0%80%EC%97%90-%EB%94%B0%EB%A5%B8-%EB%AC%B8%EC%A0%9C\">2.1. form 항목 증가에 따른 문제</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-formdata%EB%A1%9C%EC%9D%98-%EC%A0%84%ED%99%98\">3. formData로의 전환</a></p>\n<ul>\n<li><a href=\"#21-input-%ED%83%9C%EA%B7%B8-%ED%99%9C%EC%9A%A9\">2.1. input 태그 활용</a></li>\n<li><a href=\"#22-formdata-%ED%99%9C%EC%9A%A9\">2.2. formData 활용</a></li>\n<li><a href=\"#23-%EC%9C%A0%ED%9A%A8%EC%84%B1-%EA%B2%80%EC%82%AC\">2.3. 유효성 검사</a></li>\n<li><a href=\"#24-%EC%84%9C%EB%B2%84-%EC%A0%84%EC%86%A1\">2.4. 서버 전송</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-%EC%B6%94%EA%B0%80-%EA%B3%A0%EB%A0%A4%EC%82%AC%ED%95%AD\">3. 추가 고려사항</a></p>\n<ul>\n<li><a href=\"#31-checkbox\">3.1. checkbox</a></li>\n<li><a href=\"#32-%EB%AA%A9%EB%A1%9D-%EB%8D%B0%EC%9D%B4%ED%84%B0\">3.2. 목록 데이터</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#4-%ED%95%9C%EA%B3%84%EC%A0%90\">4. 한계점</a></p>\n</li>\n<li>\n<p><a href=\"#5-%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\">5. 참고자료</a></p>\n</li>\n</ul>","frontmatter":{"title":"React에서 formData 활용하기","createdAt":"2024-01-16","updatedAt":"2024-01-16","tags":["react","input","form","formData","최적화","유효성"],"description":"React에서 useState 대신 formData를 이용해서 사용자 input을 관리한다.","reference":null}},"allMarkdownRemark":{"nodes":[{"id":"c919c895-9bcb-5e95-83ac-31a2a09d0a7c","excerpt":"1. useState란 무엇인가 리액트의 useState는 대표적으로 2가지 기능을 제공한다. 1. 컴포넌트가 리렌더링 되더라도 값을 유지하고,…","parent":{"id":"f9178901-27bc-5e53-b540-2c72031d0097","name":"react_form_data","relativePath":"Frontend/React/react_form_data.md"},"frontmatter":{"title":"React에서 formData 활용하기","createdAt":"2024-01-16","updatedAt":"2024-01-16"},"fields":{"slug":"/posts/Frontend/React/react_form_data/"}},{"id":"340db7bc-71c4-530c-b15c-93ba0b54ff19","excerpt":"이 글에서는 responsive-loader를 적용하는 법을 중심적으로 다룬다. 원리에 대한 내용은 '정적 이미지를 로딩하는 가장 완벽한 방법' 포스팅에 정리했다. 1. responsive-loader 자바스크립트로 만들어진 웹팩 플러그인이다. npm…","parent":{"id":"33721eb9-f3db-5fff-9657-051d86646050","name":"responsive_loader","relativePath":"Frontend/React/responsive_loader.md"},"frontmatter":{"title":"React & Webpack 이미지 로딩 최적화","createdAt":"2023-10-16","updatedAt":"2023-10-16"},"fields":{"slug":"/posts/Frontend/React/responsive_loader/"}},{"id":"dc8842b1-870b-58e5-bf26-f2bfeb739a7f","excerpt":"1. Context 1.1. Props와 비교 1.2. 사용 예시 2. useReducer 1.1. 개념 1.2. 예시 (원시 타입) 1.3. 예시(참조타입) 1. Context…","parent":{"id":"3bb6320c-de7a-5fc6-98b2-3b2c10ea6b10","name":"02_React_Context_API","relativePath":"Frontend/React/02_React_Context_API.md"},"frontmatter":{"title":"React Context API 란?","createdAt":"2023-05-02","updatedAt":"2023-05-08"},"fields":{"slug":"/posts/Frontend/React/02_React_Context_API/"}},{"id":"ee1b12d6-a243-50d5-ae99-32f322ad757f","excerpt":"1. Redux Toolkit 기본 사용 2. Redux Toolkit 비동기 2.1. 목표 2.2. createAsyncThunk 실전 예제 1. Redux Toolkit 기본 사용 Slice 생성\nslice…","parent":{"id":"e2d2b32a-0399-59ef-8f65-f072379a23bd","name":"03_React_Redux_Toolkit","relativePath":"Frontend/React/03_React_Redux_Toolkit.md"},"frontmatter":{"title":"Redux Toolkit 기본 사용법","createdAt":"2023-05-02","updatedAt":"2023-05-08"},"fields":{"slug":"/posts/Frontend/React/03_React_Redux_Toolkit/"}},{"id":"686965c0-6280-5d37-9dc5-7f66341f4fdd","excerpt":"추후 참고하기 위해, 반복되는 CRA기반 리액트 초기 셋팅 작업을 공식문서들을 참고하여 정리한 문서입니다. 1. Create React App 2. eslint & prettier 2.1. eslint 2.2. prettier 3. React…","parent":{"id":"d9f9edaa-1b95-5100-bd47-d45bc63f29d5","name":"Create_React_App_Initial_Setting","relativePath":"Frontend/React/Create_React_App_Initial_Setting.md"},"frontmatter":{"title":"Create React App 초기 셋팅 정리","createdAt":"2023-04-23","updatedAt":"2023-04-28"},"fields":{"slug":"/posts/Frontend/React/Create_React_App_Initial_Setting/"}}]}},"pageContext":{"pagePath":"/posts/Frontend/React/react_form_data/","siblingPostsPathRegex":"/^(?!.*README).*Frontend\\/React\\/.*$/","relativeDirectory":"React","id":"c919c895-9bcb-5e95-83ac-31a2a09d0a7c","parent":{"id":"f9178901-27bc-5e53-b540-2c72031d0097","name":"react_form_data","relativePath":"Frontend/React/react_form_data.md"},"fields":{"slug":"/posts/Frontend/React/react_form_data/"}}},"staticQueryHashes":["24302420","4059933791"],"slicesMap":{}}