{"componentChunkName":"component---src-templates-post-index-tsx","path":"/posts/Frontend/React/contextAPI_practice/","result":{"data":{"markdownRemark":{"id":"8ededc75-f496-552e-9613-bf6345e60b1e","html":"<h1 id=\"1-context-란\" style=\"position:relative;\"><a href=\"#1-context-%EB%9E%80\" aria-label=\"1 context 란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Context 란?</h1>\n<p>나는 <mark>React 자체 전역 데이터 저장소</mark>라고 생각한다. 일반적으로 React에서 데이터를 하위 컴포넌트로 전달하기 위해서는 props로 일일히 내려줘야 한다. 따라서 데이터를 손자, 증손자, 고조손자까지 넘겨주려고 하면 코드가 지저분해질 뿐 아니라 불필요한 리렌더링이 발생한다. 이를 <strong>Props-Drilling</strong>이라고 한다.</p>\n<p><code>Context</code>를 이용하면 <code>Provider</code>로 감싼 모든 하위 컴포넌트에서 자유롭게 데이터에 접근 할 수 있다. 여기에 <code>reducer</code>를 이용해서 상태 업데이트를 규격화하면 일종의 Flux Pattern을 가진 미니 전역 저장소를 만들 수 있다. 중간 컴포넌트에서의 <strong>불필요한 리렌더링 또한 <code>children</code> prop으로 극복 가능</strong>하다. 이에 대해서는 아래에서 한 번 더 다룰 예정이다.</p>\n<h2 id=\"11-간단한-예시-themeprovider\" style=\"position:relative;\"><a href=\"#11-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%98%88%EC%8B%9C-themeprovider\" aria-label=\"11 간단한 예시 themeprovider permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1. 간단한 예시 (ThemeProvider)</h2>\n<p><code>useContext</code>를 사용하는 가장 대표적인 경우는 <strong>다크모드 관리</strong>이다. 아마 Context의 기본 동작이 Provider 하위 컴포넌트의 리렌더링을 유발하기 때문에, 다크모드처럼 제한적으로 바뀌는 값을 관리하는 것 같다.</p>\n<pre><code class=\"language-js\">import React, { useState, useContext, createContext } from 'react'\nimport { ThemeContext } from './context/ThemeContext'\n\nexport const ThemeContext = createContext()\n\nfunction App() {\n  const [isDark, setIsDark] = useState(false)\n\n  return (\n    &#x3C;ThemeContext.Provider value={{ isDark, setIsDark }}>\n      &#x3C;Page />\n    &#x3C;/ThemeContext.Provider>\n  )\n}\n\nfunction Page() {\n  return &#x3C;div>Page&#x3C;/div>\n}\n\nfunction Component() {\n  const { isDark, setIsDark } = useContext(ThemeContext)\n\n  return (\n    &#x3C;div>\n      &#x3C;div>{isDark ? 'dark' : 'light'}&#x3C;/div>\n      &#x3C;button onClick={() => setIsDark((theme) => !theme)}>모드 전환&#x3C;/button>\n    &#x3C;/div>\n  )\n}\n\nexport default App\n</code></pre>\n<p><img src=\"/TIL/220fa81f3d265bc271873f983548830e/useContext-theme.gif\" alt=\"useContext 테마 전환\"></p>\n<h2 id=\"12-usereducer-란\" style=\"position:relative;\"><a href=\"#12-usereducer-%EB%9E%80\" aria-label=\"12 usereducer 란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2. useReducer 란?</h2>\n<p><code>reducer</code>는 <mark>상태를 업데이트를 제한하는 함수로써, 전역 상태의 무분별한 접근과 수정을 방지</mark>한다.</p>\n<p><code>useReducer</code>를 사용하면 <code>reducer</code>로 관리되는 데이터를 쉽게 생성할 수 있다. <code>useState</code>와 아주 유사하여 <a href=\"https://react.dev/learn/extracting-state-logic-into-a-reducer#comparing-usestate-and-usereducer\">공식문서</a>에도 이 둘을 비교 정리했다. <code>useState</code>가 상태를 자유롭게 수정할 수 있는 <code>setState</code>를 반환하는 한편, <code>useReducer</code>는 미리 정의된 <code>reducer</code>에 맞춰 동작하는 <code>dispatcher</code>를 반환한다.</p>\n<pre><code class=\"language-js\">import React, { useState, useReducer } from 'react'\n\n/**\n *\n * @param state 기존 상태\n * @param action dispatch로 전달 받은 인자\n * @returns\n */\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case 'deposit':\n      return state + action.payload\n    case 'withdraw':\n      return state - action.payload\n    default:\n      return state\n  }\n}\n\nfunction App() {\n  const [balance, dispatch] = useReducer(reducer, 0) // reducer, 초깃값\n\n  function deposit() {\n    dispatch({ type: 'deposit', payload: number })\n  }\n\n  function withdraw() {\n    dispatch({ type: 'withdraw', payload: number })\n  }\n\n  return (\n    &#x3C;div>\n      &#x3C;p>{balance}원&#x3C;/p>\n      &#x3C;button onClick={deposit}>예금&#x3C;/button>\n      &#x3C;button onClick={withdraw}>출금&#x3C;/button>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p><img src=\"/TIL/be828b262dd7e63853cf876dd3047b5b/useReducer-balance.gif\" alt=\"useContext 테마 전환\"></p>\n<h2 id=\"12-context와-usereducer\" style=\"position:relative;\"><a href=\"#12-context%EC%99%80-usereducer\" aria-label=\"12 context와 usereducer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2. Context와 useReducer</h2>\n<p><code>Context</code>에 <code>useReducer</code>을 결합하면, Flux Pattern의 전역 저장소를 구현할 수 있다. 아래 예시 코드는 어쩌다보니 TypeScript로 작성했다.</p>\n<pre><code class=\"language-ts\">// types.ts\nimport React, { createContext, useReducer } from 'react'\n\ntype TState = {\n  name: string\n  count: number\n}\n\ntype TAction = {\n  type: 'UP' | 'DOWN'\n  pyload?: any\n}\n\ntype TContext = {\n  state: TState\n  dispatch: React.Dispatch&#x3C;TAction>\n}\n</code></pre>\n<pre><code class=\"language-ts\">// Context.ts\nimport { createContext } from 'react'\nimport { TContext } from './types'\n\nexport const Context = createContext&#x3C;TContext | null>(null)\n</code></pre>\n<pre><code class=\"language-tsx\">// ContextProvider.tsx\nimport React, { useReducer } from 'react'\nimport { TAction, TState } from './types'\nimport { Context } from './Context'\n\nconst initState: TState = {\n  name: 'sample-name',\n  count: 0,\n}\n\nconst reducer = (state: TState, action: TAction) => {\n  switch (action.type) {\n    case 'UP':\n      return {\n        ...state,\n        count: state.count + 1,\n      }\n    case 'DOWN':\n      return {\n        ...state,\n        count: state.count - 1,\n      }\n  }\n}\n\nconst ContextProvider = ({ children }: React.PropsWithChildren) => {\n  const [state, dispatch] = useReducer(reducer, initState)\n\n  return (\n    &#x3C;Context.Provider value={{ state, dispatch }}>{children}&#x3C;/Context.Provider>\n  )\n}\n\nexport default ContextProvider\n</code></pre>\n<pre><code class=\"language-tsx\">// App.tsx\nimport { useContext } from 'react'\nimport ContextProvider from './ContextProvider'\nimport { Context } from './Context'\n\nconst App = () => {\n  return (\n    &#x3C;ContextProvider>\n      &#x3C;Parent />\n    &#x3C;/ContextProvider>\n  )\n}\n\nconst Parent = () => {\n  return &#x3C;Child />\n}\n\nconst Child = () => {\n  const context = useContext(Context)\n\n  if (!context) return\n\n  return (\n    &#x3C;div>\n      &#x3C;div>{context.state.count}&#x3C;/div>\n      &#x3C;button onClick={() => context.dispatch({ type: 'UP' })}>+&#x3C;/button>\n      &#x3C;button onClick={() => context.dispatch({ type: 'DOWN' })}>-&#x3C;/button>\n    &#x3C;/div>\n  )\n}\n\nexport default App\n</code></pre>\n<p><img src=\"/TIL/20b4eeefbe9d7f472af621166ca8afab/useContext-useReducer.gif\" alt=\"useContext와 useReducer 결합\"></p>\n<h1 id=\"2-context의-한계\" style=\"position:relative;\"><a href=\"#2-context%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-label=\"2 context의 한계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Context의 한계</h1>\n<p>흔히 Context의 한계로 <strong>중간 컴포넌트의 불필요한 리렌더링을 꼽는다.</strong> 맞으면서도 틀린 말이다.</p>\n<p>아래 두 개의 코드는 <code>children</code> Prop 사용유무를 제외하면 완벽하게 동일하다. 하지만 콘솔을 찍어보면, <code>children</code>을 사용한 경우에 중간 컴포넌트의 불필요한 리렌더링을 발생하지 않는다.</p>\n<pre><code class=\"language-jsx\">// children 사용 안함\nimport { useState, createContext, useContext } from 'react'\n\nconst MyContext = createContext(null)\n\nconst App = () => {\n  console.log('App is Rendered')\n\n  const [number, setNumber] = useState(0)\n\n  return (\n    &#x3C;MyContext.Provider value={{ number, setNumber }}>\n      &#x3C;Parent />\n    &#x3C;/MyContext.Provider>\n  )\n}\n\nconst Parent = () => {\n  console.log('Parent is Rendered')\n\n  return &#x3C;Child />\n}\n\nconst Child = () => {\n  const { number, setNumber } = useContext(MyContext)\n\n  console.log('Child is Rendered')\n\n  return (\n    &#x3C;div>\n      &#x3C;p>{number}&#x3C;/p>\n      &#x3C;button onClick={() => setNumber((prev) => prev + 1)}>+&#x3C;/button>\n      &#x3C;button onClick={() => setNumber((prev) => prev - 1)}>-&#x3C;/button>\n    &#x3C;/div>\n  )\n}\n\nexport default App\n</code></pre>\n<p><img src=\"/TIL/769461c21bc8b52bc22bf28622eb1194/provider-without-children.gif\" alt=\"children 사용하지 않은 Context\"></p>\n<pre><code class=\"language-jsx\">// children 사용함\nimport { useState, createContext, useContext } from 'react'\n\nconst MyContext = createContext(null)\n\nconst MyProvider = ({ children }) => {\n  console.log('Provider is Rendered')\n\n  const [number, setNumber] = useState(0)\n\n  return (\n    &#x3C;MyContext.Provider value={{ number, setNumber }}>\n      {children}\n    &#x3C;/MyContext.Provider>\n  )\n}\n\nconst App = () => {\n  console.log('App is Rendered')\n\n  return (\n    &#x3C;MyProvider>\n      &#x3C;Parent />\n    &#x3C;/MyProvider>\n  )\n}\n\nconst Parent = () => {\n  console.log('Parent is Rendered')\n\n  return &#x3C;Child />\n}\n\nconst Child = () => {\n  const { number, setNumber } = useContext(MyContext)\n\n  console.log('Child is Rendered')\n\n  return (\n    &#x3C;div>\n      &#x3C;p>{number}&#x3C;/p>\n      &#x3C;button onClick={() => setNumber((prev) => prev + 1)}>+&#x3C;/button>\n      &#x3C;button onClick={() => setNumber((prev) => prev - 1)}>-&#x3C;/button>\n    &#x3C;/div>\n  )\n}\n\nexport default App\n</code></pre>\n<p><img src=\"/TIL/ee934987fd3a16ffd33e24b77ef12984/provider-with-children.gif\" alt=\"children 사용한 Context\"></p>\n<h2 id=\"21-children-에-대한-고찰\" style=\"position:relative;\"><a href=\"#21-children-%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0\" aria-label=\"21 children 에 대한 고찰 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. children 에 대한 고찰</h2>\n<p>간단하게 말하면 <code>children</code>으로 <code>ReactNode</code>를 넘겨주는 행위는, <strong>완성된 컴포넌트를 전달</strong>해주는 것과 같다.</mark> 하위 컴포넌트가 별개로 완성되어 상위 컴포넌트에 prop으로 넘겨졌기 때문에, 하위 컴포넌트의 렌더링이 더이상 상위 컴포넌트에 종속되지 않는다. (더 정확한 원인을 알기 위해서는 React 가상 DOM을 학습해야 할 것 같다.)</p>\n<p>기존</p>\n<pre><code class=\"language-jsx\">const Parent = ({ children }) => {\n  return &#x3C;div>{children}&#x3C;/div>\n}\n\n// 아래 두 형식이 동일하다.\nconst Container = () => {\n  return (\n    &#x3C;Parent>\n      &#x3C;Child />\n    &#x3C;/Parent>\n  )\n}\n\nconst Container = () => {\n  return &#x3C;Parent children={&#x3C;Child />} />\n}\n</code></pre>\n<h1 id=\"3-radio에-context-적용\" style=\"position:relative;\"><a href=\"#3-radio%EC%97%90-context-%EC%A0%81%EC%9A%A9\" aria-label=\"3 radio에 context 적용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Radio에 Context 적용</h1>\n<p>드디어 오늘의 주제에 도착했다. <code>Context</code>는 분명 편리한 기능이지만, 다른 전역 상태 라이브러리에 가려져 잘 사용하지 않는다. 그나마 앞서 말한 <code>ThemeProvider</code> 정도랄까. 그러던 중 최근에 아주 좋은 사용처를 발견했다. 바로 <strong>Radio 인풋 버튼</strong>이다.</p>\n<p>동일한 <code>name</code>의 Radio 버튼들은 서로 배타적이어야 하기 때문에 강한 연관성을 가진다. 하지만 이를 전역 상태로 관리하기에는 너무 지엽적이다. 이때 >Radio 버튼 그룹을 <code>Context</code>로 관리하면, 여러 개의 Radio 버튼 컴포넌트를 <strong>UI나 depth에 상관없이 자유롭게 배치</strong>할 수 있다. 구체적인 동작은 아래 코드에서 확인할 수 있다.</p>\n<pre><code class=\"language-ts\">import { ChangeEventHandler, createContext } from 'react'\n\ntype TRadioContext = {\n  name: string\n  value: string\n  onChange: ChangeEventHandler\n}\n\nexport const RadioContext = createContext&#x3C;TRadioContext | null>(null)\n</code></pre>\n<pre><code class=\"language-tsx\">import { ChangeEventHandler, PropsWithChildren, useState } from 'react'\nimport { RadioContext } from './RadioContext'\n\ntype RadioGroupProps = {\n  name: string\n  defaultValue: string\n  onChange?: ChangeEventHandler\n}\n\nconst RadioGroup = ({\n  children,\n  name,\n  defaultValue,\n  onChange,\n}: PropsWithChildren&#x3C;RadioGroupProps>) => {\n  const [value, setValue] = useState&#x3C;string>(defaultValue)\n\n  /**\n   * 하위 Radio 버튼 change 이벤트 처리\n   * 1. 데이터(vlaue) 업데이트\n   * 2. 지정된 함수(onChange) 동작\n   */\n  const handleChange: ChangeEventHandler&#x3C;HTMLInputElement> = (e) => {\n    setValue(e.currentTarget.value)\n    onChange &#x26;&#x26; onChange(e)\n  }\n\n  return (\n    &#x3C;RadioContext.Provider value={{ name, value, onChange: handleChange }}>\n      &#x3C;div>{name}&#x3C;/div>\n      &#x3C;div>{children}&#x3C;/div>\n    &#x3C;/RadioContext.Provider>\n  )\n}\n\nexport default RadioGroup\n</code></pre>\n<pre><code class=\"language-tsx\">import { ChangeEventHandler, useContext } from 'react'\nimport { RadioContext } from './RadioContext'\n\ntype RadioProps = {\n  value: string\n  label?: string\n}\n\nconst Radio = ({ value, label }: RadioProps) => {\n  const radioContext = useContext(RadioContext)\n\n  if (!radioContext) return\n\n  return (\n    &#x3C;label>\n      &#x3C;input\n        type=\"radio\"\n        name={radioContext.name} // context의 name으로 통일\n        value={value}\n        checked={!!radioContext &#x26;&#x26; radioContext.value === value}\n        onChange={radioContext.onChange}\n      />\n      {label ? label : value}\n    &#x3C;/label>\n  )\n}\n\nexport default Radio\n</code></pre>\n<h2 id=\"31-사용-방법\" style=\"position:relative;\"><a href=\"#31-%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95\" aria-label=\"31 사용 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1. 사용 방법</h2>\n<p>위 코드는 아래와 같이 사용할 수 있다. <mark><code>RadioGroup</code> 안에 있는 <code>Radio</code> 버튼들은 depth에 관계없이 결합된다.</mark> 정말로 데이터가 잘 선택되었는지 확인하기 위해 <code>submit</code>이벤트 발생 시 <code>form</code>안의 데이터를 수집해서 콘솔로 출력했다.</p>\n<pre><code class=\"language-tsx\">import React from 'react'\nimport RadioGroup from './RadioGroup'\nimport Radio from './Radio'\n\nconst App = () => {\n  const handleSubmit: React.FormEventHandler&#x3C;HTMLFormElement> = (e) => {\n    e.preventDefault()\n\n    // formData 콘솔 출력\n    const form = e.currentTarget\n    const formData = new FormData(form)\n    for (let key of formData.keys()) {\n      console.log(key, ':', formData.get(key))\n    }\n  }\n\n  return (\n    &#x3C;div>\n      &#x3C;form onSubmit={handleSubmit}>\n        &#x3C;RadioGroup\n          name=\"좋아하는 과일\"\n          defaultValue=\"사과\"\n          onChange={() => {\n            console.log('좋아하는 과일 change')\n          }}\n        >\n          &#x3C;Radio value=\"사과\" />\n          &#x3C;Radio value=\"바나나\" />\n          &#x3C;Radio value=\"딸기\" />\n        &#x3C;/RadioGroup>\n        &#x3C;RadioGroup\n          name=\"좋아하는 스타일\"\n          defaultValue=\"아메카지\"\n          onChange={() => {\n            console.log('좋아하는 스타일 change')\n          }}\n        >\n          &#x3C;StyleList />\n        &#x3C;/RadioGroup>\n        &#x3C;button type=\"submit\">제출&#x3C;/button>\n      &#x3C;/form>\n    &#x3C;/div>\n  )\n}\n\nconst StyleList = () => {\n  return (\n    &#x3C;div>\n      &#x3C;Radio value=\"댄디\" />\n      &#x3C;Radio value=\"아메카지\" />\n      &#x3C;Radio value=\"스트릿\" />\n    &#x3C;/div>\n  )\n}\n\nexport default App\n</code></pre>\n<p><img src=\"/TIL/120c8aac48c921a2cd1283144239b486/useContext-radio.gif\" alt=\"Context 사용한 Radio 동작\"></p>\n<h1 id=\"4-참조\" style=\"position:relative;\"><a href=\"#4-%EC%B0%B8%EC%A1%B0\" aria-label=\"4 참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 참조</h1>\n<ul>\n<li><a href=\"https://react.dev/learn/passing-data-deeply-with-context\">React : \"Passing Data Deeply with Context\"</a></li>\n<li><a href=\"https://react.dev/learn/extracting-state-logic-into-a-reducer\">React : \"Extracting State Logic into a Reducer\"</a></li>\n<li><a href=\"https://velog.io/@2ast/React-children-prop%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0feat.-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%B5%9C%EC%A0%81%ED%99%94\">2ast : \"React) children prop에 대한 고찰(feat. 렌더링 최적화)\"</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-context-%EB%9E%80\">1. Context 란?</a></p>\n<ul>\n<li><a href=\"#11-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%98%88%EC%8B%9C-themeprovider\">1.1. 간단한 예시 (ThemeProvider)</a></li>\n<li><a href=\"#12-usereducer-%EB%9E%80\">1.2. useReducer 란?</a></li>\n<li><a href=\"#12-context%EC%99%80-usereducer\">1.2. Context와 useReducer</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-context%EC%9D%98-%ED%95%9C%EA%B3%84\">2. Context의 한계</a></p>\n<ul>\n<li><a href=\"#21-children-%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0\">2.1. children 에 대한 고찰</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-radio%EC%97%90-context-%EC%A0%81%EC%9A%A9\">3. Radio에 Context 적용</a></p>\n<ul>\n<li><a href=\"#31-%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95\">3.1. 사용 방법</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#4-%EC%B0%B8%EC%A1%B0\">4. 참조</a></p>\n</li>\n</ul>","frontmatter":{"title":"Radio 버튼에 React Context 적용하기","createdAt":"2024-03-06","updatedAt":"2024-03-06","tags":["React","ContextAPI","Radio","상태 관리","children"],"description":"React 프로젝트의 Radio 인풋에 ContextAPI를 활용하여 손쉽게 관리해보자","reference":null}},"allMarkdownRemark":{"nodes":[{"id":"686965c0-6280-5d37-9dc5-7f66341f4fdd","excerpt":"추후 참고하기 위해, 반복되는 CRA기반 리액트 초기 셋팅 작업을 공식문서들을 참고하여 정리한 문서입니다. 1. Create React App 2. eslint & prettier 2.1. eslint 2.2. prettier 3. React…","parent":{"id":"d9f9edaa-1b95-5100-bd47-d45bc63f29d5","name":"Create_React_App_Initial_Setting","relativePath":"Frontend/React/Create_React_App_Initial_Setting.md"},"frontmatter":{"title":"Create React App 초기 셋팅 정리","createdAt":"2023-04-23","updatedAt":"2023-04-28"},"fields":{"slug":"/posts/Frontend/React/Create_React_App_Initial_Setting/"}},{"id":"dc8842b1-870b-58e5-bf26-f2bfeb739a7f","excerpt":"1. Context 1.1. Props와 비교 1.2. 사용 예시 2. useReducer 1.1. 개념 1.2. 예시 (원시 타입) 1.3. 예시(참조타입) 1. Context…","parent":{"id":"3bb6320c-de7a-5fc6-98b2-3b2c10ea6b10","name":"02_React_Context_API","relativePath":"Frontend/React/02_React_Context_API.md"},"frontmatter":{"title":"React Context API 란?","createdAt":"2023-05-02","updatedAt":"2023-05-08"},"fields":{"slug":"/posts/Frontend/React/02_React_Context_API/"}},{"id":"ee1b12d6-a243-50d5-ae99-32f322ad757f","excerpt":"1. Redux Toolkit 기본 사용 2. Redux Toolkit 비동기 2.1. 목표 2.2. createAsyncThunk 실전 예제 1. Redux Toolkit 기본 사용 Slice 생성\nslice…","parent":{"id":"e2d2b32a-0399-59ef-8f65-f072379a23bd","name":"03_React_Redux_Toolkit","relativePath":"Frontend/React/03_React_Redux_Toolkit.md"},"frontmatter":{"title":"Redux Toolkit 기본 사용법","createdAt":"2023-05-02","updatedAt":"2023-05-08"},"fields":{"slug":"/posts/Frontend/React/03_React_Redux_Toolkit/"}},{"id":"340db7bc-71c4-530c-b15c-93ba0b54ff19","excerpt":"이 글에서는 responsive-loader를 적용하는 법을 중심적으로 다룬다. 원리에 대한 내용은 '정적 이미지를 로딩하는 가장 완벽한 방법' 포스팅에 정리했다. 1. responsive-loader 자바스크립트로 만들어진 웹팩 플러그인이다. npm…","parent":{"id":"33721eb9-f3db-5fff-9657-051d86646050","name":"responsive_loader","relativePath":"Frontend/React/responsive_loader.md"},"frontmatter":{"title":"React & Webpack 이미지 로딩 최적화","createdAt":"2023-10-16","updatedAt":"2023-10-16"},"fields":{"slug":"/posts/Frontend/React/responsive_loader/"}},{"id":"c919c895-9bcb-5e95-83ac-31a2a09d0a7c","excerpt":"1. useState란 무엇인가 리액트의 useState는 대표적으로 2가지 기능을 제공한다. 1. 컴포넌트가 리렌더링 되더라도 값을 유지하고,…","parent":{"id":"f9178901-27bc-5e53-b540-2c72031d0097","name":"react_form_data","relativePath":"Frontend/React/react_form_data.md"},"frontmatter":{"title":"React에서 formData 활용하기","createdAt":"2024-01-16","updatedAt":"2024-01-16"},"fields":{"slug":"/posts/Frontend/React/react_form_data/"}},{"id":"8ededc75-f496-552e-9613-bf6345e60b1e","excerpt":"1. Context 란? 나는 React 자체 전역 데이터 저장소라고 생각한다. 일반적으로 React에서 데이터를 하위 컴포넌트로 전달하기 위해서는 props…","parent":{"id":"0e3e2d0a-7c62-55f6-b715-320a846f81b0","name":"contextAPI_practice","relativePath":"Frontend/React/contextAPI_practice.md"},"frontmatter":{"title":"Radio 버튼에 React Context 적용하기","createdAt":"2024-03-06","updatedAt":"2024-03-06"},"fields":{"slug":"/posts/Frontend/React/contextAPI_practice/"}}]}},"pageContext":{"pagePath":"/posts/Frontend/React/contextAPI_practice/","siblingPostsPathRegex":"/^(?!.*README).*Frontend\\/React\\/.*$/","relativeDirectory":"React","id":"8ededc75-f496-552e-9613-bf6345e60b1e","parent":{"id":"0e3e2d0a-7c62-55f6-b715-320a846f81b0","name":"contextAPI_practice","relativePath":"Frontend/React/contextAPI_practice.md"},"fields":{"slug":"/posts/Frontend/React/contextAPI_practice/"}}},"staticQueryHashes":["24302420","4059933791"],"slicesMap":{}}