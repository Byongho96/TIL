{"componentChunkName":"component---src-templates-post-index-tsx","path":"/posts/Frontend/Gatsby/09_Markdown_Styling/","result":{"data":{"markdownRemark":{"id":"6ae60c60-1e09-59a3-8a3c-f12ca9abd1c4","html":"<blockquote>\n<p><code>gatsby-transformer-remark</code>플러그인을 통한 <code>markdownRemark</code>노드를 사용을 전제합니다.</p>\n</blockquote>\n<h1 id=\"1-마크다운-스타일링\" style=\"position:relative;\"><a href=\"#1-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%EC%8A%A4%ED%83%80%EC%9D%BC%EB%A7%81\" aria-label=\"1 마크다운 스타일링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 마크다운 스타일링</h1>\n<p>나는 분명 <a href=\"https://www.gatsbyjs.com/docs/how-to/routing/adding-markdown-pages/\">Gatsby 공식문서</a>를 따라 <code>gatsby-transformer-remark</code>플러그인을 이용해서 마크다운 페이지를 만들고 있었다.</p>\n<p>그러던 중 <a href=\"https://www.gatsbyjs.com/docs/how-to/routing/migrate-remark-to-mdx/\">Remark에서 MDX로 이전하는 방법</a>이라는 기가 차는 또 하나의 공식문서를 발견하게 되었다. 아마 Gatsby는 <code>remark</code>노드보다 <code>MDX</code>노드를 주력으로 밀려고 하나보다.</p>\n<p>저 문서를 따라 몇 번 이전을 시도했지만, 번번히 실패하여 정신건강을 위해 그냥 <code>remark</code>노드를 이용하기로 했다. 어차피 내 웹사이트에는 MDX의 기능을 쓰지도 않는다.</p>\n<h2 id=\"11-graphql-불러오기\" style=\"position:relative;\"><a href=\"#11-graphql-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0\" aria-label=\"11 graphql 불러오기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1. GraphQL 불러오기</h2>\n<p>일단 grqphQL로 내가 원하는 <code>markdownRemark</code>노드의 <code>html</code>필드를 불러와야 한다. <strong>이 html에는 마크다운 문서가 html형식을 변환된 값이 <mark>문자열 형식</mark>으로 담겨있다.</strong></p>\n<pre><code class=\"language-js\">export const query = graphql`\n  query ($id: String!) {\n    markdownRemark(id: { eq: $id }) {\n      html\n      ...\n    }\n  }\n`\n</code></pre>\n<h2 id=\"12-dangerouslysetinnerhtml\" style=\"position:relative;\"><a href=\"#12-dangerouslysetinnerhtml\" aria-label=\"12 dangerouslysetinnerhtml permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2. dangerouslySetInnerHTML</h2>\n<p>그럼 이제 불러온 html 문자열을 리액트 tsx(jsx)문법에 맞춰 렌더링해야 한다.</p>\n<p>리액트는 어떻게 알고, 이런 경우를 위한 <mark>특별한 prop을</mark> 준비해놨다. 바로 <code>dangerouslySetInnerHTML</code>이다.<br>\n<strong><code>dangerouslySetInnerHTML</code>은 문자열 형식의 HTML을, 리액트 컴포넌트로 전환해서 렌더링할 수 있게 도와준다.</strong> 사용방법은 간단하다. <code>dangerouslySetInnerHTML</code>의 <code>__html</code> 속성 값으로 문자열 형식의 HTML을 전달하기만 하면 된다.</p>\n<p>근데 <mark>\"dangerously\"</mark>라는게 뭔가 좀 불안하다. 다른게 아니라 문자열이 그대로 html로 전환되는 만큼 조심히 사용하라는 것이다. 만약 전달하는 문자열이 악의적인 <code>&#x3C;script/></code>태그라도 가지고 있다면, XSS 공격이 발생할 수 있다.</p>\n<p>나는 다행히도 지금 정적 웹사이트 생성기로, 내가 작성한 마크다운 파일을 렌더링하려는 것이기 때문에 보안의 위험은 걱정할 필요 없다.</p>\n<pre><code class=\"language-js\">import React from 'react'\nimport type { PageProps } from 'gatsby'\n\nconst PostPage: React.FC&#x3C;PageProps> = ({ data }) => {\n  return &#x3C;div dangerouslySetInnerHTML={{ __html: data.markdownRemark.html }} />\n}\n</code></pre>\n<h2 id=\"13-마크다운-css\" style=\"position:relative;\"><a href=\"#13-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-css\" aria-label=\"13 마크다운 css permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.3. 마크다운 CSS</h2>\n<p>이제 그럼 렌더링 된 마크다운을 이쁘게 CSS 스타일링 해야한다. 근데 밑바닥부터 만드려니까 눈 앞이 깜깜해져, 좋은 레퍼런스를 하나 참조하기로 했다. 바로바로~ <strong>github</strong>이다!</p>\n<p>솔직히 과연 github CSS가 있을까 했는데, <a href=\"https://github.com/sindresorhus/github-markdown-css/blob/main/github-markdown.css\">너무 대놓고 있었다</a>. 심지어 <a href=\"https://www.npmjs.com/package/github-markdown-css\">npm 패키지</a>로도 제공한다. 나는 CSS를 커스텀할 것이기 때문에 복사해서 <code>src/styles/_markdown.scss</code>로 가져왔다.</p>\n<h3 id=\"131-마크다운에만-한정-적용\" style=\"position:relative;\"><a href=\"#131-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%EC%97%90%EB%A7%8C-%ED%95%9C%EC%A0%95-%EC%A0%81%EC%9A%A9\" aria-label=\"131 마크다운에만 한정 적용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.3.1. 마크다운에만 한정 적용</h3>\n<p>복붙해 온 css 코드를 슬쩍 보면, 너무 감사하게도 한 가지 공통된 특징을 발견할 수 있다.</p>\n<p><mark>바로 모든 선택자에 <code>.markdown-body</code>가 붙는다는 것이다.</mark> 다시 말해서 github의 모든 CSS는 <code>markdown-body</code>라는 클래스를 가진 요소 안에서만 적용된다.</p>\n<pre><code class=\"language-css\">.markdown-body mark {\n  background-color: var(--color-attention-subtle);\n  color: var(--color-fg-default);\n}\n\n.markdown-body small {\n  font-size: 90%;\n}\n\n.markdown-body sub,\n.markdown-body sup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\n...\n</code></pre>\n<p>그럼 아주 간단하게 아까 tsx(jsx)로 가서</p>\n<ol>\n<li>github CSS 파일을 import 하고</li>\n<li><code>dangerouslySetInnerHTML</code>으로 html을 내려준 요소에다 <code>markdown-body</code>라는 클래스를 추가해주면</li>\n</ol>\n<p>해당 요소에만 github CSS 한정 적용된다.</p>\n<pre><code class=\"language-js\">import React from 'react'\nimport from '@styles/_markdown.scss'\nimport type { PageProps } from 'gatsby'\n\nconst PostPage: React.FC&#x3C;PageProps> = ({ data }) => {\n  return (\n    &#x3C;div\n      className=\"markdown-body\" // 추가\n      dangerouslySetInnerHTML={{ __html: data.markdownRemark.html }}\n    />\n  )\n}\n</code></pre>\n<h3 id=\"132-다크모드\" style=\"position:relative;\"><a href=\"#132-%EB%8B%A4%ED%81%AC%EB%AA%A8%EB%93%9C\" aria-label=\"132 다크모드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.3.2. 다크모드</h3>\n<p>가져온 github CSS 파일을 보면, 다음과 같이 다크모드 관련 CSS 변수가 문서 앞쪽에서 모두 구분되어 있다.</p>\n<p>따라서 이 CSS 변수할당 부분만, 자신의 웹사이트 다크모드 기능에 맞게 수정하면 된다.</p>\n<pre><code class=\"language-css\">@media (prefers-color-scheme: dark) {\n  .markdown-body {\n    color-scheme: dark;\n    --color-fg-default: #c9d1d9;\n    --color-fg-muted: #8b949e;\n    --color-fg-subtle: #6e7681;\n    ...;\n  }\n}\n\n@media (prefers-color-scheme: light) {\n  .markdown-body {\n    color-scheme: light;\n    --color-fg-default: #24292f;\n    --color-fg-muted: #57606a;\n    --color-fg-subtle: #6e7781;\n    ...;\n  }\n}\n</code></pre>\n<p>나는 context API를 이용하여 <code>theme</code>을 <code>'dark' | 'light'</code>로 받는다. 따라서 이 <code>theme</code>변수를 아까 <code>markdown-body</code>클래스를 달은 요소에 추가해주었고</p>\n<pre><code class=\"language-js\">import React, { useContext } from 'react'\nimport from '@styles/_markdown.scss'\nimport type { PageProps } from 'gatsby'\nimport { ThemeContext } from '@contexts/theme-context'\n\nconst PostPage: React.FC&#x3C;PageProps> = ({ data }) => {\n  const { theme } = useContext(ThemeContext) // dark | light\n\n  return (\n    &#x3C;div\n      className={`markdown-body ${theme}`}\n      dangerouslySetInnerHTML={{ __html: data.markdownRemark.html }}\n    />\n  )\n}\n</code></pre>\n<p>이어서 깃헙 CSS의 변수할당 부분을 다음과 같이 커스텀했다.</p>\n<pre><code class=\"language-css\">.markdown-body.dark {\n  color-scheme: dark;\n  --color-fg-default: #c9d1d9;\n  --color-fg-muted: #8b949e;\n  --color-fg-subtle: #6e7681;\n  ...;\n}\n\n.markdown-body.light {\n  color-scheme: light;\n  --color-fg-default: #24292f;\n  --color-fg-muted: #57606a;\n  --color-fg-subtle: #6e7781;\n  ...;\n}\n</code></pre>\n<h1 id=\"2-코드-하이라이팅\" style=\"position:relative;\"><a href=\"#2-%EC%BD%94%EB%93%9C-%ED%95%98%EC%9D%B4%EB%9D%BC%EC%9D%B4%ED%8C%85\" aria-label=\"2 코드 하이라이팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 코드 하이라이팅</h1>\n<h2 id=\"21-토큰화란-tokenization\" style=\"position:relative;\"><a href=\"#21-%ED%86%A0%ED%81%B0%ED%99%94%EB%9E%80-tokenization\" aria-label=\"21 토큰화란 tokenization permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. 토큰화란? (Tokenization)</h2>\n<p>코드 하이라이팅에 대해 조금만 구글링해보면 <mark>토큰화(tokenization)</mark>라는 말이 나온다. 토큰이라고 하니까 JWT토큰 같은 것 밖에 생각 안나서 좀 이상했는데, 좀 더 알아보니 별거 아니었다.</p>\n<p><strong>코드 하이라이팅에서 토큰화란 소스 코드를 어휘 단위로 나누는 과정을 의미한다.</strong> 예를 들어, 키워드, 식별자, 연산자 등으로 해당 언어의 문법 구조에 맞춰 구분하는 것이다.</p>\n<p>예시를 보면 훨씬 더 직관적으로 이해할 수 있다. 아래는 Github에서 내 레포지토리의 아무 md파일을 열어 확인한 것이다. Github 사이트도 자체적으로 코드하이라이팅 기능을 지원하는데, 개발자도구를 열어서 요소를 확인해보면, <strong>작성된 코드 어휘 단위로 구분되어 클래스가 먹혀있는 걸 확인할 수 있다.</strong> 그리고 오른쪽 아래를 보면 CSS는 클래스에 맞춰 색깔을 입혀줬을 뿐이다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/bc786930723d940e745477093dcfd997/460fa/tokenization.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 54.285714285714285%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABJ0AAASdAHeZh94AAAB2UlEQVR42m2SCWrkMBBFff/DzVxhkrbbm2zJUmn18oLVncBABIU2ePz6vxofCs9e0XY93aDoesXn48nHx4NhmFhWg1KaeV4YhplxVEyTYlYL4zQzjBNjPzCNE0otNNs2suiRxXgk5HclnI/ozWGcr3fvPWazaOOw1uKcoFdD/xjQ61rPWhuaZP+ipz8sW8I6YXMeJwEnER8zzidSKS+gMdhtY3vXDR7+Pek/PunakWmaaEIoPLqZSWm0fQN9fKmKGR8LZT84j4Pfll+FLJ6cDo7joIkp00+KUa0sxrIa9wN9gTOp7IQQuK7r/wJk3pBFY7dI8IEmxsSiFsRJbXWTUJWFVH4q5RfwtyXKEa2Q4kFK+W451nS1DS9VIRFuwBvmUyHvB/teSMETRAhe8OLqvnQjehiYR1PDqS2Ps2ZeN8ztYTXcYv23h5n9OGsgz66ja1v6rqPvWvrnk/7Z1rfHZ0fbdjS5HOjVoRbDdo+JlQqzbw+txBqKiGAlEPNt/slxnpzn9frzAfGe1RiaUnbUPbTzyqoti34Fc6dcW36nnGIki7DHRDkglou8X6RyYq3DeyHGeCvcWad76je09VXFrew7mG9gyZldhORvlTtlv9iPq+634uu8KvALm6pOSUwon6EAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/TIL/static/bc786930723d940e745477093dcfd997/c54d4/tokenization.webp 175w,\n/TIL/static/bc786930723d940e745477093dcfd997/a3432/tokenization.webp 350w,\n/TIL/static/bc786930723d940e745477093dcfd997/426ac/tokenization.webp 700w,\n/TIL/static/bc786930723d940e745477093dcfd997/c139f/tokenization.webp 1050w,\n/TIL/static/bc786930723d940e745477093dcfd997/7f403/tokenization.webp 1400w,\n/TIL/static/bc786930723d940e745477093dcfd997/f6e07/tokenization.webp 1910w\" sizes=\"(max-width: 700px) 100vw, 700px\" type=\"image/webp\">\n          <source srcset=\"/TIL/static/bc786930723d940e745477093dcfd997/4edbd/tokenization.png 175w,\n/TIL/static/bc786930723d940e745477093dcfd997/13ae7/tokenization.png 350w,\n/TIL/static/bc786930723d940e745477093dcfd997/8c557/tokenization.png 700w,\n/TIL/static/bc786930723d940e745477093dcfd997/e996b/tokenization.png 1050w,\n/TIL/static/bc786930723d940e745477093dcfd997/2cefc/tokenization.png 1400w,\n/TIL/static/bc786930723d940e745477093dcfd997/460fa/tokenization.png 1910w\" sizes=\"(max-width: 700px) 100vw, 700px\" type=\"image/png\">\n          <img class=\"gatsby-resp-image-image\" src=\"/TIL/static/bc786930723d940e745477093dcfd997/8c557/tokenization.png\" alt=\"tokenization.png\" title=\"\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span>\n<p>이러한 토큰화 과정은 코드 하이라이팅 말고도, TypeScript언어로 JavaScript로 컴파일 할 때, 혹은 JavaScript를 추상구문트리(AST, Abstract Syntax Tree)로 변환할 때도 거치는 과정이다.</p>\n<h2 id=\"22-prismjs를-사용한-방법\" style=\"position:relative;\"><a href=\"#22-prismjs%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%B0%A9%EB%B2%95\" aria-label=\"22 prismjs를 사용한 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2. Prism.js를 사용한 방법</h2>\n<p>결과적으로 채택하지 않은 방법이기 때문에 원리만 간단히 설명하려고 한다.</p>\n<p>가장 쉽게 사용할 수 있는 Prism.js이다. <a href=\"https://www.gatsbyjs.com/plugins/gatsby-remark-prismjs/\">Gatsby와 연동되는 플러그인</a>이 있어 문서에 따라 <code>gatsby-config.js</code>파일만 작성해주면, <code>markdownRemark</code>노드를 만드는 과정에서 토큰화 과정도 함께 일어난다.</p>\n<p>한마디로 <code>markdownRemark.html</code>안에 <code>pre > code</code>내부 값이 모두 토큰화 된 채로, <code>dangerouslySetInnerHTML</code>에 전달되었다. 이제 할 일은 <mark>클래스 네임에 따라 color를 입히는 css파일</mark>만 적용하면 된다. 이는 <a href=\"https://www.npmjs.com/package/prismjs\">prismjs npm 패키지</a>를 설치하면 받을 수 있다.</p>\n<p>그런데 왜 Prism.js를 적용하지 않았냐? 하면 <strong>너어어어무 못생겼기 때문이다.</strong> <a href=\"https://prismjs.com/\">Prsim.js 공식 홈페이지</a>에 가면 스타일링을 미리 확인해볼 수도 있는데, 8가지 옵션이 있는데 하나같이 구리다. 그래서 갈아탔다.</p>\n<h2 id=\"23-highlightjs를-사용한-방법\" style=\"position:relative;\"><a href=\"#23-highlightjs%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%B0%A9%EB%B2%95\" aria-label=\"23 highlightjs를 사용한 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3. Highlight.js를 사용한 방법</h2>\n<p>그러던 중 <a href=\"https://highlightjs.org/\">Highlight.js</a>를 찾았다.<br>\n무려 스타일이 248개이다. 그리고 이따 보면 알겠지만, 생각보다 클래스가 많이 구분되지 않아 커스텀할 만하다.</p>\n<p>HighlightJS도 <a href=\"https://www.gatsbyjs.com/plugins/gatsby-remark-highlight.js/\">Gatsby 플러그인</a>이 있기는 한데, 어째 내용도 부실하고 v1.0도 출시가 안된 것이 조금 꺼림직하다. 그래서 [HighlightJS 공식문서]를 참고해서 토큰화 함수를 돌릴 것이다.</p>\n<ol>\n<li>\n<p><strong>highlight.js 설치</strong></p>\n<pre><code class=\"language-bash\">npm install highlight.js\n</code></pre>\n</li>\n<li>\n<p><strong>highligt.css 작성</strong><br>\n원래는 아까 highlight.js npm 패키지 설치 시, <code>node_modules/styles</code>경로에 CSS 파일이 스타일 옵션 별로 설치되었기 때문에 그냥 <code>import</code>헤서 쓰기만 하면 된다.</p>\n<p>그런데 문제는 다크모드를 지원하기 위해서는 CSS 파일을 조건에 따라 동적으로 <code>import</code>해야 한다는 것이다. 어떻게 이걸 해야할지 모르겠어서 그냥 2개의 CSS 파일을 복붙해다가 아래처럼 <code>highlight.css</code>파일을 만들었다.</p>\n<p>보면 <code>github-light</code>와 <code>github-dark</code>스타일을 가져왔는데, 하나는 스타일 전체를 각각 <code>.light</code> 선택자와 <code>.dark</code>선택자 안에 둬서 동적으로 적용되게 했다. 이게 가능한 이유는, 앞 서 <a href=\"#132-%EB%8B%A4%ED%81%AC%EB%AA%A8%EB%93%9C\">1.3.2. 다크모드</a> 항목에서 마크다운 최상단 태그에 <code>${theme}</code> 클래스를 넣어주었기 때문이다.</p>\n<pre><code class=\"language-css\">pre code.hljs {\n  display: block;\n  overflow-x: auto;\n  padding: 1em;\n}\ncode.hljs {\n  padding: 3px 5px;\n}\n\n.light {\n  /*\n Theme: GitHub\n Description: Light theme as seen on github.com\n Author: github.com\n Maintainer: @Hirse\n Updated: 2021-05-15\n */\n  .hljs {\n    color: #24292e;\n  }\n  .hljs-doctag,\n  .hljs-keyword,\n  .hljs-meta .hljs-keyword,\n  .hljs-template-tag,\n  .hljs-template-variable,\n  .hljs-type,\n  .hljs-variable.language_ {\n    color: #d73a49;\n  }\n  .hljs-title,\n  .hljs-title.class_,\n  .hljs-title.class_.inherited__,\n  .hljs-title.function_ {\n    color: #6f42c1;\n  }\n  ...;\n}\n\n.dark {\n  /*\n Theme: GitHub Dark\n Description: Dark theme as seen on github.com\n Author: github.com\n Maintainer: @Hirse\n Updated: 2021-05-15\n */\n  .hljs {\n    color: #c9d1d9;\n  }\n  .hljs-doctag,\n  .hljs-keyword,\n  .hljs-meta .hljs-keyword,\n  .hljs-template-tag,\n  .hljs-template-variable,\n  .hljs-type,\n  .hljs-variable.language_ {\n    color: #ff7b72;\n  }\n  .hljs-title,\n  .hljs-title.class_,\n  .hljs-title.class_.inherited__,\n  .hljs-title.function_ {\n    color: #d2a8ff;\n  }\n  ...;\n}\n</code></pre>\n</li>\n<li>\n<p><strong>highlightCode.js 파일 작성</strong><br>\nhiglightCode.js의 역할은 두 가지이다.</p>\n<ul>\n<li>코드를 토큰화한다.</li>\n<li>CSS 파일을 import 한다.</li>\n</ul>\n<p><a href=\"https://highlightjs.readthedocs.io/en/latest/api.html#highlightelement\">highligt.js 공식문서</a>를 보면 <code>highlightElement</code>로 특정 엘리먼틀를 잡아 토큰화할 수 있다고 한다. 나는 <code>pre > code</code>요소 만을 선택했는데, 그냥 <code>code</code>로 하면 in-line 코드 블록까지 선택된다.<br>\n또 <code>configure</code>에다가 <code>ignoreUnescapedHTML: true</code>를 설정해줬는데, JSX 구분을 토큰화할 때 <code>&#x3C;</code>와 <code>></code>요소 등에 대해 콘솔 창에 경고 문구를 띄우길래, 그냥 무시하겠다는 설정이다.</p>\n<pre><code class=\"language-js\">import hljs from 'highlight.js'\nimport '@styles/_highlight.scss' // CSS 파일\n\nhljs.configure({\n  ignoreUnescapedHTML: true,\n})\n\nexport default function highlightCode() {\n  const codeBlocks = document.querySelectorAll('pre > code') // 인라인 코드 블록은 제외\n  codeBlocks.forEach((codeBlock) => {\n    if (typeof codeBlock === 'object') {\n      hljs.highlightElement(codeBlock)\n    }\n  })\n}\n</code></pre>\n</li>\n<li>\n<p><strong>마운트 시 highlightCode.js 실행</strong><br>\n이제 작성한 highlightCode.js를 mount 되었을 떼 실행하면 된다. 지금은 Gatsby니가 Hydration 되었을 때 실행시킨다고 생각하면 더 적합할 것 같다.</p>\n<pre><code class=\"language-js\">import React, { useEffect, useContext } from 'react'\nimport from '@styles/_markdown.scss'\nimport type { PageProps } from 'gatsby'\nimport { ThemeContext } from '@contexts/theme-context'\nimport highlightCode from '@utils/highlightCode.ts'\n\nconst PostPage: React.FC&#x3C;PageProps> = ({ data }) => {\n  const { theme } = useContext(ThemeContext)\n\n  useEffect(() => {  // 마운트 되었을 때, highlightCode() 동작\n    highlightCode()\n  }, [])\n\n  return (\n    &#x3C;div\n      className={`markdown-body ${theme}`}\n      dangerouslySetInnerHTML={{ __html: data.markdownRemark.html }}\n    />\n  )\n}\n</code></pre>\n</li>\n</ol>\n<h1 id=\"3-참조\" style=\"position:relative;\"><a href=\"#3-%EC%B0%B8%EC%A1%B0\" aria-label=\"3 참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 참조</h1>\n<ul>\n<li><a href=\"https://www.gatsbyjs.com/docs/how-to/routing/adding-markdown-pages/\">Gatsby: Adding Markdown Pages</a></li>\n<li><a href=\"https://www.gatsbyjs.com/docs/how-to/routing/migrate-remark-to-mdx/\">Gatsby: Migrating Remark to MDX</a></li>\n<li><a href=\"https://github.com/sindresorhus/github-markdown-css\">Github Markdown CSS</a></li>\n<li><a href=\"https://www.gatsbyjs.com/plugins/gatsby-remark-prismjs/\">Gatsby Remark Prismjs</a></li>\n<li><a href=\"https://highlightjs.org/\">HighligtJS</a></li>\n<li><a href=\"https://highlightjs.readthedocs.io/en/latest/api.html#highlightelement\">HighlightJS Documentation</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%EC%8A%A4%ED%83%80%EC%9D%BC%EB%A7%81\">1. 마크다운 스타일링</a></p>\n<ul>\n<li>\n<p><a href=\"#11-graphql-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0\">1.1. GraphQL 불러오기</a></p>\n</li>\n<li>\n<p><a href=\"#12-dangerouslysetinnerhtml\">1.2. dangerouslySetInnerHTML</a></p>\n</li>\n<li>\n<p><a href=\"#13-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-css\">1.3. 마크다운 CSS</a></p>\n<ul>\n<li><a href=\"#131-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%EC%97%90%EB%A7%8C-%ED%95%9C%EC%A0%95-%EC%A0%81%EC%9A%A9\">1.3.1. 마크다운에만 한정 적용</a></li>\n<li><a href=\"#132-%EB%8B%A4%ED%81%AC%EB%AA%A8%EB%93%9C\">1.3.2. 다크모드</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-%EC%BD%94%EB%93%9C-%ED%95%98%EC%9D%B4%EB%9D%BC%EC%9D%B4%ED%8C%85\">2. 코드 하이라이팅</a></p>\n<ul>\n<li><a href=\"#21-%ED%86%A0%ED%81%B0%ED%99%94%EB%9E%80-tokenization\">2.1. 토큰화란? (Tokenization)</a></li>\n<li><a href=\"#22-prismjs%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%B0%A9%EB%B2%95\">2.2. Prism.js를 사용한 방법</a></li>\n<li><a href=\"#23-highlightjs%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%B0%A9%EB%B2%95\">2.3. Highlight.js를 사용한 방법</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-%EC%B0%B8%EC%A1%B0\">3. 참조</a></p>\n</li>\n</ul>","frontmatter":{"title":"09. Gatsby 마크다운(md) 스타일링","createdAt":"2023-06-29","updatedAt":"2023-06-29","tags":["gatsby","마크다운","CSS","코드 하이라이팅","highlight.js"],"description":" Gatsby의 마크다운 문서를 스타일링하고, 코드를 하아리이팅한다.","reference":null}},"allMarkdownRemark":{"nodes":[{"id":"94b436d7-15e2-57c6-8d40-52cf418e46e6","excerpt":"시작하기 앞서... Gatsby로 Markdown기반의 블로그를 만들려고 한다면, Gatsby 공식문서를 보는 것을 추천한다. 맞춤형 강의라고 해도 믿을 만큼 잘 정리되어 있기 때문이다. 때문에 나는 앞으로 Gatsby…","parent":{"id":"ce161dd8-00d5-50d2-8c0d-578dd75f7c94","name":"01_Gatsby","relativePath":"Frontend/Gatsby/01_Gatsby.md"},"frontmatter":{"title":"01. Gatsby 렌더링 옵션과 프로젝트 구조","createdAt":"2023-06-16","updatedAt":"2023-06-16"},"fields":{"slug":"/posts/Frontend/Gatsby/01_Gatsby/"}},{"id":"9aebcdb2-63dc-552b-b521-6c16e309d09b","excerpt":"1. 프론트엔드 배포란? 프론트엔드 배포를 한 마디로 정리하면, 특정 url을 통한 GET요청에 대해 index.html…","parent":{"id":"7fbea288-e615-5f15-96a9-d71745462e2c","name":"02_Github_Pages","relativePath":"Frontend/Gatsby/02_Github_Pages.md"},"frontmatter":{"title":"02. Gatsby 프로젝트 Github Pages 배포","createdAt":"2023-06-23","updatedAt":"2023-06-23"},"fields":{"slug":"/posts/Frontend/Gatsby/02_Github_Pages/"}},{"id":"3e2351da-7a0c-5c18-b503-c4358b27ab8f","excerpt":"1. import 경로 프로젝트를 진행하다 보면, import 절대경로를 설정하지 않을 수 없다.\n심지어 어쩌다가 한 번, IDE에서 자동 import…","parent":{"id":"cc5bee56-affb-555b-95d9-325b948e4870","name":"03_Import_Settings","relativePath":"Frontend/Gatsby/03_Import_Settings.md"},"frontmatter":{"title":"03. Gatsby 프로젝트(TypeScript) import 경로 설정","createdAt":"2023-06-24","updatedAt":"2023-06-24"},"fields":{"slug":"/posts/Frontend/Gatsby/03_Import_Settings/"}},{"id":"e2e850af-877e-5cc3-afc7-00362ed5273d","excerpt":"1. 개요 1.1. Prettier & ESLint란? Prettier와 ESLint는 각각 코드 포맷팅(Code Formatting)과 린팅(Linting…","parent":{"id":"8e077755-e170-50a6-a0b5-964d3835ef5d","name":"04_ESLint_Prettier","relativePath":"Frontend/Gatsby/04_ESLint_Prettier.md"},"frontmatter":{"title":"04. Gatsby 프로젝트 Prettier & ESLint & Husky 설정","createdAt":"2023-06-25","updatedAt":"2023-06-25"},"fields":{"slug":"/posts/Frontend/Gatsby/04_ESLint_Prettier/"}},{"id":"a0a6e020-13b3-5b8c-a3a9-731d0b01e16c","excerpt":"아래 내용은 주관적인 의견이고, 카카오 FE 기술 블로그의 내용을 참조했습니다. 1. Sass 다크모드 한동안 다크모드를 공부한 적이 있다. Styled Component와 같은 CSS-in-JS…","parent":{"id":"f070924b-4b2c-5a2e-ae60-efbd70ce23c9","name":"05_Dark_Mode","relativePath":"Frontend/Gatsby/05_Dark_Mode.md"},"frontmatter":{"title":"05. Gatsby 다크모드 구현하기 (feat. Sass)","createdAt":"2023-06-26","updatedAt":"2023-06-26"},"fields":{"slug":"/posts/Frontend/Gatsby/05_Dark_Mode/"}},{"id":"8dd7c7ba-002c-5398-92a5-b43faf1f595b","excerpt":"1. SSG 렌더링 React에서는 Nested Route로 손 쉽게 레이아웃을 구현할 수 있다. 그런데 Gatsby는 Single Page Application이 아니다! Gatsby는 정적 사이트 생성기(SSG)로 빌드 시에, 모든 url…","parent":{"id":"7dc89b39-7e64-5368-9d05-118f4f02d985","name":"06_Navigation_Layout","relativePath":"Frontend/Gatsby/06_Navigation_Layout.md"},"frontmatter":{"title":"06. Gatsby 네비게이션 레이아웃 설정","createdAt":"2023-06-27","updatedAt":"2023-06-27"},"fields":{"slug":"/posts/Frontend/Gatsby/06_Navigation_Layout/"}},{"id":"f2e3f78d-324e-5387-b630-101288184fae","excerpt":"1. 튜토리얼 방식의 한계 Gatsby 튜토리얼 Part6 를 보면 file system routes라고 해서 파일시스템에 있는 파일들에 대해서 동적으로 페이지를 생성하는 방법을 소개한다. 예를 들어 아래 그림처럼 src/pages/아래에 {mdx…","parent":{"id":"0384b347-d777-5cc3-943b-91771189a957","name":"07_Custom_Pages","relativePath":"Frontend/Gatsby/07_Custom_Pages.md"},"frontmatter":{"title":"07. Gatsby 커스텀 페이지 생성","createdAt":"2023-06-27","updatedAt":"2023-06-27"},"fields":{"slug":"/posts/Frontend/Gatsby/07_Custom_Pages/"}},{"id":"19ad15a7-720c-5daf-880f-06af0a704144","excerpt":"1. GraphQL 아직 GraphQL을 파일시스템에 대해서 밖에 사용하지 않아, 정확히 GraphQL이 뭔지는 감이 안잡힌다. 하지만 그 제한된 경험으로도 GrqphQL이 기존 API…","parent":{"id":"daf85c35-0844-5cdb-8909-f001a0714f75","name":"08_Diretory_Based_Category","relativePath":"Frontend/Gatsby/08_Diretory_Based_Category.md"},"frontmatter":{"title":"08. 폴더 구조 기반 Gatsby 카테고리 바 생성","createdAt":"2023-06-28","updatedAt":"2023-06-28"},"fields":{"slug":"/posts/Frontend/Gatsby/08_Diretory_Based_Category/"}},{"id":"6ae60c60-1e09-59a3-8a3c-f12ca9abd1c4","excerpt":"gatsby-transformer-remark플러그인을 통한 markdownRemark노드를 사용을 전제합니다. 1. 마크다운 스타일링 나는 분명 Gatsby 공식문서를 따라 gatsby-transformer-remark…","parent":{"id":"e5909625-6638-5137-b366-16bba9f61baf","name":"09_Markdown_Styling","relativePath":"Frontend/Gatsby/09_Markdown_Styling.md"},"frontmatter":{"title":"09. Gatsby 마크다운(md) 스타일링","createdAt":"2023-06-29","updatedAt":"2023-06-29"},"fields":{"slug":"/posts/Frontend/Gatsby/09_Markdown_Styling/"}},{"id":"187472ff-d02f-5104-9b2e-515b0b1898f2","excerpt":"1. URL 프래그먼트 식별자(#) 일단 프래그먼트 식별자(a.k.a. #)이 어떻게 동작하는 알 필요가 있다. 나는 평소 너무 당연하게 써왔지만, 어떻게 동작하는지는 한 번도 생각해보지 않았다. 사용자가 URL…","parent":{"id":"0a367c55-81a1-5059-8814-42d23ceac89a","name":"10_Table_of_Contents","relativePath":"Frontend/Gatsby/10_Table_of_Contents.md"},"frontmatter":{"title":"10. Gatsby 스크롤 반응형 목차(TOC) 생성","createdAt":"2023-06-30","updatedAt":"2023-06-30"},"fields":{"slug":"/posts/Frontend/Gatsby/10_Table_of_Contents/"}},{"id":"1e126097-6df5-5927-8c17-282ca0974e45","excerpt":"1. Utterances와 Giscus 따로 서버를 돌리지 않고서는 댓글/좋아요 기능을 구현할 수 없을 줄 알았다. 그런데 항상 개발자들은 신박한 방법을 찾아낸다. GitHub API…","parent":{"id":"86d49b0e-e662-5a09-8fa5-8d69829c899f","name":"11_utterances_giscus","relativePath":"Frontend/Gatsby/11_utterances_giscus.md"},"frontmatter":{"title":"11. Gatsby 댓글 및 좋아요 기능","createdAt":"2023-07-02","updatedAt":"2023-07-02"},"fields":{"slug":"/posts/Frontend/Gatsby/11_utterances_giscus/"}}]}},"pageContext":{"pagePath":"/posts/Frontend/Gatsby/09_Markdown_Styling/","siblingPostsPathRegex":"/^(?!.*README).*Frontend\\/Gatsby.*$/","relativeDirectory":"Gatsby","id":"6ae60c60-1e09-59a3-8a3c-f12ca9abd1c4","parent":{"id":"e5909625-6638-5137-b366-16bba9f61baf","name":"09_Markdown_Styling","relativePath":"Frontend/Gatsby/09_Markdown_Styling.md"},"fields":{"slug":"/posts/Frontend/Gatsby/09_Markdown_Styling/"}}},"staticQueryHashes":["24302420","4059933791"],"slicesMap":{}}