{"componentChunkName":"component---src-templates-post-index-tsx","path":"/posts/Frontend/Gatsby/06_Navigation_Layout.md/","result":{"data":{"markdownRemark":{"id":"8dd7c7ba-002c-5398-92a5-b43faf1f595b","html":"<h1 id=\"1-ssg-렌더링\" style=\"position:relative;\"><a href=\"#1-ssg-%EB%A0%8C%EB%8D%94%EB%A7%81\" aria-label=\"1 ssg 렌더링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. SSG 렌더링</h1>\n<p>React에서는 Nested Route로 손 쉽게 레이아웃을 구현할 수 있다. <strong>그런데 Gatsby는 Single Page Application이 아니다!</strong> Gatsby는 정적 사이트 생성기(SSG)로 빌드 시에, 모든 url 경로에 대한 index.html을 작성하고 사용자가 요청하면 해당 index.html을 반환한다. 다시 말해서 <mark>클라이언트는 매 페이지(url)마다 독립된 index.html을 제공받는다.</mark></p>\n<p><a href=\"https://www.gatsbyjs.com/docs/how-to/routing/layout-components/\">Gatsby 공식문서</a>에서도 이를 명확하게 말하고 있다.</p>\n<blockquote>\n<p>As mentioned earlier, Gatsby does not, by default, automatically wrap pages in a layout component. The “top level” component is the page itself. As a result, when the “top level” component changes between pages, React will re-render all children. This means that shared components like navigations will unmount and remount.</p>\n</blockquote>\n<p>다행히 이어서 바로 해결방법도 제시한다. Browser API &#x26; SSR API의 <code>wrapPageElement</code>를 사용하면 된다고 한다.</p>\n<blockquote>\n<p>If you need to set a wrapper component around page components that won’t get unmounted on page changes, use the wrapPageElement browser API and the SSR equivalent.</p>\n</blockquote>\n<h1 id=\"11-navigation-layout\" style=\"position:relative;\"><a href=\"#11-navigation-layout\" aria-label=\"11 navigation layout permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1. Navigation Layout</h1>\n<p>일단 먼저 Layout Component를 작성한다. 나늠 다음과 같이 작성했다.</p>\n<pre><code class=\"language-js\">import React from 'react'\nimport Footer from '@components/footer'\nimport Navigation from '@components/navigation'\n\ninterface Props {\n  children: React.ReactNode;\n}\n\nconst NavigationLayout: React.FC&#x3C;Props> = ({ children }) => {\n  return (\n    &#x3C;div>\n      &#x3C;Navigation />\n      {children}\n      &#x3C;Footer />\n    &#x3C;/div>\n  )\n}\n\nexport default NavigationLayout\n</code></pre>\n<h1 id=\"12-wrappageelement\" style=\"position:relative;\"><a href=\"#12-wrappageelement\" aria-label=\"12 wrappageelement permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2. WrapPageElement</h1>\n<p>그리고 gatsby-browser파일에 다음처럼 코드를 작성하기만 하면 된다. 좀 특이했던 것은 jsx 문법을 사용해야하기 때문에</p>\n<ul>\n<li><code>import React from 'react</code> 구문을 넣고</li>\n<li>파일 이름을 <code>gatsby-browser.ts</code>에서 <code>gatsby-browser.tsx</code>로 바꿔야 했다.</li>\n</ul>\n<p>SSR APIs에도 동일한 <code>wrapPageElement</code>가 있기 때문에, 본인의 프로젝트가 SSR 렌더링을 사용한다면 gatsby-ssr에도 같은 코드를 입력하면 된다.</p>\n<pre><code class=\"language-js\">import React from 'react'\nimport NavigationLayout from '@layouts/navigation-layout'\n\nexport const wrapPageElement = ({ element, props }) => {\n  return &#x3C;NavigationLayout {...props}>{element}&#x3C;/NavigationLayout>\n}\n</code></pre>\n<p>이렇게 되면 해당 Layout Component가 항상 페이지를 감싸기 때문에 Page Component에서 따로 Layout과 관련된 코드를 넣지 않아도 된다.</p>\n<pre><code class=\"language-js\">import * as React from 'react'\n\nconst IndexPage: React.FC&#x3C;PageProps> = () => {\n  return &#x3C;div>Home Page&#x3C;/div>\n}\n\nexport default IndexPage\n\nexport const Head: HeadFC = () => &#x3C;title>Home Page&#x3C;/title>\n</code></pre>\n<h1 id=\"2-참조\" style=\"position:relative;\"><a href=\"#2-%EC%B0%B8%EC%A1%B0\" aria-label=\"2 참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 참조</h1>\n<ul>\n<li><a href=\"https://www.gatsbyjs.com/docs/how-to/routing/layout-components/\">Gatsby Layout Components</a></li>\n<li><a href=\"https://www.gatsbyjs.com/docs/reference/config-files/gatsby-browser/\">Gatsby Browser APIs</a></li>\n</ul>","tableOfContents":"<ul>\n<li><a href=\"#1-ssg-%EB%A0%8C%EB%8D%94%EB%A7%81\">1. SSG 렌더링</a></li>\n<li><a href=\"#11-navigation-layout\">1.1. Navigation Layout</a></li>\n<li><a href=\"#12-wrappageelement\">1.2. WrapPageElement</a></li>\n<li><a href=\"#2-%EC%B0%B8%EC%A1%B0\">2. 참조</a></li>\n</ul>","frontmatter":{"title":"06. Gatsby 네비게이션 레이아웃 설정","createdAt":"2023-06-27","updatedAt":"2023-06-27","tags":["gatsby","layout","레이아웃","navigation","네비게이션"],"description":"SSG 기반 Gatsby 프로젝트에서 unmount되지 않는 네비게이션 레이아웃을 만든다.","reference":null}},"allMarkdownRemark":{"nodes":[{"id":"94b436d7-15e2-57c6-8d40-52cf418e46e6","parent":{"id":"ce161dd8-00d5-50d2-8c0d-578dd75f7c94","name":"01_Gatsby","relativePath":"Frontend/Gatsby/01_Gatsby.md"},"frontmatter":{"title":"01. Gatsby 렌더링 옵션과 프로젝트 구조","createdAt":"2023-06-16","updatedAt":"2023-06-16"},"excerpt":"시작하기 앞서... Gatsby로 Markdown기반의 블로그를 만들려고 한다면, Gatsby 공식문서를 보는 것을 추천한다. 맞춤형 강의라고 해도 믿을 만큼 잘 정리되어 있기 때문이다. 때문에 나는 앞으로 Gatsby…"},{"id":"9aebcdb2-63dc-552b-b521-6c16e309d09b","parent":{"id":"7fbea288-e615-5f15-96a9-d71745462e2c","name":"02_Github_Pages","relativePath":"Frontend/Gatsby/02_Github_Pages.md"},"frontmatter":{"title":"02. Gatsby 프로젝트 Github Pages 배포","createdAt":"2023-06-23","updatedAt":"2023-06-23"},"excerpt":"1. 프론트엔드 배포란? 프론트엔드 배포를 한 마디로 정리하면, 특정 url을 통한 GET요청에 대해 index.html…"},{"id":"3e2351da-7a0c-5c18-b503-c4358b27ab8f","parent":{"id":"cc5bee56-affb-555b-95d9-325b948e4870","name":"03_Import_Settings","relativePath":"Frontend/Gatsby/03_Import_Settings.md"},"frontmatter":{"title":"03. Gatsby 프로젝트(TypeScript) import 경로 설정","createdAt":"2023-06-24","updatedAt":"2023-06-24"},"excerpt":"1. import 경로 프로젝트를 진행하다 보면, import 절대경로를 설정하지 않을 수 없다.\n심지어 어쩌다가 한 번, IDE에서 자동 import…"},{"id":"e2e850af-877e-5cc3-afc7-00362ed5273d","parent":{"id":"8e077755-e170-50a6-a0b5-964d3835ef5d","name":"04_ESLint_Prettier","relativePath":"Frontend/Gatsby/04_ESLint_Prettier.md"},"frontmatter":{"title":"04. Gatsby 프로젝트 Prettier & ESLint & Husky 설정","createdAt":"2023-06-25","updatedAt":"2023-06-25"},"excerpt":"1. 개요 1.1. Prettier & ESLint란? Prettier와 ESLint는 각각 코드 포맷팅(Code Formatting)과 린팅(Linting…"},{"id":"a0a6e020-13b3-5b8c-a3a9-731d0b01e16c","parent":{"id":"f070924b-4b2c-5a2e-ae60-efbd70ce23c9","name":"05_Dark_Mode","relativePath":"Frontend/Gatsby/05_Dark_Mode.md"},"frontmatter":{"title":"05. Gatsby 다크모드 구현하기 (feat. Sass)","createdAt":"2023-06-26","updatedAt":"2023-06-26"},"excerpt":"아래 내용은 주관적인 의견이고, 카카오 FE 기술 블로그의 내용을 참조했습니다. 1. Sass 다크모드 한동안 다크모드를 공부한 적이 있다. Styled Component와 같은 CSS-in-JS…"},{"id":"8dd7c7ba-002c-5398-92a5-b43faf1f595b","parent":{"id":"7dc89b39-7e64-5368-9d05-118f4f02d985","name":"06_Navigation_Layout","relativePath":"Frontend/Gatsby/06_Navigation_Layout.md"},"frontmatter":{"title":"06. Gatsby 네비게이션 레이아웃 설정","createdAt":"2023-06-27","updatedAt":"2023-06-27"},"excerpt":"1. SSG 렌더링 React에서는 Nested Route로 손 쉽게 레이아웃을 구현할 수 있다. 그런데 Gatsby는 Single Page Application이 아니다! Gatsby는 정적 사이트 생성기(SSG)로 빌드 시에, 모든 url…"},{"id":"f2e3f78d-324e-5387-b630-101288184fae","parent":{"id":"0384b347-d777-5cc3-943b-91771189a957","name":"07_Custom_Pages","relativePath":"Frontend/Gatsby/07_Custom_Pages.md"},"frontmatter":{"title":"07. Gatsby 커스텀 페이지 생성","createdAt":"2023-06-27","updatedAt":"2023-06-27"},"excerpt":"1. 튜토리얼 방식의 한계 Gatsby 튜토리얼 Part6 를 보면 file system routes라고 해서 파일시스템에 있는 파일들에 대해서 동적으로 페이지를 생성하는 방법을 소개한다. 예를 들어 아래 그림처럼 src/pages/아래에 {mdx…"},{"id":"19ad15a7-720c-5daf-880f-06af0a704144","parent":{"id":"daf85c35-0844-5cdb-8909-f001a0714f75","name":"08_Diretory_Based_Category","relativePath":"Frontend/Gatsby/08_Diretory_Based_Category.md"},"frontmatter":{"title":"08. 폴더 구조 기반 Gatsby 카테고리 바 생성","createdAt":"2023-06-28","updatedAt":"2023-06-28"},"excerpt":"1. GraphQL 아직 GraphQL을 파일시스템에 대해서 밖에 사용하지 않아, 정확히 GraphQL이 뭔지는 감이 안잡힌다. 하지만 그 제한된 경험으로도 GrqphQL이 기존 API…"}]}},"pageContext":{"pagePath":"posts/Frontend/Gatsby/06_Navigation_Layout.md","regex":"/^(?!.*README).*Frontend\\/Gatsby.*$/","relativeDirectory":"Gatsby","id":"8dd7c7ba-002c-5398-92a5-b43faf1f595b","parent":{"id":"7dc89b39-7e64-5368-9d05-118f4f02d985","name":"06_Navigation_Layout","relativePath":"Frontend/Gatsby/06_Navigation_Layout.md"}}},"staticQueryHashes":["3300660363","3571427910"],"slicesMap":{}}