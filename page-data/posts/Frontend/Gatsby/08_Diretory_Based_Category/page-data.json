{"componentChunkName":"component---src-templates-post-index-tsx","path":"/posts/Frontend/Gatsby/08_Diretory_Based_Category/","result":{"data":{"markdownRemark":{"id":"19ad15a7-720c-5daf-880f-06af0a704144","html":"<h1 id=\"1-graphql\" style=\"position:relative;\"><a href=\"#1-graphql\" aria-label=\"1 graphql permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. GraphQL</h1>\n<p>아직 GraphQL을 파일시스템에 대해서 밖에 사용하지 않아, 정확히 GraphQL이 뭔지는 감이 안잡힌다. 하지만 그 제한된 경험으로도 GrqphQL이 기존 API방식과 많이 다르다는 것을 체감하기는 충분했다.</p>\n<ul>\n<li>\n<p><strong>장점</strong><br>\n<mark>작성되지 않은 API에 대해서도 데이터를 받을 수 있다.</mark> 벌써 파일시스템도 설계된 API 없이 모든 정보를 받아올 수 있다. 반면 백엔드를 통해 데이터베이스와 연결된 요청에 대해서는 어떻게 동작하는지 미지수이다.</p>\n</li>\n<li>\n<p><strong>단점</strong><br>\n<mark>원하는 형식으로 데이터를 받을 수 없다.</mark> GraphQL의 장점으로 프론트엔드가 원하는대로 데이터를 골라받을 수 있다고 하는데, 이건 정말 <strong>원하는 데이터만을 골라 받는거지, 원하는 형식으로 주는 것은 아니다.</strong> 때문에 프론트엔드가 데이터를 받아 직접 가공해야 한다.</p>\n</li>\n</ul>\n<h1 id=\"2-폴더구조-기반-카테고리\" style=\"position:relative;\"><a href=\"#2-%ED%8F%B4%EB%8D%94%EA%B5%AC%EC%A1%B0-%EA%B8%B0%EB%B0%98-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC\" aria-label=\"2 폴더구조 기반 카테고리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 폴더구조 기반 카테고리</h1>\n<p>블로그를 생성하기 전, 나는 TIL 레포지토리의 마크다운 파일들을 다음과 같이 중첩된 디렉토리 구조로 관리하고 있었다(아마 대부분 그렇겠지만...). 그래서 아래 그림과 같이, 나는 이 폴더구조가 곧 카테고리 바가 되길 바랬다.아마 누구나 처음 그렇게 생각하지 않을까?</p>\n<table>\n<thead>\n<tr>\n<th><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 481px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/d563abf6bd025dd0763731fe1f1ee763/d024a/posts-directory-structure.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 132.57142857142858%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAABJ0AAASdAHeZh94AAACBklEQVR42q2V2Y6bMBSG8xANBmPANmE13oCMptNqNFLV93+kv7KTTKtuZJJcHMVXH//i4+yOxy94ff2Gt7fvWJdneP+EZXm+adb1M3Zt28Maj5eXr5jnI4xxqGWDuv74HJoOuyzLUBQF5tnDeQ+jNQhJkCT7D84npCnBLs9zCCEwTRP6vkfXdaBZhjRNPzyU0hOQc4GmaUAIQULITbB3IM0pGCuglIKUAvt9cieQUuR5gXEYYYzGNCkwliNkSzOKLM3i+TL/BpJfgTmatoFzHtYYJEmC/X4f5/fz/xSGD+5CAbSscBg1rD4pHEcF7xwmrWNR1rnooK7rDZVpAKagXKI1M8a+wzAMmP0c1XrvI6SWNer6ACnEZo4RmFcBuEArBa01lnmBMQbWGjDGUJZl/A3xXAEMljnayUJPCsPQR5XR+jCga/tzWROGvt8GhkKKosSkFOZljtfnUkS4lyQhSM6FkCvu6HlTeLQ4DGO0GWxXVXUV4C9ABikk1nWF8w68qs553bZ+J4VSQqkRVVUiS9OblP0BDKFzXt0MegcGe5xzWGsj9G7g5bUJRRQF29yEbSBjEELGu+acg7Hm/gyDwgALKnNKQe61LGUN52ccDvUjMmTgQsBYG9fuIaWEDMMfVFi7e/L7WQrn8cqUZRF39wEKRdzlcCbkEZalwLLM8ZHYeua3gD8AFhHR9050jM4AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/TIL/static/d563abf6bd025dd0763731fe1f1ee763/c54d4/posts-directory-structure.webp 175w,\n/TIL/static/d563abf6bd025dd0763731fe1f1ee763/a3432/posts-directory-structure.webp 350w,\n/TIL/static/d563abf6bd025dd0763731fe1f1ee763/1c567/posts-directory-structure.webp 481w\" sizes=\"(max-width: 481px) 100vw, 481px\" type=\"image/webp\">\n          <source srcset=\"/TIL/static/d563abf6bd025dd0763731fe1f1ee763/4edbd/posts-directory-structure.png 175w,\n/TIL/static/d563abf6bd025dd0763731fe1f1ee763/13ae7/posts-directory-structure.png 350w,\n/TIL/static/d563abf6bd025dd0763731fe1f1ee763/d024a/posts-directory-structure.png 481w\" sizes=\"(max-width: 481px) 100vw, 481px\" type=\"image/png\">\n          <img class=\"gatsby-resp-image-image\" src=\"/TIL/static/d563abf6bd025dd0763731fe1f1ee763/d024a/posts-directory-structure.png\" alt=\"posts-directory-structure.png\" title=\"\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span></th>\n<th><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 373px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/70067e0c562173d6eb6c03dd210a8f2f/67a5d/posts-category-bar.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 241.71428571428572%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAwCAYAAAARtFotAAAACXBIWXMAABJ0AAASdAHeZh94AAADY0lEQVR42q2XWU8qQRCF+f9/QV540ISggkhcExQENO4iihubCCouqLgL1s1XSRNwrjI9StI609OcOVV16nTjkz/6tNttHT7+nJ6eSqVSkcvLS6nX61Kr1eTm5kYXfn5+ugb8+PgQX6fTkWazKa1WS66urvT68fFRnp6erBkqIDfv7+9dRlw/PDwoMxYBzkutAIvFogQCAQkGgxKLxWR0dFSmpqbk4OBAZmdnlfWg8PsAWfj6+ip3d3f6AJZvb2+64OXlxZ5hqVSSiYkJSaVSkkwmZXp6WhYWFqRarcrh4aEWzYohLBqNhlb44uJCzs/PFeT+/l7DJadWDJHLysqKguXzec2pjWQcgNfX17K1taWy2dnZ0TB/BciHouRyOQ2RgvSG6QbYAQjLoaEhZbi9va0p8Cxsw4JJ/n8dyGgQSwcg/YuYI5GIpNNplc7MzIz2OHIiJT+F7wDkhvZDPuSRFyCj29tbvX5+ftZBKyKzgYB0A3nEJABG1Mjn5ORE9vf3FZQGoB2Z/8r0v4A4DKEhaDQJU+ZMLntz7Joh7OgUBA4j5txIxwGI9mBGRc1DhjEKa9lQAL/fL9FoVCs8NjYmu7u7sr6+rto0Ubi2LxYzYEQ1eWjmWGzlNlRufn5eEomEsoFlNptVPW5sbMjy8rJWdm1t7dvwHfaF4yBiinB2dqYDqWBjhUKhKyW+NBAQoNXVVTk+Ppa9vT3NJy/ALEiBdS+jOcIlvLm5OQUGEJMwXfGd/hyApiC0FBOmIF42+i5DchMOh7U4FIUUDJLJj4BcGDcx7IxkPAEeHR2pdSHo4eFhlQdMNzc3vTk2TLB88ogheDmO9AGiMfZjbB8Bs2EZU+Bl1gypLCKmOMZtmPNcZb5MZ8AK2yqXy8qUwQt4ZgXImYaQM5mMxONxDX1paUl7GE90U5w+QHyQvYNCmB0OEzBSsg6ZVkM24+PjMjk5qR7I6YFeditwhx/CyBzlzEPPwkbEoVBIjYE9mLyRQ+N91rLhBhEjaCpO7thOPTPEDBYXF9WuyB8yIYdGi9YMYWO6BEB6G5P1DEiodAnHECSELhm/6hTO1EgHqcDQ9tDp2KR6/fDPHJu2Y/ukBX91JDa/U5hAe253uh9/p4yMjGjrIRnETXE85xBGaBHbQkJ4o40x9AL+A1JKesBbfalYAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/TIL/static/70067e0c562173d6eb6c03dd210a8f2f/c54d4/posts-category-bar.webp 175w,\n/TIL/static/70067e0c562173d6eb6c03dd210a8f2f/a3432/posts-category-bar.webp 350w,\n/TIL/static/70067e0c562173d6eb6c03dd210a8f2f/48a24/posts-category-bar.webp 373w\" sizes=\"(max-width: 373px) 100vw, 373px\" type=\"image/webp\">\n          <source srcset=\"/TIL/static/70067e0c562173d6eb6c03dd210a8f2f/4edbd/posts-category-bar.png 175w,\n/TIL/static/70067e0c562173d6eb6c03dd210a8f2f/13ae7/posts-category-bar.png 350w,\n/TIL/static/70067e0c562173d6eb6c03dd210a8f2f/67a5d/posts-category-bar.png 373w\" sizes=\"(max-width: 373px) 100vw, 373px\" type=\"image/png\">\n          <img class=\"gatsby-resp-image-image\" src=\"/TIL/static/70067e0c562173d6eb6c03dd210a8f2f/67a5d/posts-category-bar.png\" alt=\"posts-category-bar.png\" title=\"\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span></th>\n</tr>\n</thead>\n</table>\n<p>결론만 말하면 <strong>그냥 코딩테스트마냥 구현 알고리즘을 만들었다.</strong> GraphQL에 대해서 설명한 이유가 이것이다. 데이터가 원하는 대로 오지 않으면, 가공하면 그만이다. 그나마 다행인 점은, 렌더링 속도 측면에서 시간복잡도를 고려할 필요는 없다는 것이다. SSG 방식이기 때문에 어차피 빌드 시에 렌더링이 완성되기 때문이다.</p>\n<h2 id=\"21-fragments--usestaticquery\" style=\"position:relative;\"><a href=\"#21-fragments--usestaticquery\" aria-label=\"21 fragments  usestaticquery permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. fragments &#x26; useStaticQuery</h2>\n<p>Gatsby는 기본적으로 페이지 단위의 Query로 동작한다. 빌드 시에 모든 페이지에 대한 index.html을 렌더링하는 SSG 특징 때문인 것 같다. 하지만 프로젝트의 크기가 커지고, 컴포넌트가 분리되면 페이지 쿼리에서 모든 데이터를 불러오는게 말처럼 쉽지가 않다. 일단 query문 자체가 무지막지하게 길어질 것이다.</p>\n<p><strong>Gatsby는 페이지 쿼리를 분리해서 개별 컴포넌트에서 관리하기 위해 두 가지 기능을 제공한다.</strong> 바로 <a href=\"https://www.gatsbyjs.com/docs/conceptual/graphql-concepts/#fragments\">fragments</a>와 <a href=\"https://www.gatsbyjs.com/docs/how-to/querying-data/use-static-query/\">useStaticQuery</a>이다. 이 둘의 목적만 간략하게 정리하면 다음과 같다. 구체적인 예시는 위 링크를 통해 공식문서에서 확인할 수 있다.</p>\n<ul>\n<li>\n<p><strong>fragments</strong></p>\n<ul>\n<li><strong>페이지에 종속적인 쿼리 데이터를 컴포넌트에서 관리할 수 있다.</strong></li>\n<li>컴포넌트에 선언된 fragment는 최종적으로 페이지 쿼리문에 삽입되어야 한다.</li>\n</ul>\n</li>\n<li>\n<p><strong>useStaticQuery</strong></p>\n<ul>\n<li><strong>페이지에 독립적인 정적 쿼리문을 컴포너트에서 관리할 수 있다.</strong></li>\n<li>정적인 쿼리문이기 때문에 외부로부터 인자를 받지 못한다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"21-usestaticquery-hook\" style=\"position:relative;\"><a href=\"#21-usestaticquery-hook\" aria-label=\"21 usestaticquery hook permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. useStaticQuery Hook</h2>\n<p>카테고리 바를 구현하기 위해, 나는 <code>useStaticQuery</code>를 사용했다. <strong>디렉토리 구조라고 하는 것은, 페이지 url과는 상관없는 독립적이고 정적인 데이터이기 때문이다.</strong></p>\n<p>그리고 <a href=\"https://www.gatsbyjs.com/docs/how-to/querying-data/use-static-query/#composing-custom-usestaticquery-hooks\">공식문서</a>를 보면, <mark><code>useStaticQuery</code>를 하나의 hook으로 관리하여 여러 컴포넌트에서 재사용하기를 권장한다.</mark> 여기서 말하는 hook이란, 정적인 데이터를 불러와 원하는 형태로 가공하여 제공하는 역할을 한다.</p>\n<p>그렇게 내가 만든 <code>useCategorizedPosts</code>는 다음과 같다.</p>\n<pre><code class=\"language-js\">import { graphql, useStaticQuery } from 'gatsby'\n\n// 마크다운 파일 정보\ninterface Post {\n  id: string\n  title: string\n  relativePath: string\n}\n\n// 카테고리(디렉토리) 정보\ninterface Directory {\n  name: string\n  posts: Post[]\n  nums: number\n  folders: Directory[]\n}\n\ninterface Returns {\n  totalPosts: number // 전체 포스트 수\n  categories: Directory[] // 카테고리(디렉토리) 정보 배열\n}\n\nexport const useCategorizedPosts = (): Returns => {\n  // 마크다운 파일 수집\n  // 조건 1. isCompleted: true\n  // 조건 2. README.md 제외\n  // 조건 3. posts 디렉토리 하위\n  const data = useStaticQuery(graphql`\n    query {\n      allMarkdownRemark(\n        filter: {\n          frontmatter: { isCompleted: { eq: true } }\n          fileAbsolutePath: { regex: \"/^(?!.*README).*posts.*$/\" }\n        }\n        sort: { frontmatter: { title: ASC } }\n      ) {\n        nodes {\n          id\n          parent {\n            ... on File {\n              id\n              name\n              relativePath\n            }\n          }\n          frontmatter {\n            title\n          }\n        }\n      }\n    }\n  `)\n\n  const totalPosts = data.allMarkdownRemark.nodes.length // 전체 포스트 수\n\n  // 마크다운 파일 순회하며 카테고리 분류\n  const categories = []\n  data.allMarkdownRemark.nodes.forEach((post) => {\n    // 데이터 분해\n    const { id, parent, frontmatter } = post\n    const { name, relativePath } = parent\n    const { title } = frontmatter\n\n    // 카테고리 분류를 위해 상대 경로를 배열로 변환\n    const pathArray = relativePath.split('/')\n\n    // 루트 카테고리 분류\n    const rootCategoryName = pathArray[0]\n    let rootCategory = categories.find(\n      (category) => category.name === rootCategoryName\n    )\n    if (!rootCategory) {\n      // 루트 카테고리가 없을 경우, 새로 생성\n      const newCategory = {\n        name: rootCategoryName,\n        num: 1,\n        posts: [],\n        subCategories: [],\n      }\n      categories.push(newCategory)\n      rootCategory = newCategory\n    } else {\n      // 루트 카테고리가 있을 경우, 갯수만 업데이트\n      rootCategory.num += 1\n    }\n\n    // 서브 카테고리 분류\n    let parentCategory = rootCategory // 상대 경로 배열을 순회하며, 부모 디렉토리 재할당\n    pathArray.slice(1, -1).forEach((subCategoryName) => {\n      let subCategory = parentCategory.subCategories.find(\n        (category) => category.name === subCategoryName\n      )\n      if (!subCategory) {\n        // 서브 카테고리가 없을 경우, 새로 생성\n        const newCategory = {\n          name: subCategoryName,\n          num: 1,\n          posts: [],\n          subCategories: [],\n        }\n        parentCategory.subCategories.push(newCategory)\n        subCategory = newCategory\n      } else {\n        // 서브 카테고리가 있을 경우, 새로 생성\n        subCategory.num += 1\n      }\n      parentCategory = subCategory\n    })\n\n    // 포스트 삽입\n    parentCategory.posts.push({ id, title, name, relativePath })\n  })\n\n  return { totalPosts, categories }\n}\n</code></pre>\n<h2 id=\"23-카테고리-컴포넌트\" style=\"position:relative;\"><a href=\"#23-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\" aria-label=\"23 카테고리 컴포넌트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3. 카테고리 컴포넌트</h2>\n<p>카테고리 컴포넌트는, 위에서 만든 <code>useCategorizedPosts</code>훅에서 데이터를 받아 렌더링한다.</p>\n<p>재귀 형식으로 렌더링을 표현할 수 없어 렌더링 부분이 조금 지저분한다. 같은 이유로 카테고리의 depth를 무한정 늘리지는 못하고, 3depth 까지만 렌더링 할 수 있도록 제한했다.</p>\n<p>또한 선택된 카테고리 <code>selectedCategory</code>가 바뀔 때마다, 서브 컴포넌트 <code>CategoryName</code>와 <code>Posts</code>가 불필요하게 렌더링되지 않도로고 <code>React.memo()</code>를 사용했다.</p>\n<pre><code class=\"language-js\">import React, { useState, useRef, useEffect } from 'react'\nimport './style.scss'\nimport { Link } from 'gatsby'\nimport { useCategorizedPosts } from '@hooks/use-categorized-posts' // 혹에서 데이터를 받아온다.\n\ninterface Props {\n  defaultCategory?: string; // 기본으로 선택된 카테고리\n}\n\n// 최대 3단계 카테고리까지만(루트 카테고리 포함) 지원\nconst Category: React.FC&#x3C;Props> = ({ defaultCategory = '' }) => {\n  const { totalPosts, categories } = useCategorizedPosts()\n  const [selectedCategory, setSelectedCategory] = useState(defaultCategory)\n\n  // 카테고리 클릭 이벤트 처리\n  const handleClickCategory = (event, name) => {\n    if (event.detail > 1) return // 더블 클릭 이상이면 Link 동작\n    event.preventDefault() // 한번 클릭이면 Link 이동 막고, selecedCategory 토글\n    setSelectedCategory(selectedCategory === name ? '' : name)\n  }\n\n  return (\n    &#x3C;nav className=\"sidebar\">\n      &#x3C;div className=\"sidebar__total\">{`전체 글 (${totalPosts})`}&#x3C;/div>\n      &#x3C;ul className=\"sidebar__category\">\n        {/* 루트 카테고리 */}\n        {categories.map((category) => (\n          &#x3C;li key={category.name}>\n            &#x3C;CategoryName\n              name={category.name}\n              num={category.num}\n              handleClickCategory={handleClickCategory}\n            />\n            &#x3C;ul className=\"sidebar__category\">\n              {/* 서브 카테고리 1 */}\n              {category.subCategories.map((subCategory) => (\n                &#x3C;li key={subCategory.name}>\n                  &#x3C;CategoryName\n                    name={subCategory.name}\n                    num={subCategory.num}\n                    handleClickCategory={handleClickCategory}\n                  />\n                  &#x3C;ul className=\"sidebar__category\">\n                    {/* 서브 카테고리 2 */}\n                    {subCategory.subCategories.map((subCategory) => (\n                      &#x3C;li key={subCategory.name}>\n                        &#x3C;CategoryName\n                          name={subCategory.name}\n                          num={subCategory.num}\n                          handleClickCategory={handleClickCategory}\n                        />\n                        {/* 서브 카테고리 2 포스트 */}\n                        &#x3C;Posts\n                          posts={subCategory.posts}\n                          isSelected={selectedCategory === subCategory.name}\n                        />\n                      &#x3C;/li>\n                    ))}\n                  &#x3C;/ul>\n                  {/* 서브 카테고리 1 포스트 */}\n                  &#x3C;Posts\n                    posts={subCategory.posts}\n                    isSelected={selectedCategory === subCategory.name}\n                  />\n                &#x3C;/li>\n              ))}\n            &#x3C;/ul>\n            {/* 루트 카테고리 포스트 */}\n            &#x3C;Posts\n              posts={category.posts}\n              isSelected={selectedCategory === category.name}\n            />\n          &#x3C;/li>\n        ))}\n      &#x3C;/ul>\n    &#x3C;/nav>\n  )\n}\n\nexport default Category\n\n// &#x3C;카테고리 이름> 서브 컴포넌트\nconst CategoryName: React.FC = React.memo(\n  ({ name, num, handleClickCategory }) => {\n    return (\n      &#x3C;Link\n        to={`/posts/${name}`}\n        className=\"sidebar__category--text\"\n        onClick={(event) => {\n          handleClickCategory(event, name)\n        }}\n      >\n        {`${name}\\u00a0\\u00a0(${num})`}\n      &#x3C;/Link>\n    )\n  }\n)\n\n// &#x3C;포스트 목록> 서브 컴포넌트\nconst Posts: React.FC = React.memo(({ posts, isSelected }) => {\n  const postsRef = useRef &#x3C; HTMLUListElement > null\n\n  // css를 위한 변수 전달\n  useEffect(() => {\n    const postsEle = postsRef.current\n    postsEle &#x26;&#x26;\n      postsEle.style.setProperty('--posts-count', posts.length.toString())\n  }, [])\n\n  // 디렉토리 선택 여부\n  const selected = isSelected ? 'open' : null\n\n  return (\n    &#x3C;ul ref={postsRef} className={`sidebar__posts ${selected}`}>\n      {posts.map((post) => (\n        &#x3C;li key={post.id}>\n          &#x3C;Link to={`/posts/${post.relativePath}`} activeClassName=\"active\">\n            {post.title || post.name}\n          &#x3C;/Link>\n        &#x3C;/li>\n      ))}\n    &#x3C;/ul>\n  )\n})\n</code></pre>\n<h1 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h1>\n<ul>\n<li><a href=\"https://www.gatsbyjs.com/docs/how-to/querying-data/use-static-query/\">Gatsby useStaticQuery</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-graphql\">1. GraphQL</a></p>\n</li>\n<li>\n<p><a href=\"#2-%ED%8F%B4%EB%8D%94%EA%B5%AC%EC%A1%B0-%EA%B8%B0%EB%B0%98-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC\">2. 폴더구조 기반 카테고리</a></p>\n<ul>\n<li><a href=\"#21-fragments--usestaticquery\">2.1. fragments &#x26; useStaticQuery</a></li>\n<li><a href=\"#21-usestaticquery-hook\">2.1. useStaticQuery Hook</a></li>\n<li><a href=\"#23-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\">2.3. 카테고리 컴포넌트</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EA%B3%A0\">참고</a></p>\n</li>\n</ul>","frontmatter":{"title":"08. 폴더 구조 기반 Gatsby 카테고리 바 생성","createdAt":"2023-06-28","updatedAt":"2023-06-28","tags":["gatsby","카테고리","디렉토리 기반","폴더 기반"],"description":"Gatsby의 graphql을 이용해서 디렉토리 구조에 기반하여 카테고리 바를 생성해본다.","reference":null}},"allMarkdownRemark":{"nodes":[{"id":"94b436d7-15e2-57c6-8d40-52cf418e46e6","excerpt":"시작하기 앞서... Gatsby로 Markdown기반의 블로그를 만들려고 한다면, Gatsby 공식문서를 보는 것을 추천한다. 맞춤형 강의라고 해도 믿을 만큼 잘 정리되어 있기 때문이다. 때문에 나는 앞으로 Gatsby…","parent":{"id":"ce161dd8-00d5-50d2-8c0d-578dd75f7c94","name":"01_Gatsby","relativePath":"Frontend/Gatsby/01_Gatsby.md"},"frontmatter":{"title":"01. Gatsby 렌더링 옵션과 프로젝트 구조","createdAt":"2023-06-16","updatedAt":"2023-06-16"},"fields":{"slug":"/posts/Frontend/Gatsby/01_Gatsby/"}},{"id":"9aebcdb2-63dc-552b-b521-6c16e309d09b","excerpt":"1. 프론트엔드 배포란? 프론트엔드 배포를 한 마디로 정리하면, 특정 url을 통한 GET요청에 대해 index.html…","parent":{"id":"7fbea288-e615-5f15-96a9-d71745462e2c","name":"02_Github_Pages","relativePath":"Frontend/Gatsby/02_Github_Pages.md"},"frontmatter":{"title":"02. Gatsby 프로젝트 Github Pages 배포","createdAt":"2023-06-23","updatedAt":"2023-06-23"},"fields":{"slug":"/posts/Frontend/Gatsby/02_Github_Pages/"}},{"id":"3e2351da-7a0c-5c18-b503-c4358b27ab8f","excerpt":"1. import 경로 프로젝트를 진행하다 보면, import 절대경로를 설정하지 않을 수 없다.\n심지어 어쩌다가 한 번, IDE에서 자동 import…","parent":{"id":"cc5bee56-affb-555b-95d9-325b948e4870","name":"03_Import_Settings","relativePath":"Frontend/Gatsby/03_Import_Settings.md"},"frontmatter":{"title":"03. Gatsby 프로젝트(TypeScript) import 경로 설정","createdAt":"2023-06-24","updatedAt":"2023-06-24"},"fields":{"slug":"/posts/Frontend/Gatsby/03_Import_Settings/"}},{"id":"e2e850af-877e-5cc3-afc7-00362ed5273d","excerpt":"1. 개요 1.1. Prettier & ESLint란? Prettier와 ESLint는 각각 코드 포맷팅(Code Formatting)과 린팅(Linting…","parent":{"id":"8e077755-e170-50a6-a0b5-964d3835ef5d","name":"04_ESLint_Prettier","relativePath":"Frontend/Gatsby/04_ESLint_Prettier.md"},"frontmatter":{"title":"04. Gatsby 프로젝트 Prettier & ESLint & Husky 설정","createdAt":"2023-06-25","updatedAt":"2023-06-25"},"fields":{"slug":"/posts/Frontend/Gatsby/04_ESLint_Prettier/"}},{"id":"a0a6e020-13b3-5b8c-a3a9-731d0b01e16c","excerpt":"아래 내용은 주관적인 의견이고, 카카오 FE 기술 블로그의 내용을 참조했습니다. 1. Sass 다크모드 한동안 다크모드를 공부한 적이 있다. Styled Component와 같은 CSS-in-JS…","parent":{"id":"f070924b-4b2c-5a2e-ae60-efbd70ce23c9","name":"05_Dark_Mode","relativePath":"Frontend/Gatsby/05_Dark_Mode.md"},"frontmatter":{"title":"05. Gatsby 다크모드 구현하기 (feat. Sass)","createdAt":"2023-06-26","updatedAt":"2023-06-26"},"fields":{"slug":"/posts/Frontend/Gatsby/05_Dark_Mode/"}},{"id":"8dd7c7ba-002c-5398-92a5-b43faf1f595b","excerpt":"1. SSG 렌더링 React에서는 Nested Route로 손 쉽게 레이아웃을 구현할 수 있다. 그런데 Gatsby는 Single Page Application이 아니다! Gatsby는 정적 사이트 생성기(SSG)로 빌드 시에, 모든 url…","parent":{"id":"7dc89b39-7e64-5368-9d05-118f4f02d985","name":"06_Navigation_Layout","relativePath":"Frontend/Gatsby/06_Navigation_Layout.md"},"frontmatter":{"title":"06. Gatsby 네비게이션 레이아웃 설정","createdAt":"2023-06-27","updatedAt":"2023-06-27"},"fields":{"slug":"/posts/Frontend/Gatsby/06_Navigation_Layout/"}},{"id":"f2e3f78d-324e-5387-b630-101288184fae","excerpt":"1. 튜토리얼 방식의 한계 Gatsby 튜토리얼 Part6 를 보면 file system routes라고 해서 파일시스템에 있는 파일들에 대해서 동적으로 페이지를 생성하는 방법을 소개한다. 예를 들어 아래 그림처럼 src/pages/아래에 {mdx…","parent":{"id":"0384b347-d777-5cc3-943b-91771189a957","name":"07_Custom_Pages","relativePath":"Frontend/Gatsby/07_Custom_Pages.md"},"frontmatter":{"title":"07. Gatsby 커스텀 페이지 생성","createdAt":"2023-06-27","updatedAt":"2023-06-27"},"fields":{"slug":"/posts/Frontend/Gatsby/07_Custom_Pages/"}},{"id":"19ad15a7-720c-5daf-880f-06af0a704144","excerpt":"1. GraphQL 아직 GraphQL을 파일시스템에 대해서 밖에 사용하지 않아, 정확히 GraphQL이 뭔지는 감이 안잡힌다. 하지만 그 제한된 경험으로도 GrqphQL이 기존 API…","parent":{"id":"daf85c35-0844-5cdb-8909-f001a0714f75","name":"08_Diretory_Based_Category","relativePath":"Frontend/Gatsby/08_Diretory_Based_Category.md"},"frontmatter":{"title":"08. 폴더 구조 기반 Gatsby 카테고리 바 생성","createdAt":"2023-06-28","updatedAt":"2023-06-28"},"fields":{"slug":"/posts/Frontend/Gatsby/08_Diretory_Based_Category/"}},{"id":"6ae60c60-1e09-59a3-8a3c-f12ca9abd1c4","excerpt":"gatsby-transformer-remark플러그인을 통한 markdownRemark노드를 사용을 전제합니다. 1. 마크다운 스타일링 나는 분명 Gatsby 공식문서를 따라 gatsby-transformer-remark…","parent":{"id":"e5909625-6638-5137-b366-16bba9f61baf","name":"09_Markdown_Styling","relativePath":"Frontend/Gatsby/09_Markdown_Styling.md"},"frontmatter":{"title":"09. Gatsby 마크다운(md) 스타일링","createdAt":"2023-06-29","updatedAt":"2023-06-29"},"fields":{"slug":"/posts/Frontend/Gatsby/09_Markdown_Styling/"}},{"id":"187472ff-d02f-5104-9b2e-515b0b1898f2","excerpt":"1. URL 프래그먼트 식별자(#) 일단 프래그먼트 식별자(a.k.a. #)이 어떻게 동작하는 알 필요가 있다. 나는 평소 너무 당연하게 써왔지만, 어떻게 동작하는지는 한 번도 생각해보지 않았다. 사용자가 URL…","parent":{"id":"0a367c55-81a1-5059-8814-42d23ceac89a","name":"10_Table_of_Contents","relativePath":"Frontend/Gatsby/10_Table_of_Contents.md"},"frontmatter":{"title":"10. Gatsby 스크롤 반응형 목차(TOC) 생성","createdAt":"2023-06-30","updatedAt":"2023-06-30"},"fields":{"slug":"/posts/Frontend/Gatsby/10_Table_of_Contents/"}},{"id":"1e126097-6df5-5927-8c17-282ca0974e45","excerpt":"1. Utterances와 Giscus 따로 서버를 돌리지 않고서는 댓글/좋아요 기능을 구현할 수 없을 줄 알았다. 그런데 항상 개발자들은 신박한 방법을 찾아낸다. GitHub API…","parent":{"id":"86d49b0e-e662-5a09-8fa5-8d69829c899f","name":"11_utterances_giscus","relativePath":"Frontend/Gatsby/11_utterances_giscus.md"},"frontmatter":{"title":"11. Gatsby 댓글 및 좋아요 기능","createdAt":"2023-07-02","updatedAt":"2023-07-02"},"fields":{"slug":"/posts/Frontend/Gatsby/11_utterances_giscus/"}}]}},"pageContext":{"pagePath":"/posts/Frontend/Gatsby/08_Diretory_Based_Category/","siblingPostsPathRegex":"/^(?!.*README).*Frontend\\/Gatsby.*$/","relativeDirectory":"Gatsby","id":"19ad15a7-720c-5daf-880f-06af0a704144","parent":{"id":"daf85c35-0844-5cdb-8909-f001a0714f75","name":"08_Diretory_Based_Category","relativePath":"Frontend/Gatsby/08_Diretory_Based_Category.md"},"fields":{"slug":"/posts/Frontend/Gatsby/08_Diretory_Based_Category/"}}},"staticQueryHashes":["24302420","4059933791"],"slicesMap":{}}