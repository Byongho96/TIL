{"componentChunkName":"component---src-templates-post-index-tsx","path":"/posts/Frontend/Gatsby/02_Github_Pages.md/","result":{"data":{"markdownRemark":{"id":"9aebcdb2-63dc-552b-b521-6c16e309d09b","html":"<h1 id=\"1-프론트엔드-배포란\" style=\"position:relative;\"><a href=\"#1-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%B0%B0%ED%8F%AC%EB%9E%80\" aria-label=\"1 프론트엔드 배포란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 프론트엔드 배포란?</h1>\n<p>프론트엔드 배포를 한 마디로 정리하면, <strong>특정 url을 통한 GET요청에 대해 index.html을 반환하도록 설정</strong>하는 것을 말한다.</p>\n<p>처음 배포를 공부할 때, 나는 백엔드보다 오히려 프론트엔드의 배포를 이해하기 더 어려웠다. 백엔드를 배포한다는 것은, 클라이언트의 요청을 WAS(Web Application Server)가 동적으로 처리해 결과를 반환할 수 있도록, 서버에 백엔드 프로젝트(어플리케이션)를 구동하는 것을 말한다. 그런데 도대체 프론트엔드를 배포한다는게 무슨 말일까?</p>\n<p>다음 예시를 통해 프론트엔드 배포의 한 번 설명해보겠다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/ef37963c1dfed53ff4c502af95571639/4cdc7/naver.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 43.42857142857143%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABJ0AAASdAHeZh94AAABTUlEQVR42m2SCY6DMAxFuf8tyx6yE8hCoH9kV8O01Vj6IgmO/WynafsBwyQwLwpCacxSoe16PIYFyjhIbbAoDSEVlDYs51f4NXxoDRv/a7quh9YGIWxIKSGmBKkUBznPE7kUOO8RY8JxHLiui8/fVWsF2TiOaLq+h3cOOWfUerC01pBS4vl8IpUMoRbU43XpPyM/smma0IzjzAvvPWcqpTCxWBasISDngrDt2GNiShKdvSslgjnRdR2aYZw5GJVLJZGU0hiG4WPvnMMaVt7fZF+EQgg0RGe0YUfqBxFSAlqTETWVb627E7+UuU2kGCPf37YNTd+1eDxazLPg3pEz0dCXjByNMTfJ31CujwERIwfUSnEgkrX2DqCk4uxEbIy9aUi/JX4PhQPOYoGhctbX29LG3kPZ9x3lOGCdwx4jB6dnVOmpvOmoFed1cUt+AHBntyv/qCqHAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"naver network\" title=\"\" src=\"/TIL/static/ef37963c1dfed53ff4c502af95571639/8c557/naver.png\" srcset=\"/TIL/static/ef37963c1dfed53ff4c502af95571639/4edbd/naver.png 175w,\n/TIL/static/ef37963c1dfed53ff4c502af95571639/13ae7/naver.png 350w,\n/TIL/static/ef37963c1dfed53ff4c502af95571639/8c557/naver.png 700w,\n/TIL/static/ef37963c1dfed53ff4c502af95571639/e996b/naver.png 1050w,\n/TIL/static/ef37963c1dfed53ff4c502af95571639/4cdc7/naver.png 1327w\" sizes=\"(max-width: 700px) 100vw, 700px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<ol>\n<li>브라우저에 '<a href=\"http://www.naver.com/&#x27;%EC%9D%84\">http://www.naver.com/'을</a> 입력했다고 가정해보자</li>\n<li>이는 곧 해당 URL(IP 주소)로 GET 요청을 보내는 것이다</li>\n<li>URL(IP 주소)에 대응하는 서버는 네이버 홈페이지 HTML파일을 반환한다.</li>\n<li>이 때 HTTP/2의 특징으로 HTML파일이 참조하는 JS, CSS, img, ... 등도 서버에서 한꺼번에 보내준다.</li>\n<li>브라우저는 받은 HTML을 나머지 정적 파일들과 함께 렌더링하여 화면에 보여준다.</li>\n</ol>\n<p>즉, 백엔드와 프론트엔드 배포는 큰 틀에서 동일하게 동작한다. 다만 프론트엔드는 GET만을 받아 JSON이 아닌 정적파일(html, js, css, ...)을 반환하는 차이점이 있을 뿐이다. 이렇게 url에 대해서 정적인 콘텐츠를 반환할 뿐이기에, 프론트엔드만을 배포하기 위해서 24시간 돌아가는 컴퓨팅 자원을 관리하는 것을 배보다 배꼽이 큰 격이다. 이런 경우 Netflify나 Gihub Pages와 같은 정적 콘텐츠 제공 서비스를 사용할 수 있다.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th align=\"center\">백엔드</th>\n<th align=\"center\">프론트엔드</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Method</td>\n<td align=\"center\">GET, POST, PUT, DELETE ...</td>\n<td align=\"center\">GET</td>\n</tr>\n<tr>\n<td>Process</td>\n<td align=\"center\">요청에 따라 동적</td>\n<td align=\"center\">모든 요청에 정적 (SSR 제외)</td>\n</tr>\n<tr>\n<td>Return</td>\n<td align=\"center\">JSON</td>\n<td align=\"center\">html (js, css, static)</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"2-github-pages\" style=\"position:relative;\"><a href=\"#2-github-pages\" aria-label=\"2 github pages permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. GitHub Pages</h1>\n<p><a href=\"https://docs.github.com/ko/pages/getting-started-with-github-pages/creating-a-github-pages-site\">GitHub Pages</a>는 GitHub에서 제공하는 정적 웹사이트 호스팅 서비스이다. GitHub 리포지토리에 저장된 정적 파일(HTML, CSS, JavaScript)을 url 요청이 들어오면 제공하는 것이다.</p>\n<p>어떠한 github 레포지토리든지 Settings > Pages 에 들어가면, 아래 사진에서 볼 수 있는 것처럼 특정 Branch를 바라보도록 설정할 수 있다. 그러면 GitHub Pages는 해당 브랜치의 최상단 디렉토리에서 <mark><strong>index.html, index.md, README.md</strong></mark> 3가지 파일을 호스팅할 사이트의 <strong>시작 파일</strong>로 관찰하고 있다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/ae895da16b9e7f6236c291d77bbfa608/4f1dd/github-pages.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 53.714285714285715%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABJ0AAASdAHeZh94AAABh0lEQVR42o2SO2/dMAxG/f//S6auXbJ06xwEuMhSNMmtrfdbsn0KycltjLZoCXwgSEHkIaXp8fLELBRSW37MkkVqfMx/UcGFgtIvSHXB+nA7cyENTco4dJf1CKnpsXEB6+OQDwljPcZ5rIsYq5HXT8jXO1JaSHkj5ULKdWhqrZFSAnY+mnMOKSXGGH6zTcD6nT/ZUTBn9nM9Ym64kAkhUEoZTQ9Fcq7EVMk5k2Iafn8DmmqtKKkG0bZtI7nvOyFErPVorXHOj7Oz1lN8InQujO77B8zeoNPFmKit8b829XG0Mbdi67YNfCkNUhms8+RSTjTr2nUQriPeeYecUk4oJW8dciuUtWLMC9pc8TFSax57yumX7xONHXZfGqXt74T9cqC17YRe0yMlPmGukXkptwv/HNm5B5brF6K/DOxjlB2tPXLWPNxf+Hz/jefF00onelM8Xj3GONTjvr5Jyq8sz3fU/EBtjAdo64a1BiEFLlhiMGilEEIghRy/Yp6X8U/FcuSEkGMFPwGmzFdbyxMs9wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"github-pages\" title=\"\" src=\"/TIL/static/ae895da16b9e7f6236c291d77bbfa608/8c557/github-pages.png\" srcset=\"/TIL/static/ae895da16b9e7f6236c291d77bbfa608/4edbd/github-pages.png 175w,\n/TIL/static/ae895da16b9e7f6236c291d77bbfa608/13ae7/github-pages.png 350w,\n/TIL/static/ae895da16b9e7f6236c291d77bbfa608/8c557/github-pages.png 700w,\n/TIL/static/ae895da16b9e7f6236c291d77bbfa608/e996b/github-pages.png 1050w,\n/TIL/static/ae895da16b9e7f6236c291d77bbfa608/2cefc/github-pages.png 1400w,\n/TIL/static/ae895da16b9e7f6236c291d77bbfa608/4f1dd/github-pages.png 1567w\" sizes=\"(max-width: 700px) 100vw, 700px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>내 TIL 레포지토리에 대한 Gihub Pages 설정을 보며 더 자세하게 설명해보도록 하겠다.</p>\n<ul>\n<li>Default url은 <code>{Github ID}.github.io/{레포지토리 이름}/</code>이다.\n<ul>\n<li>아래 예시의 경우, <code>byongho96/github.io/TIL/</code></li>\n</ul>\n</li>\n<li>지켜 볼 Branch와 Directory를 설정할 수 있다.\n<ul>\n<li>아래 예시의 경우, <code>gh-pages</code> 브랜치의 최상단 디렉토리(<code>/root</code>)를 바라보고 있다.</li>\n<li>해당 위치에 index.html, index.md, README.md 가 들어올 경우, 이를 제공한다.</li>\n</ul>\n</li>\n</ul>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/6e2b9994a54834efc7ddf7fb12868d99/01294/github-pages-setting.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 49.142857142857146%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABJ0AAASdAHeZh94AAABZUlEQVR42oVS207sMAzs/38dD/C4CImFA8tuc7FzTzwoLl1AIM5IE+fSjid2lqd/JxweHmE9KylmcMwa97muwx4TLtbjbLzOQypK+jhbOCY4z/AU4ChoJI7b2hM8R8xv5h6FCOIAZx2c88i1I9eGXD65CAQ5F/Te8RUpZ6zGwliH3gdEsHEIRAbG+M4dyxw4BIQQvh3U2uE4g8iA6AiiZ3g6IvAFOVfEmNRISknZeoeIbIIpzR8JpRQVE0AdO5/w8vqIs7mDsXfwdIvWTh8p5ZqcQwRzRGtjEyRm5VeHrTXUWtRFrduVd5npZCN+YJl7McZrDado7RXMjLe3E4wx8N5CpO9y+AtbDTkg57w5EEEfXZ0ZF/W5zO6NIZp0jK6xd8H41aEIzOzmuqrYtcvJ43K+BfMznL2Hcw9aq5lo1rrUgfaL4tK64PhyxrpaxFQQU0ZMFaUQ7HoD559wMQeQP6CUhv/hHQjmDTM4IDbtAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"github-pages-setting\" title=\"\" src=\"/TIL/static/6e2b9994a54834efc7ddf7fb12868d99/8c557/github-pages-setting.png\" srcset=\"/TIL/static/6e2b9994a54834efc7ddf7fb12868d99/4edbd/github-pages-setting.png 175w,\n/TIL/static/6e2b9994a54834efc7ddf7fb12868d99/13ae7/github-pages-setting.png 350w,\n/TIL/static/6e2b9994a54834efc7ddf7fb12868d99/8c557/github-pages-setting.png 700w,\n/TIL/static/6e2b9994a54834efc7ddf7fb12868d99/e996b/github-pages-setting.png 1050w,\n/TIL/static/6e2b9994a54834efc7ddf7fb12868d99/2cefc/github-pages-setting.png 1400w,\n/TIL/static/6e2b9994a54834efc7ddf7fb12868d99/01294/github-pages-setting.png 1615w\" sizes=\"(max-width: 700px) 100vw, 700px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<h2 id=\"21-gh-pages\" style=\"position:relative;\"><a href=\"#21-gh-pages\" aria-label=\"21 gh pages permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. gh-pages</h2>\n<p>그럼 우리는 index.html을 포함한 정적 파일을 특정 브랜치에 업로드하기만 하면 된다. 이를 도와주는 라이브러리가 <a href=\"https://www.npmjs.com/package/gh-pages-cli\">gh-pages</a>이다. gh-pages의 역할을 간단하다. 그냥 레포지토리에 브랜치를 생성하고, 해당 브랜치에 정적파일을 업로드 하는 것이다.</p>\n<p>사용법은 다음과 같다.</p>\n<ol>\n<li>\n<p><strong>gh-pages 설치</strong></p>\n<p>npm 패키지 설치 시, cli 명령도 사용할 수 있다.</p>\n<pre><code class=\"language-cli\">npm install gh-pages --save-dev\n</code></pre>\n</li>\n<li>\n<p><strong>gh-pages CLI 구동</strong></p>\n<pre><code class=\"language-cli\">gh-pages\n\n옵션\n-d {타겟 디렉토리}: 올리고자 하는 타겟 디렉토리이다. 기본값은 현재 위치이다.\n-b {타겟 브랜치}: 올리려는 타겟 브랜치이다. 기본값은 gh-pages이다.\n</code></pre>\n</li>\n</ol>\n<h2 id=\"22-gatsby-and-gh-pages\" style=\"position:relative;\"><a href=\"#22-gatsby-and-gh-pages\" aria-label=\"22 gatsby and gh pages permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2. Gatsby and gh-pages</h2>\n<p><a href=\"https://www.gatsbyjs.com/docs/how-to/previews-deploys-hosting/how-gatsby-works-with-github-pages/\">Gatsby 공식문서</a>에서는 Gatsby 프로젝트를 gh-pages를 어떻게 배포할지 설명해주고 있다. 그런데 살펴보면 별거 없다. <strong>그냥 Gatsby를 먼저 빌드하고, 이걸 <code>gh-pages</code>명령어로 GitHub에 푸시하라는 말이다.</strong></p>\n<ol>\n<li>\n<p><strong>gh-pages 설치</strong></p>\n<pre><code class=\"language-cli\">npm install gh-pages --save-dev\n</code></pre>\n</li>\n<li>\n<p><strong>pathPrefix 설정</strong></p>\n<p>Github Pages로 웹사이트를 호스팅하면 따로 커스텀 도메인을 설정해주지 않는 이상, 레포지토리 명을 url 주소의 prefix로 가져간다. 이를 반영해서 Gatsby 프로젝트를 반영하기 위해 <code>gatsby-config.js</code>파일에 다음 설정을 해줘야 한다.</p>\n<pre><code class=\"language-js\">// gatsby-config.js\n\nmodule.exports = {\n  pathPrefix: '/{레포지토리 이름}',\n}\n</code></pre>\n</li>\n<li>\n<p><strong>커스텀 script 설정</strong></p>\n<p>다음과 같이 pacakge.json에서 커스텀 script를 설정한다. <code>npm run deploy</code>를 입력하면, <code>gatsby build --prefix-paths &#x26;&#x26; gh-pages -d public</code>명령어를 실행시키도록 하겠다는 것이다.</p>\n<ul>\n<li>\n<p><code>gatsby build --prefix-paths</code></p>\n<ul>\n<li>설정해 둔 <code>pathPrefix</code>를 반영해서 Gatsby 프로젝트를 빌드한다.</li>\n<li>빌드 결과물은 자동으로 <code>/public</code>폴더에 저장된다.</li>\n</ul>\n</li>\n<li>\n<p><code>gh-pages -d public</code></p>\n<ul>\n<li><code>public</code>폴더의 내용물을 <code>gh-pages</code>브랜치에 push한다.</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">// package.json\n\n {\n    \"scripts\": {\n        \"deploy\": \"gatsby build --prefix-paths &#x26;&#x26; gh-pages -d public\"\n    }\n }\n</code></pre>\n</li>\n</ol>\n<h1 id=\"3-github-actions\" style=\"position:relative;\"><a href=\"#3-github-actions\" aria-label=\"3 github actions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Github Actions</h1>\n<p>Github Actions는 GitHub에서 제공하는 CI/CD 서비스이다.</p>\n<p>더 직관적으로 설명하면 이렇다. YAML형식의 워크플로우 파일을 등록하여, <strong>특정 이벤트(push, merge, pull ...)가 일어났을 때, 내가 설정해둔 작업을 자동 실행시킬 수 있다.</strong></p>\n<p>그러면 내가 master 브랜치에 머지했을 때 <code>npm run deploy</code>명령어가 돌아가도록, 형식에 맞춰 워크플로우를 작성해서 등록하면 자동배포 끝이다!</p>\n<p>근데 항상 생각대로 되지 않기 마련이다... 아래는 내가 처음에 작성했던 간단한 워크플로이다. 마지막 <code>npm run deploy</code>부분에서 인증에러가 발생했다. 아무리 내 레포지토리로 push를 하는 것이라고 해도, 실제 워크플로 작업이 일어나는 공간은 Github Cloud이기 때문에 인증에러가 발생하는 것이라고 추측한다.</p>\n<pre><code class=\"language-yml\">name: Deploy GitHub Pages\n\n# master 브랜치에 push 작업이 발생했을 때,\non:\n  push:\n    branches:\n      - master\n\n# 아래 작업을 실행시킨다.\njobs:\n  deploy:\n    runs-on: ubuntu-latest # 작업 실행 OS 설정\n    permissions: # 저장소에 대해 쓰기 권한을 부여한다.\n      contents: write\n    steps:\n      - uses: actions/checkout@v3 # 현재 저장소를 checkout해서 코드를 가져온다.\n\n      - name: Setup Node # Node 환경을 셋팅한다.\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18' # 내가 사용한 Node 버전\n\n      - run: npm ci # npm 패키지를 설치\n      - run: npm run deploy # gatsby build --prefix-paths &#x26;&#x26; gh-pages -d public\n</code></pre>\n<h2 id=\"31-peaceirisactions-gh-pages\" style=\"position:relative;\"><a href=\"#31-peaceirisactions-gh-pages\" aria-label=\"31 peaceirisactions gh pages permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1. peaceiris/actions-gh-pages</h2>\n<p>그래서 인증과 gh-pages를 함께 처리할 수 있는 action을 찾기 시작했다. <strong>actions 이란, 워크플로우에서 재사용할 수 있는 기능 단위의 모듈이라고 생각할 수 있다.</strong> <code>actions/checkout</code> Github에서 공식적으로 제공하는 액션도 있고, 다른 개발자들이 만든 action도 있다.</p>\n<p>그런데 구글링해서 찾아본 대부분의 글에서는 Personal Access Token을 발급받아 배포를 진행했다. 나는 다음과 같은 이유로 이 부분이 조금 꺼림직했다.</p>\n<ul>\n<li>내 레포지토리로 push를 하는 것인데, Personal Access Token이 정말 필요할지 의문이었다.</li>\n<li>Github 공식 Action도 아닌데 Personal Access Token을 사용하기가 꺼려졌다.</li>\n<li><strong>무엇보다 Persnal Access Token은 만료기간이 있어서 주기적으로 갱신해줘야 한다.</strong></li>\n</ul>\n<p>그러던 중 구세주를 만났다. 바로 이 <a href=\"https://github.com/peaceiris/actions-gh-pages\">peaceiris/actions-gh-pages</a>이다. 링크를 타고 들어가면 다음과 같은 사용예시와 설명을 볼 수 있다. 한 마디로 <code>GIHUB_TOKEN</code>이라는 값을 사용하기는 하는데, 이건 Personal Access Token이 아니라 Github Actions Runner가 인증을 위해 자동생성하는 값이다. 때문에 우리는 어떠한 추가 설정없이 바로 해당 action을 사용할 수 있다!</p>\n<pre><code class=\"language-yml\">- name: Deploy\n  uses: peaceiris/actions-gh-pages@v3\n  with:\n    github_token: ${{ secrets.GITHUB_TOKEN }}\n    publish_dir: ./public\n</code></pre>\n<blockquote>\n<p>For newbies of GitHub Actions: Note that the GITHUB_TOKEN is NOT a personal access token. A GitHub Actions runner automatically creates a GITHUB_TOKEN secret to authenticate in your workflow. So, you can start to deploy immediately without any configuration.</p>\n</blockquote>\n<p>여기서 끝이 아니다! 프레임워크 별로 구체적인 예시 코드까지 정리해 놓으셨다. 이렇게 똑똑하고 친절한 개발자는 복 받을 거다. 아래는 내가 아주 살짝 커스텀한 코드이다.</p>\n<pre><code class=\"language-yml\">name: GitHub Pages\n\n# master 브랜치에 push 작업이 발생했을 때,\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest # 작업 실행 OS 설정\n    permissions: # 저장소에 대해 쓰기 권한을 부여한다.\n      contents: write\n    concurrency: # 작업 동시성을 제어한다 (하단 설명 참조)\n      group: ${{ github.workflow }}-${{ github.ref }}\n    steps:\n      - uses: actions/checkout@v3 # 현재 저장소를 checkout해서 코드를 가져온다.\n\n      # Node 환경을 셋팅한다.\n      - name: Setup Node\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18' # 내가 사용한 노드 버전\n\n      # 캐시 관리\n      # 다운로드한 패키지를 캐시하여 다음 실행 시에 다시 다운로드하지 않는다. (하단 설명 참조)\n      - name: Cache dependencies\n        uses: actions/cache@v3\n        with:\n          path: ~/.npm\n          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}\n          restore-keys: |\n            ${{ runner.os }}-node-\n\n      - run: npm ci\n      #   - run: npm run format\n      #   - run: npm run test\n      - run: npm run build\n\n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v3\n        if: github.ref == 'refs/heads/main'\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./public\n</code></pre>\n<ul>\n<li>\n<p><strong>concurrency</strong><br>\nconcurrency는 동시성을 제어하는 옵션으로, 그룹 내에서 여러 작업이 동시 실행되는 것을 제한할 수 있다.</p>\n<p>위 코드에서는 group 속성에 <code>${{ github.workflow }}-${{ github.ref }}</code> 값을 사용하고 있다. <code>${{ github.workflow }}</code>는 현재 워크플로우 이름을, <code>${{ github.ref }}</code>는 현재 브랜치를 의미한다. 이렇게 설정된 그룹 내에서는 한 번에 하나의 작업만 실행된다. 이를 통해 작업 간의 충돌을 방지하고 자원을 효율적으로 활용할 수 있다고 한다.</p>\n</li>\n<li>\n<p><strong>actions/cache@v3</strong><br>\n해당 코드는 Github의 캐시 서비스를 이용해서 종속성을 캐시한다. 캐시 서비스에 저장된 값은 동일 레포지토리 내에서 다른 워크플로우와 공유되기 때문에, 다음 번 워크프롤우에서 사용할 수 있다.</p>\n<ul>\n<li>\n<p><strong>path</strong><br>\n캐시를 저장할 디렉토리 경로를 지정한다.</p>\n</li>\n<li>\n<p><strong>key</strong><br>\n캐시를 식별하는 고유한 키를 생성한다. 위 코드에서는 두가지 변수를 사용한다. <code>${{ runner.os }}</code>는 실행 환경의 운영체제를, <code>-node-</code>는 단순 문자열, 그리고 <code>${{ hashFiles('**/package-lock.json') }}</code>은 package-lock.json 파일의 해시값을 의미한다. 이를 통해 package-lock.json 파일이 수정되었을 경우에만 새로운 캐시를 생성한다.</p>\n</li>\n<li>\n<p><strong>restore-keys</strong><br>\n캐시된 값을 복원할 때 사용할 키들의 목록을 지정한다. 위의 코드에서는 <code>${{ runner.os }}-node-</code>를 사용하여 앞선 <code>key</code>항목에서 생성되었던 모듴 키들을 순서대로 검사하도록 했다. 그 중 가장 최근에 생성된 캐시의 값으로 복원한다.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"참조\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EC%A1%B0\" aria-label=\"참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참조</h1>\n<ul>\n<li><a href=\"https://docs.github.com/ko/pages/getting-started-with-github-pages/creating-a-github-pages-site\">Getting Started with Github Pages</a></li>\n<li><a href=\"https://pages.github.com/\">Github Pages</a></li>\n<li><a href=\"https://www.gatsbyjs.com/docs/how-to/previews-deploys-hosting/how-gatsby-works-with-github-pages/\">How Gatsby workswith Gitub Pages</a></li>\n<li><a href=\"https://github.com/peaceiris/actions-gh-pages\">peaceiris/actions-gh-pages</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%B0%B0%ED%8F%AC%EB%9E%80\">1. 프론트엔드 배포란?</a></p>\n</li>\n<li>\n<p><a href=\"#2-github-pages\">2. GitHub Pages</a></p>\n<ul>\n<li><a href=\"#21-gh-pages\">2.1. gh-pages</a></li>\n<li><a href=\"#22-gatsby-and-gh-pages\">2.2. Gatsby and gh-pages</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-github-actions\">3. Github Actions</a></p>\n<ul>\n<li><a href=\"#31-peaceirisactions-gh-pages\">3.1. peaceiris/actions-gh-pages</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EC%A1%B0\">참조</a></p>\n</li>\n</ul>","frontmatter":{"title":"02. Gatsby 프로젝트 Github Pages 배포","createdAt":"2023-06-23","updatedAt":"2023-06-23","tags":["gatsby","gh-pages","프론트엔드","배포","github","actions"],"description":"gh-pages와 github actions를 이용해서 gatsby 프로젝트를 자동배포한다.","reference":null}},"allMarkdownRemark":{"nodes":[{"id":"94b436d7-15e2-57c6-8d40-52cf418e46e6","parent":{"id":"ce161dd8-00d5-50d2-8c0d-578dd75f7c94","name":"01_Gatsby","relativePath":"Frontend/Gatsby/01_Gatsby.md"},"frontmatter":{"title":"01. Gatsby 렌더링 옵션과 프로젝트 구조","createdAt":"2023-06-16","updatedAt":"2023-06-16"},"excerpt":"시작하기 앞서... Gatsby로 Markdown기반의 블로그를 만들려고 한다면, Gatsby 공식문서를 보는 것을 추천한다. 맞춤형 강의라고 해도 믿을 만큼 잘 정리되어 있기 때문이다. 때문에 나는 앞으로 Gatsby…"},{"id":"9aebcdb2-63dc-552b-b521-6c16e309d09b","parent":{"id":"7fbea288-e615-5f15-96a9-d71745462e2c","name":"02_Github_Pages","relativePath":"Frontend/Gatsby/02_Github_Pages.md"},"frontmatter":{"title":"02. Gatsby 프로젝트 Github Pages 배포","createdAt":"2023-06-23","updatedAt":"2023-06-23"},"excerpt":"1. 프론트엔드 배포란? 프론트엔드 배포를 한 마디로 정리하면, 특정 url을 통한 GET요청에 대해 index.html…"},{"id":"3e2351da-7a0c-5c18-b503-c4358b27ab8f","parent":{"id":"cc5bee56-affb-555b-95d9-325b948e4870","name":"03_Import_Settings","relativePath":"Frontend/Gatsby/03_Import_Settings.md"},"frontmatter":{"title":"03. Gatsby 프로젝트(TypeScript) import 경로 설정","createdAt":"2023-06-24","updatedAt":"2023-06-24"},"excerpt":"1. import 경로 프로젝트를 진행하다 보면, import 절대경로를 설정하지 않을 수 없다.\n심지어 어쩌다가 한 번, IDE에서 자동 import…"},{"id":"e2e850af-877e-5cc3-afc7-00362ed5273d","parent":{"id":"8e077755-e170-50a6-a0b5-964d3835ef5d","name":"04_ESLint_Prettier","relativePath":"Frontend/Gatsby/04_ESLint_Prettier.md"},"frontmatter":{"title":"04. Gatsby 프로젝트 Prettier & ESLint & Husky 설정","createdAt":"2023-06-25","updatedAt":"2023-06-25"},"excerpt":"1. 개요 1.1. Prettier & ESLint란? Prettier와 ESLint는 각각 코드 포맷팅(Code Formatting)과 린팅(Linting…"},{"id":"a0a6e020-13b3-5b8c-a3a9-731d0b01e16c","parent":{"id":"f070924b-4b2c-5a2e-ae60-efbd70ce23c9","name":"05_Dark_Mode","relativePath":"Frontend/Gatsby/05_Dark_Mode.md"},"frontmatter":{"title":"05. Gatsby 다크모드 구현하기 (feat. Sass)","createdAt":"2023-06-26","updatedAt":"2023-06-26"},"excerpt":"아래 내용은 주관적인 의견이고, 카카오 FE 기술 블로그의 내용을 참조했습니다. 1. Sass 다크모드 한동안 다크모드를 공부한 적이 있다. Styled Component와 같은 CSS-in-JS…"},{"id":"8dd7c7ba-002c-5398-92a5-b43faf1f595b","parent":{"id":"7dc89b39-7e64-5368-9d05-118f4f02d985","name":"06_Navigation_Layout","relativePath":"Frontend/Gatsby/06_Navigation_Layout.md"},"frontmatter":{"title":"06. Gatsby 네비게이션 레이아웃 설정","createdAt":"2023-06-27","updatedAt":"2023-06-27"},"excerpt":"1. SSG 렌더링 React에서는 Nested Route로 손 쉽게 레이아웃을 구현할 수 있다. 그런데 Gatsby는 Single Page Application이 아니다! Gatsby는 정적 사이트 생성기(SSG)로 빌드 시에, 모든 url…"},{"id":"f2e3f78d-324e-5387-b630-101288184fae","parent":{"id":"0384b347-d777-5cc3-943b-91771189a957","name":"07_Custom_Pages","relativePath":"Frontend/Gatsby/07_Custom_Pages.md"},"frontmatter":{"title":"07. Gatsby 커스텀 페이지 생성","createdAt":"2023-06-27","updatedAt":"2023-06-27"},"excerpt":"1. 튜토리얼 방식의 한계 Gatsby 튜토리얼 Part6 를 보면 file system routes라고 해서 파일시스템에 있는 파일들에 대해서 동적으로 페이지를 생성하는 방법을 소개한다. 예를 들어 아래 그림처럼 src/pages/아래에 {mdx…"},{"id":"19ad15a7-720c-5daf-880f-06af0a704144","parent":{"id":"daf85c35-0844-5cdb-8909-f001a0714f75","name":"08_Diretory_Based_Category","relativePath":"Frontend/Gatsby/08_Diretory_Based_Category.md"},"frontmatter":{"title":"08. 폴더 구조 기반 Gatsby 카테고리 바 생성","createdAt":"2023-06-28","updatedAt":"2023-06-28"},"excerpt":"1. GraphQL 아직 GraphQL을 파일시스템에 대해서 밖에 사용하지 않아, 정확히 GraphQL이 뭔지는 감이 안잡힌다. 하지만 그 제한된 경험으로도 GrqphQL이 기존 API…"},{"id":"6ae60c60-1e09-59a3-8a3c-f12ca9abd1c4","parent":{"id":"e5909625-6638-5137-b366-16bba9f61baf","name":"09_Markdown_Styling","relativePath":"Frontend/Gatsby/09_Markdown_Styling.md"},"frontmatter":{"title":"09. Gatsby 마크다운(md) 스타일링","createdAt":"2023-06-29","updatedAt":"2023-06-29"},"excerpt":"gatsby-transformer-remark플러그인을 통한 markdownRemark노드를 사용을 전제합니다. 1. 마크다운 스타일링 나는 분명 Gatsby 공식문서를 따라 gatsby-transformer-remark…"},{"id":"187472ff-d02f-5104-9b2e-515b0b1898f2","parent":{"id":"0a367c55-81a1-5059-8814-42d23ceac89a","name":"10_Table_of_Contents","relativePath":"Frontend/Gatsby/10_Table_of_Contents.md"},"frontmatter":{"title":"10. Gatsby 스크롤 반응형 목차(TOC) 생성","createdAt":"2023-06-30","updatedAt":"2023-06-30"},"excerpt":"1. URL 프래그먼트 식별자(#) 일단 프래그먼트 식별자(a.k.a. #)이 어떻게 동작하는 알 필요가 있다. 나는 평소 너무 당연하게 써왔지만, 어떻게 동작하는지는 한 번도 생각해보지 않았다. 사용자가 URL…"},{"id":"1e126097-6df5-5927-8c17-282ca0974e45","parent":{"id":"86d49b0e-e662-5a09-8fa5-8d69829c899f","name":"11_utterances_giscus","relativePath":"Frontend/Gatsby/11_utterances_giscus.md"},"frontmatter":{"title":"11. Gatsby 댓글 및 좋아요 기능","createdAt":"2023-07-02","updatedAt":"2023-07-02"},"excerpt":"1. Utterances와 Giscus 따로 서버를 돌리지 않고서는 댓글/좋아요 기능을 구현할 수 없을 줄 알았다. 그런데 항상 개발자들은 신박한 방법을 찾아낸다. GitHub API…"}]}},"pageContext":{"pagePath":"posts/Frontend/Gatsby/02_Github_Pages.md","regex":"/^(?!.*README).*Frontend\\/Gatsby.*$/","relativeDirectory":"Gatsby","id":"9aebcdb2-63dc-552b-b521-6c16e309d09b","parent":{"id":"7fbea288-e615-5f15-96a9-d71745462e2c","name":"02_Github_Pages","relativePath":"Frontend/Gatsby/02_Github_Pages.md"}}},"staticQueryHashes":["3300660363","522921546"],"slicesMap":{}}