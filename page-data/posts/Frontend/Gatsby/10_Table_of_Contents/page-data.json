{"componentChunkName":"component---src-templates-post-index-tsx","path":"/posts/Frontend/Gatsby/10_Table_of_Contents/","result":{"data":{"markdownRemark":{"id":"187472ff-d02f-5104-9b2e-515b0b1898f2","html":"<h1 id=\"1-url-프래그먼트-식별자\" style=\"position:relative;\"><a href=\"#1-url-%ED%94%84%EB%9E%98%EA%B7%B8%EB%A8%BC%ED%8A%B8-%EC%8B%9D%EB%B3%84%EC%9E%90\" aria-label=\"1 url 프래그먼트 식별자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. URL 프래그먼트 식별자(#)</h1>\n<p>일단 프래그먼트 식별자(a.k.a. #)이 어떻게 동작하는 알 필요가 있다.<br>\n나는 평소 너무 당연하게 써왔지만, 어떻게 동작하는지는 한 번도 생각해보지 않았다.</p>\n<ol>\n<li>사용자가 URL을 입력하거나 링크를 클릭합니다.</li>\n<li>브라우저는 URL을 파싱하여 호스트, 포트 번호, 경로, 쿼리, 프래그먼트로 구분한다.</li>\n<li>페이지 렌더링이 완료되면, 브라우저가 프래그먼트 식별자를 처리한다.</li>\n<li>페이지에서 프래그먼트 식별자와 동일한 ID를 가진요소를 검색한다.</li>\n<li>요소가 발견되면, 브라우저는 해당 요소로 스크롤하여 사용자를 이동시킨다.</li>\n<li>만약 프래그먼트 식별자에 해당하는 요소가 없는 경을 경우, 별도로 추가 동작하지 않는다.</li>\n</ol>\n<p>이런 사전 지식을 알고 있을 때, <code>gatsby-remark-autolink-headers</code>플러그인의 역할을 이해할 수 있다.</p>\n<h2 id=\"11-gatsby-remark-autolink-headers\" style=\"position:relative;\"><a href=\"#11-gatsby-remark-autolink-headers\" aria-label=\"11 gatsby remark autolink headers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1. gatsby-remark-autolink-headers</h2>\n<p>gatsby-remark-autolink-headers의 역할은 대표적으로 두 가지이다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/c18b6697204b330f309c5936f36eb400/ec09f/gatsby-remark-autolink-headers.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 53.14285714285714%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABJ0AAASdAHeZh94AAACJ0lEQVR42j2SWY7eNhCEdf8j+DZ5iIMssPNgYMYzzkS/tVGkNoq7KOkzJC8NFJsE2I2qQhXWe2TTMPQ9quvuPinFpAYmKe+u1EDbCbqup+sEQkjqRtDVHc3jQVULvlYt0zRTeKPxTUWUgiBafN8Rp5EwDgQl2VbNtucbQ7+yCElXD6hhxdpE8o4QEj5kVmMptu1k244badtJaWdL8Tu2dCPnjauiSxh5MV/oZWCZPfPiCfGaPwkhUPTt71Tle5rqb768/EZb/8VxfF8A5306axnHiXEo+f+tpqoEsh+QQjEIgRI9XdsyqleKzy8fefvvA19e/uTl+Q/q6tMPVjs/62Ib00YKJaKTvFULr43nc+V4rS3PD8vTY6ZXzxSr8SzaorVjNQHjItb5m/7P2nP+cfOs80zbzZSdp+ktg86o9WRxByHOFMexE4LHh4DTE2NbEsxCiBkfN2LK5Jw5j4Njz5hRYxeLXx3OeFKI7NGSnMe7QGGtwXuPsY6lK2k+vWcVJauNGB8JccMYi5KScVD0naBv2zteslfUVUVbPajKkmmeKS4hx3HcDFdZ0T79gx2aW7oJiXyCd4551mjrSTmT94OUd7Ztx7rAaj3aWMZporjYKaWQUjGLr/Sv/+InweoTzjjOp2eSc1g1YPSCXldijL/8vey43pfn1lqKeV7QWt+yvbOk4Dn3neMKjbXw7h1Ra9z1x1rmRRNCvCN1nue9MKUrrxvOOb4BmTtHW7maabEAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/TIL/static/c18b6697204b330f309c5936f36eb400/c54d4/gatsby-remark-autolink-headers.webp 175w,\n/TIL/static/c18b6697204b330f309c5936f36eb400/a3432/gatsby-remark-autolink-headers.webp 350w,\n/TIL/static/c18b6697204b330f309c5936f36eb400/426ac/gatsby-remark-autolink-headers.webp 700w,\n/TIL/static/c18b6697204b330f309c5936f36eb400/c139f/gatsby-remark-autolink-headers.webp 1050w,\n/TIL/static/c18b6697204b330f309c5936f36eb400/7f403/gatsby-remark-autolink-headers.webp 1400w,\n/TIL/static/c18b6697204b330f309c5936f36eb400/3d7de/gatsby-remark-autolink-headers.webp 1916w\" sizes=\"(max-width: 700px) 100vw, 700px\" type=\"image/webp\">\n          <source srcset=\"/TIL/static/c18b6697204b330f309c5936f36eb400/4edbd/gatsby-remark-autolink-headers.png 175w,\n/TIL/static/c18b6697204b330f309c5936f36eb400/13ae7/gatsby-remark-autolink-headers.png 350w,\n/TIL/static/c18b6697204b330f309c5936f36eb400/8c557/gatsby-remark-autolink-headers.png 700w,\n/TIL/static/c18b6697204b330f309c5936f36eb400/e996b/gatsby-remark-autolink-headers.png 1050w,\n/TIL/static/c18b6697204b330f309c5936f36eb400/2cefc/gatsby-remark-autolink-headers.png 1400w,\n/TIL/static/c18b6697204b330f309c5936f36eb400/ec09f/gatsby-remark-autolink-headers.png 1916w\" sizes=\"(max-width: 700px) 100vw, 700px\" type=\"image/png\">\n          <img class=\"gatsby-resp-image-image\" src=\"/TIL/static/c18b6697204b330f309c5936f36eb400/8c557/gatsby-remark-autolink-headers.png\" alt=\"gatsby-remark-autolink-headers.png\" title=\"\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span>\n<ul>\n<li><strong>헤더에 id 추가</strong><br>\n헤더 요소에 프래그먼트 식별자에 대응하는 id가 추가되어야, 브라우저가 스크롤을 이동시킬 수 있다.</li>\n<li><strong>헤더에 &#x3C;a/> 태그 추가</strong><br>\n헤더 요소에 추가되는 &#x3C;a/> 태그는, 눌렀을 때 자기 자신의 위치로 이동하는 프래그먼트 url값을 가진다.</li>\n</ul>\n<p>적용 방법은 그냥 <a href=\"https://www.gatsbyjs.com/plugins/gatsby-remark-autolink-headers/\">공식문서</a>를 따라하면 된다.</p>\n<h1 id=\"2-toc-생성\" style=\"position:relative;\"><a href=\"#2-toc-%EC%83%9D%EC%84%B1\" aria-label=\"2 toc 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. TOC 생성</h1>\n<p><code>markdownRemark</code>노드를 사용하느냐, <code>MDX</code>노드를 사용하느냐에 따라서 <code>tableOfContents</code>필드 값의 형태가 다른 것으로 알고 있다. <mark>하지만 형태는 중요하지 않다.</mark> 어차피 &#x3C;a/>태그가 적용되어 프래그먼트 식별자로 이동하는 동작 자체는 동일하기 때문이다.</p>\n<p><code>markdownRemark</code>노드를 사용할 경우, <code>&#x3C;ul></code>구조의 문자열 html이 검색되기 때문에, 아래와 같이 그대로 <code>dangerouslySetInnerHTML</code>에 내려주면 된다.</p>\n<pre><code class=\"language-js\">import React from 'react'\n\n// toc는 페이지 쿼리로부터 상속 받은 markdownRemark.tableOfContents 값이다.\nconst TableOfContent: React.FC = ({ toc }) => {\n  return &#x3C;div className=\"toc\" dangerouslySetInnerHTML={{ __html: toc }} />\n}\n\nexport default TableOfContent\n</code></pre>\n<h1 id=\"3-스크롤-이벤트\" style=\"position:relative;\"><a href=\"#3-%EC%8A%A4%ED%81%AC%EB%A1%A4-%EC%9D%B4%EB%B2%A4%ED%8A%B8\" aria-label=\"3 스크롤 이벤트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 스크롤 이벤트</h1>\n<p>이제 스크롤 이벤트를 걸어 아래와 같이 상호작용하는 toc를 만들 것이다.</p>\n<p><img src=\"/TIL/57ecc736859c0c5428cad3418f383b38/interactive-toc.gif\" alt=\"./images/interactive-toc.gif\"></p>\n<p>나는 내가 생각해낸 방법이 꽤나 마음에 드는데, 그림과 함께 설명하면 다음과 같다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 575px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/f9909b00cefe082909d31f64f95de1ba/59415/toc-algorithm.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 133.71428571428572%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAABJ0AAASdAHeZh94AAAEP0lEQVR42o2VSW/bRhxH8ym7oEmBAumlh556a68J0M+QBE2LIkXRtLWNuJGdZhNsy6J2y4sWW9x3SqSWWBvFV5B0HBmW0RD4gUNB8/if4cybW4qiEEeSJERRRJZlgiDA8zx0XUdV1ctomoplaliWjmmkz6ahJb9pWsq5lcJkbMui67l4rsvrVy+pVsoM+gHRImQRhhCFjMchXX9KW3QpVk9ptaXkXqyc0miJqOolUMJxHDzXwbZM1tf+Rsjv4/e6EC2IFgtgQdePqDfP2StpbGwfUq2fkXl9wtPNOjv5FoaupsB4mLZtQRQRRXHn+LpoLwG9Xojfh/nsHF1T0HUVw1CT4evLQ06AlpVAuISEyQtYhETxkAnxuiF+sGAyHiKKEmnfD1maQwnXthElEVGRefT4MZuZDLKiprVGac2uH+EPYDoZJX3ef9DlpEBZxnUcuq0mQauJVilj1KoErRa4DpFtQ9em27bpnzlMB37S50agrCi4gsBsb49x5wzpzRvsgsC01QRJJBJFUEV6ByL92hnTcgFJ1VBWQG8phoFarfLu/j2OnvzKSVHgwY/32fj5Jxq5Xeh5LDwXAhdP9PDPbCZ7WcQYuLJCTcPY2qLbaIJmgayD6XxoSyqRqIKq0jtQ6ddV5q6LrKqrgerBAdbbLMXjGkLpOQfHWerNXeqNXQ6baeL2cSvLm/weO8UchdILms0WmqatANaq2Lkiz54/RK58gtP+Gq3+RZrD2+hHd9AOv8Tv3EU8+gG78z3F7Dfk82Usy0yW3FVgtYy9K7D96hcC6SvG1rd0T+/gND/DaX5Ot30b6+RTzo27uNp93nXv0ah+hyBUsEzjOlDpdHBevGQr85SB84xovEM0zSUhzmyfaLYP4S62kWM0KHNc+528UFxdoWwYmKUSbx88ZDyPCOcXG2QB8znMZvFCTjfR0emChgQnx4fk8wKWZa0AyjK6abL11zqttoxu2Gy/eE2hUEnaw+E4yWg0xg/Omcwgt19CEARM8wagoWusb26zlz+gfSry5Lc/EmijccpsDtNZlGY6T7bg290yhUI+qVBRVgENg8zzTDLRxXKd+lGLau2YQumAfaFCLl9BKJR5la2xkzthczNDuVxF143EpYqa7rYrtontHAS9JH7PI4jjd+n3ffpBj9Gwh6wG1I5c1jLHPFmrkS+1+Tfb4M9/DinXzhKdLfnQ5qbrvW08P6LXh+FoRLMlJsrqiHJi7qTS5QqtCx+mUo0usvhwBBDidEN6QcR0Mryir1j9V/UlSXieS7vVTPLo4QM21tfonJ2mL4llu2TsyXh0Kdj3kr0GdBybwO8xHPRRZAnT0OkH/gUwPQLcXlzhRwj28kxZnrB4JRNdP1MGHw20r4KWEkXpvaMu6Kgwm777f6BpmsxmU6bTybVMJhPC+QTLnaCZU0bD/uVXXQn8mMQTHx+VpqGgyDf/7z+6t7G/cHF/8gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/TIL/static/f9909b00cefe082909d31f64f95de1ba/c54d4/toc-algorithm.webp 175w,\n/TIL/static/f9909b00cefe082909d31f64f95de1ba/a3432/toc-algorithm.webp 350w,\n/TIL/static/f9909b00cefe082909d31f64f95de1ba/039fe/toc-algorithm.webp 575w\" sizes=\"(max-width: 575px) 100vw, 575px\" type=\"image/webp\">\n          <source srcset=\"/TIL/static/f9909b00cefe082909d31f64f95de1ba/4edbd/toc-algorithm.png 175w,\n/TIL/static/f9909b00cefe082909d31f64f95de1ba/13ae7/toc-algorithm.png 350w,\n/TIL/static/f9909b00cefe082909d31f64f95de1ba/59415/toc-algorithm.png 575w\" sizes=\"(max-width: 575px) 100vw, 575px\" type=\"image/png\">\n          <img class=\"gatsby-resp-image-image\" src=\"/TIL/static/f9909b00cefe082909d31f64f95de1ba/59415/toc-algorithm.png\" alt=\"toc-algorithm.png\" title=\"\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span>\n<ol>\n<li>위에서 부터 순서대로 탐색하며 <code>.active</code>클래스를 없애준다.</li>\n<li>헤더의 <code>top(상단 위치)</code>이 설정한 THRESHOLD보다 커지는 <strong>첫번째 헤더</strong>를 찾는다.</li>\n<li>그럼 <mark>해당 헤더가 아닌, 그 윗 헤더에 <code>.active</code>클래스를 달아주고</mark></li>\n<li><code>isSet</code>이라는 변수의 값을 <code>false</code>라면 설정한다.</li>\n<li><code>isSet</code>라면 <code>top</code>이 <code>THRESHOLD</code>보다 크더라도, 무시하고 <code>.active</code>클래스를 없애준다.</li>\n<li>만약 마지막 요소를 순회할 때 까지 <code>isSet</code>이 <code>false</code>라면, 마지막 헤더에 <code>.active</code>클래스를 달아준다.</li>\n</ol>\n<p>여기서 생각보다 중요한 점은 <code>.active</code>를 <strong>추가</strong>해야하는 요소 말고도, 다른 요소들에 대해서 <code>.active</code>를 <strong>제거</strong>해줘야 한다. 안 그러면 스크롤을 아주 빠르게 반복적으로 이동시켰을 때, 생각처럼 동작하지 않았다.</p>\n<p>위 기능을 하나의 <code>useEffect</code>안에 구현하면 다음과 같다.</p>\n<pre><code class=\"language-js\">useEffect(() => {\n  const handleScroll = function () {\n    const TOP_THRESHOLD = 50\n    const headerElements = document.querySelectorAll(\n      '.markdown-body h1, .markdown-body h2, .markdown-body h3'\n    ) // toc 스크롤 기능을 적용하고자하는 헤더를 선택한다.\n\n    let isSet = false\n    for (let idx = 0; idx &#x3C; headerElements.length; idx++) {\n      const headerElement = headerElements[idx]\n      const { top } = headerElement.getBoundingClientRect() // 현재 뷰포인트 기준, 요소의 상단 상대적 위치\n\n      // toc에서 헤더 id에 대응하는 요소를 탐색\n      const id = encodeURI(headerElement.id) // 한글을 url 형식으로 인코딩\n      const tocElement = document.querySelector(`.toc a[href=\"#${id}\"]`)\n\n      if (!(tocElement instanceof HTMLAnchorElement)) return // 대응하는 toc 요소가 없으면 종료(비정상)\n\n      // 조건에 만족하는 첫번째 헤더를 찾았을 때\n      if (top > TOP_THRESHOLD &#x26;&#x26; !isSet) {\n        isSet = true\n        tocElement.classList.remove('active') // 현제 헤더는 active 클래스 제거\n        // 이전 헤더를 찾아 active 클래스 추가\n        if (idx &#x3C; 1) continue\n        const previousHeaderElement = headerElements[idx - 1]\n        const previousId = encodeURI(previousHeaderElement.id)\n        const previousTocElement = document.querySelector(\n          `.toc a[href=\"#${previousId}\"]`\n        )\n        previousTocElement.classList.add('active')\n        continue\n      }\n\n      // 그 외의 헤더들은 모두 active 클래스 제거\n      tocElement.classList.remove('active')\n    }\n\n    // 모든 헤더를 탐색 완료했을 때까지 isSet이 false이면, 마지막 헤더에 active 클래스 추가\n    if (!isSet) {\n      const headerElement = headerElements[headerElements.length - 1]\n      const id = encodeURI(headerElement.id)\n      const tocElement = document.querySelector(`.toc a[href=\"#${id}\"]`)\n      tocElement.classList.add('active')\n    }\n  }\n\n  const throttledHandleScroll = throttle(handleScroll, 100) // 연속해서 이벤트 발생 시, 최소 0.1초 간격으로 실행. lodash.throttle\n\n  window.addEventListener('scroll', throttledHandleScroll)\n\n  return () => {\n    // clean-up\n    window.removeEventListener('scroll', throttledHandleScroll)\n  }\n}, [])\n</code></pre>\n<h1 id=\"4-참조\" style=\"position:relative;\"><a href=\"#4-%EC%B0%B8%EC%A1%B0\" aria-label=\"4 참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 참조</h1>\n<ul>\n<li><a href=\"https://www.gatsbyjs.com/plugins/gatsby-remark-autolink-headers/\">gatsby-remark-autolink-headers</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-url-%ED%94%84%EB%9E%98%EA%B7%B8%EB%A8%BC%ED%8A%B8-%EC%8B%9D%EB%B3%84%EC%9E%90\">1. URL 프래그먼트 식별자(#)</a></p>\n<ul>\n<li><a href=\"#11-gatsby-remark-autolink-headers\">1.1. gatsby-remark-autolink-headers</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-toc-%EC%83%9D%EC%84%B1\">2. TOC 생성</a></p>\n</li>\n<li>\n<p><a href=\"#3-%EC%8A%A4%ED%81%AC%EB%A1%A4-%EC%9D%B4%EB%B2%A4%ED%8A%B8\">3. 스크롤 이벤트</a></p>\n</li>\n<li>\n<p><a href=\"#4-%EC%B0%B8%EC%A1%B0\">4. 참조</a></p>\n</li>\n</ul>","frontmatter":{"title":"10. Gatsby 스크롤 반응형 목차(TOC) 생성","createdAt":"2023-06-30","updatedAt":"2023-06-30","tags":["gatsby","반응형 목차","toc","스크롤"],"description":"스크롤 이벤트를 활용한 반응형 목차(toc)를 구현한다.","reference":null}},"allMarkdownRemark":{"nodes":[{"id":"1e126097-6df5-5927-8c17-282ca0974e45","excerpt":"1. Utterances와 Giscus 따로 서버를 돌리지 않고서는 댓글/좋아요 기능을 구현할 수 없을 줄 알았다. 그런데 항상 개발자들은 신박한 방법을 찾아낸다. GitHub API…","parent":{"id":"86d49b0e-e662-5a09-8fa5-8d69829c899f","name":"11_utterances_giscus","relativePath":"Frontend/Gatsby/11_utterances_giscus.md"},"frontmatter":{"title":"11. Gatsby 댓글 및 좋아요 기능","createdAt":"2023-07-02","updatedAt":"2023-07-02"},"fields":{"slug":"/posts/Frontend/Gatsby/11_utterances_giscus/"}},{"id":"187472ff-d02f-5104-9b2e-515b0b1898f2","excerpt":"1. URL 프래그먼트 식별자(#) 일단 프래그먼트 식별자(a.k.a. #)이 어떻게 동작하는 알 필요가 있다. 나는 평소 너무 당연하게 써왔지만, 어떻게 동작하는지는 한 번도 생각해보지 않았다. 사용자가 URL…","parent":{"id":"0a367c55-81a1-5059-8814-42d23ceac89a","name":"10_Table_of_Contents","relativePath":"Frontend/Gatsby/10_Table_of_Contents.md"},"frontmatter":{"title":"10. Gatsby 스크롤 반응형 목차(TOC) 생성","createdAt":"2023-06-30","updatedAt":"2023-06-30"},"fields":{"slug":"/posts/Frontend/Gatsby/10_Table_of_Contents/"}},{"id":"6ae60c60-1e09-59a3-8a3c-f12ca9abd1c4","excerpt":"gatsby-transformer-remark플러그인을 통한 markdownRemark노드를 사용을 전제합니다. 1. 마크다운 스타일링 나는 분명 Gatsby 공식문서를 따라 gatsby-transformer-remark…","parent":{"id":"e5909625-6638-5137-b366-16bba9f61baf","name":"09_Markdown_Styling","relativePath":"Frontend/Gatsby/09_Markdown_Styling.md"},"frontmatter":{"title":"09. Gatsby 마크다운(md) 스타일링","createdAt":"2023-06-29","updatedAt":"2023-06-29"},"fields":{"slug":"/posts/Frontend/Gatsby/09_Markdown_Styling/"}},{"id":"19ad15a7-720c-5daf-880f-06af0a704144","excerpt":"1. GraphQL 아직 GraphQL을 파일시스템에 대해서 밖에 사용하지 않아, 정확히 GraphQL이 뭔지는 감이 안잡힌다. 하지만 그 제한된 경험으로도 GrqphQL이 기존 API…","parent":{"id":"daf85c35-0844-5cdb-8909-f001a0714f75","name":"08_Diretory_Based_Category","relativePath":"Frontend/Gatsby/08_Diretory_Based_Category.md"},"frontmatter":{"title":"08. 폴더 구조 기반 Gatsby 카테고리 바 생성","createdAt":"2023-06-28","updatedAt":"2023-06-28"},"fields":{"slug":"/posts/Frontend/Gatsby/08_Diretory_Based_Category/"}},{"id":"8dd7c7ba-002c-5398-92a5-b43faf1f595b","excerpt":"1. SSG 렌더링 React에서는 Nested Route로 손 쉽게 레이아웃을 구현할 수 있다. 그런데 Gatsby는 Single Page Application이 아니다! Gatsby는 정적 사이트 생성기(SSG)로 빌드 시에, 모든 url…","parent":{"id":"7dc89b39-7e64-5368-9d05-118f4f02d985","name":"06_Navigation_Layout","relativePath":"Frontend/Gatsby/06_Navigation_Layout.md"},"frontmatter":{"title":"06. Gatsby 네비게이션 레이아웃 설정","createdAt":"2023-06-27","updatedAt":"2023-06-27"},"fields":{"slug":"/posts/Frontend/Gatsby/06_Navigation_Layout/"}},{"id":"f2e3f78d-324e-5387-b630-101288184fae","excerpt":"1. 튜토리얼 방식의 한계 Gatsby 튜토리얼 Part6 를 보면 file system routes라고 해서 파일시스템에 있는 파일들에 대해서 동적으로 페이지를 생성하는 방법을 소개한다. 예를 들어 아래 그림처럼 src/pages/아래에 {mdx…","parent":{"id":"0384b347-d777-5cc3-943b-91771189a957","name":"07_Custom_Pages","relativePath":"Frontend/Gatsby/07_Custom_Pages.md"},"frontmatter":{"title":"07. Gatsby 커스텀 페이지 생성","createdAt":"2023-06-27","updatedAt":"2023-06-27"},"fields":{"slug":"/posts/Frontend/Gatsby/07_Custom_Pages/"}},{"id":"a0a6e020-13b3-5b8c-a3a9-731d0b01e16c","excerpt":"아래 내용은 주관적인 의견이고, 카카오 FE 기술 블로그의 내용을 참조했습니다. 1. Sass 다크모드 한동안 다크모드를 공부한 적이 있다. Styled Component와 같은 CSS-in-JS…","parent":{"id":"f070924b-4b2c-5a2e-ae60-efbd70ce23c9","name":"05_Dark_Mode","relativePath":"Frontend/Gatsby/05_Dark_Mode.md"},"frontmatter":{"title":"05. Gatsby 다크모드 구현하기 (feat. Sass)","createdAt":"2023-06-26","updatedAt":"2023-06-26"},"fields":{"slug":"/posts/Frontend/Gatsby/05_Dark_Mode/"}},{"id":"e2e850af-877e-5cc3-afc7-00362ed5273d","excerpt":"1. 개요 1.1. Prettier & ESLint란? Prettier와 ESLint는 각각 코드 포맷팅(Code Formatting)과 린팅(Linting…","parent":{"id":"8e077755-e170-50a6-a0b5-964d3835ef5d","name":"04_ESLint_Prettier","relativePath":"Frontend/Gatsby/04_ESLint_Prettier.md"},"frontmatter":{"title":"04. Gatsby 프로젝트 Prettier & ESLint & Husky 설정","createdAt":"2023-06-25","updatedAt":"2023-06-25"},"fields":{"slug":"/posts/Frontend/Gatsby/04_ESLint_Prettier/"}},{"id":"3e2351da-7a0c-5c18-b503-c4358b27ab8f","excerpt":"1. import 경로 프로젝트를 진행하다 보면, import 절대경로를 설정하지 않을 수 없다.\n심지어 어쩌다가 한 번, IDE에서 자동 import…","parent":{"id":"cc5bee56-affb-555b-95d9-325b948e4870","name":"03_Import_Settings","relativePath":"Frontend/Gatsby/03_Import_Settings.md"},"frontmatter":{"title":"03. Gatsby 프로젝트(TypeScript) import 경로 설정","createdAt":"2023-06-24","updatedAt":"2023-06-24"},"fields":{"slug":"/posts/Frontend/Gatsby/03_Import_Settings/"}},{"id":"9aebcdb2-63dc-552b-b521-6c16e309d09b","excerpt":"1. 프론트엔드 배포란? 프론트엔드 배포를 한 마디로 정리하면, 특정 url을 통한 GET요청에 대해 index.html…","parent":{"id":"7fbea288-e615-5f15-96a9-d71745462e2c","name":"02_Github_Pages","relativePath":"Frontend/Gatsby/02_Github_Pages.md"},"frontmatter":{"title":"02. Gatsby 프로젝트 Github Pages 배포","createdAt":"2023-06-23","updatedAt":"2023-06-23"},"fields":{"slug":"/posts/Frontend/Gatsby/02_Github_Pages/"}},{"id":"94b436d7-15e2-57c6-8d40-52cf418e46e6","excerpt":"시작하기 앞서... Gatsby로 Markdown기반의 블로그를 만들려고 한다면, Gatsby 공식문서를 보는 것을 추천한다. 맞춤형 강의라고 해도 믿을 만큼 잘 정리되어 있기 때문이다. 때문에 나는 앞으로 Gatsby…","parent":{"id":"ce161dd8-00d5-50d2-8c0d-578dd75f7c94","name":"01_Gatsby","relativePath":"Frontend/Gatsby/01_Gatsby.md"},"frontmatter":{"title":"01. Gatsby 렌더링 옵션과 프로젝트 구조","createdAt":"2023-06-16","updatedAt":"2023-06-16"},"fields":{"slug":"/posts/Frontend/Gatsby/01_Gatsby/"}}]}},"pageContext":{"pagePath":"/posts/Frontend/Gatsby/10_Table_of_Contents/","siblingPostsPathRegex":"/^(?!.*README).*Frontend\\/Gatsby\\/.*$/","relativeDirectory":"Gatsby","id":"187472ff-d02f-5104-9b2e-515b0b1898f2","parent":{"id":"0a367c55-81a1-5059-8814-42d23ceac89a","name":"10_Table_of_Contents","relativePath":"Frontend/Gatsby/10_Table_of_Contents.md"},"fields":{"slug":"/posts/Frontend/Gatsby/10_Table_of_Contents/"}}},"staticQueryHashes":["24302420","4059933791"],"slicesMap":{}}