{"componentChunkName":"component---src-templates-post-index-tsx","path":"/posts/Frontend/Gatsby/07_Custom_Pages/","result":{"data":{"markdownRemark":{"id":"f2e3f78d-324e-5387-b630-101288184fae","html":"<h1 id=\"1-튜토리얼-방식의-한계\" style=\"position:relative;\"><a href=\"#1-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-%EB%B0%A9%EC%8B%9D%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-label=\"1 튜토리얼 방식의 한계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 튜토리얼 방식의 한계</h1>\n<p><a href=\"https://www.gatsbyjs.com/docs/tutorial/getting-started/part-6/\">Gatsby 튜토리얼 Part6</a> 를 보면 <strong>file system routes</strong>라고 해서 파일시스템에 있는 파일들에 대해서 동적으로 페이지를 생성하는 방법을 소개한다.</p>\n<p>예를 들어 아래 그림처럼 <code>src/pages/</code>아래에 <code>{mdx.frontmatter_slug}</code>라는 파일을 만들면, 파일 시스템이 관측하는 모든 mdx의 문서에 대해서 <code>{mdx.frontmatter_slug}</code>라는 url로 페이지를 만들어 준다. 더 자세하게 말하면, <code>gatsby-config</code>파일에서 <code>gatsby-source-filesystem</code>가 관측하는 경로의 모든 mdx파일에 대해서 페이지를 만들어준다</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/357bb7fe824bb64e811622bb947a8b1b/efa1a/file-system-routes.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 67.42857142857143%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABUElEQVR42pWSy04DMQxF5/9/DbEEFiwQUBbTmVGTaV7zykXXraO0tCAiWbGd+MR23MQYcwwBx3FECAE/VgZyziI476LfWNu25YbKu3d4864cPFkDuyzKk2XmCc+jxV9LgK99h5f9/gTIGQ+fHxi8F3ueZwTnsRsGPH7tINUc3X0gAdF7+PFYsjkagykl0adpwuFwgDUGzlpYa8W+C1zXFcu6Yl4WUBe70rdtk6y501/r9T2VhiUxC34IdSkxBPHpGSWlhBBi8SmMu8ZRCjDGVJwppgJUoe2ck3sxRhjD0s3FZBBeAeNFcA27vsNsCR/Po8YWMFvJ8BR86g1foO29Lz2qgdoKAgmnveh4neMb7Yc6GNz3gwTdAtJPads92rYtI3QB1Ffrht/qYV1yPRH06d5c9+o3IVCl63p0XSfC3y+fMk1T/g9Us9XSCddqUkr5Gz6b+mkoRsYHAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"file-system-routes.png\" title=\"\" src=\"/TIL/static/357bb7fe824bb64e811622bb947a8b1b/8c557/file-system-routes.png\" srcset=\"/TIL/static/357bb7fe824bb64e811622bb947a8b1b/4edbd/file-system-routes.png 175w,\n/TIL/static/357bb7fe824bb64e811622bb947a8b1b/13ae7/file-system-routes.png 350w,\n/TIL/static/357bb7fe824bb64e811622bb947a8b1b/8c557/file-system-routes.png 700w,\n/TIL/static/357bb7fe824bb64e811622bb947a8b1b/e996b/file-system-routes.png 1050w,\n/TIL/static/357bb7fe824bb64e811622bb947a8b1b/2cefc/file-system-routes.png 1400w,\n/TIL/static/357bb7fe824bb64e811622bb947a8b1b/efa1a/file-system-routes.png 2040w\" sizes=\"(max-width: 700px) 100vw, 700px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>위 방법으로 간단하게 모든 파일에 대응되는 페이지를 만들 수 있었지만, 나한테는 적합하지 않았다. 왜냐하면 나는 <mark>모든 파일이 아닌 <strong>필터링된 일부 파일</strong></mark>에 대해서만 페이지를 만들고 싶었기 때문이다. 개인적인 상황을 좀 더 구체적으로 말하자면, 내 *.md 파일들의 frontmatter는 다음처럼 구성되어 있다. 나는 이 중 <code>isCompleted: true</code>인 파일들에 대해서만 페이지를 만들고 싶었다. <del>내가 의욕이 많은 편이라 isCompleted가 false 문서가 많다</del></p>\n<pre><code class=\"language-text\">---\ntitle: ''\nupdatedAt: 'YYYY-MM-DD'\ncreatedAt: 'YYYY-MM-DD'\nisCompleted: boolean\ndescription: ''\ntags: ['']\nreference: ''\n---\n</code></pre>\n<h1 id=\"2-createpage\" style=\"position:relative;\"><a href=\"#2-createpage\" aria-label=\"2 createpage permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. CreatePage</h1>\n<p>Gatsby는 나 같은 사람들을 위해서 또 node API를 만들었다. node API 중 <code>createPages</code>를 이용하면, 프로그래밍적으로 내가 원하는 커스텀 페이지를 만들 수 있다.</p>\n<h1 id=\"21-gatsby-node\" style=\"position:relative;\"><a href=\"#21-gatsby-node\" aria-label=\"21 gatsby node permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. gatsby-node</h1>\n<p>페이지를 만드는 작업은 빌드 시에 일어나기 때문에, 당연히 <code>createPages</code>는 Node API 이다. 그리고 Node API이기 때문에 <code>gatsby-node</code>파일에 작성한다.</p>\n<p>사용 예시가 <a href=\"https://www.gatsbyjs.com/docs/programmatically-create-pages-from-data/\">공식문서</a>에 잘 정리되어 있어, 나는 그냥 따라서 코드를 작성했다.</p>\n<p>한 가지 특별히 설명하고 싶은 거는 <strong>pageContext</strong>이다. 마지막 <code>createPage</code>함수에 보면 <code>path</code>, <code>component</code>, <code>context</code>가 인자로 들어간다. 각각의 인자의 특징은 다음과 같다.</p>\n<ul>\n<li><strong>path</strong>\n<ul>\n<li>페이지의 url 경로.</li>\n</ul>\n</li>\n<li><strong>component</strong>\n<ul>\n<li>렌더링할 페이지 컴포넌트.</li>\n</ul>\n</li>\n<li><strong>context</strong>\n<ul>\n<li>페이지에 <code>pageContext</code>라는 이름으로 prop된다.</li>\n<li>페이지 query에서 인자로 바로 참조할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">// createPages API로 커스텀 페이지 생성\nexports.createPages = async ({ graphql, actions, reporter }) => {\n  const { createPage } = actions\n\n  // 페이지를 만들 md 데이터 수집\n  // 조건 1. frontmatter.isCompleted == true\n  // 조건 2. posts 디렉토리 내부 &#x26;&#x26; README 파일 제외\n  const posts = await graphql(\n    `\n      query AllPost {\n        allMarkdownRemark(\n          filter: {\n            frontmatter: { isCompleted: { eq: true } }\n            fileAbsolutePath: { regex: \"/^(?!.*README).*posts.*$/\" }\n          }\n        ) {\n          nodes {\n            id\n            parent {\n              ... on File {\n                id\n                name\n                relativeDirectory\n                relativePath\n              }\n            }\n          }\n        }\n      }\n    `\n  )\n\n  // 에러 처리\n  if (posts.errors) {\n    reporter.panicOnBuild(`Error while running GraphQL query.`)\n    return\n  }\n\n  // 사용할 템플릿(페이지) 컴포넌트\n  const postTemplate = path.resolve(`src/templates/post/index.tsx`)\n\n  // graphQL로 불러온 데이터를 순회하며 페이지 생성\n  posts.data.allMarkdownRemark.nodes.forEach((node) => {\n    const path = 'posts/' + node.parent.relativePath // url 경로 커스텀\n    const relativeDirectory = node.parent.relativePath // 추가로 내려주고 싶은 pageContext\n      .split('/')\n      .slice(0, -1)\n      .join('/')\n    const regex = new RegExp(\n      `^(?!.*README).*${relativeDirectory}.*$`\n    ).toString()\n\n    // 페이지 생성\n    createPage({\n      path: path, // url 경로\n      component: postTemplate, // 페이지 템플릿\n      context: {\n        // pageContext\n        siblingPostsPathRegex: regex,\n        ...node,\n      },\n    })\n  })\n}\n</code></pre>\n<h1 id=\"22-template-컴포넌트\" style=\"position:relative;\"><a href=\"#22-template-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\" aria-label=\"22 template 컴포넌트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2. template 컴포넌트</h1>\n<p>그러면 템플릿 컴포넌트에서는 다음과 같이 코드를 작성할 수 있다.</p>\n<p>앞서 말한 것처럼 <code>gatsby-node</code>파일에서 작성한 코드에서, <strong><code>createPage</code>함수에 <code>context</code>에 내려준 값은 페이지에 <code>pateContext</code>라는 prop으로 내려간다.</strong> 그 뿐 아니라, <mark>pageContext의 내부 값은 페이지 query에서 바로 참조할 수 있다.</mark></p>\n<p>그래서 나는 <code>pageContext</code>로 prop받은 markdownRemark의 <code>id</code>와 형제 포스트를 검색하기 위해 커스텀해서 내려준 정규식 <code>siblingPostsPathRegex</code>을 사용해서, 세부 정보를 위한 query를 만들었다.</p>\n<pre><code class=\"language-js\">import * as React from 'react'\nimport type { PageProps } from 'gatsby'\nimport { graphql } from 'gatsby'\n\nconst PostPage: React.FC&#x3C;PageProps> = ({ pageContext, data }) => {\n  console.log(pageContext) // createPage 함수에서 내려준 context\n\n  return &#x3C;div dangerouslySetInnerHTML={{ __html: data.markdownRemark.html }} />\n}\n\n// pageContext의 내부 값은 페이지 query에서 바로 참조 가능\nexport const query = graphql`\n  query PostDetail ($id: String!, $siblingPostsPathRegex: String!) {\n    markdownRemark(id: { eq: $id }) {\n      id\n      html\n      tableOfContents\n      frontmatter {\n        ...\n      }\n    }\n    allMarkdownRemark(\n      filter: {\n        frontmatter: { isCompleted: { eq: true } }\n        fileAbsolutePath: { regex: $siblingPostsPathRegex }\n      }\n    ) {\n      nodes {\n        ...\n      }\n    }\n  }\n`\n\nexport default PostPage\n</code></pre>\n<h1 id=\"3-참조\" style=\"position:relative;\"><a href=\"#3-%EC%B0%B8%EC%A1%B0\" aria-label=\"3 참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 참조</h1>\n<ul>\n<li><a href=\"https://www.gatsbyjs.com/docs/tutorial/getting-started/part-6/\">Gatsby Getting Started Part6</a> -<a href=\"https://www.gatsbyjs.com/docs/programmatically-create-pages-from-data/\">Gatsby Programatically Create Pages from Data</a></li>\n</ul>","tableOfContents":"<ul>\n<li><a href=\"#1-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-%EB%B0%A9%EC%8B%9D%EC%9D%98-%ED%95%9C%EA%B3%84\">1. 튜토리얼 방식의 한계</a></li>\n<li><a href=\"#2-createpage\">2. CreatePage</a></li>\n<li><a href=\"#21-gatsby-node\">2.1. gatsby-node</a></li>\n<li><a href=\"#22-template-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\">2.2. template 컴포넌트</a></li>\n<li><a href=\"#3-%EC%B0%B8%EC%A1%B0\">3. 참조</a></li>\n</ul>","frontmatter":{"title":"07. Gatsby 커스텀 페이지 생성","createdAt":"2023-06-27","updatedAt":"2023-06-27","tags":["gatsby","커스텀 페이지"],"description":"Gatsby에서 원하는 마크다운파일에 대한 커스텀 페이지를 생성한다.","reference":"https://www.gatsbyjs.com/docs/programmatically-create-pages-from-data/"}},"allMarkdownRemark":{"nodes":[{"id":"94b436d7-15e2-57c6-8d40-52cf418e46e6","excerpt":"시작하기 앞서... Gatsby로 Markdown기반의 블로그를 만들려고 한다면, Gatsby 공식문서를 보는 것을 추천한다. 맞춤형 강의라고 해도 믿을 만큼 잘 정리되어 있기 때문이다. 때문에 나는 앞으로 Gatsby…","parent":{"id":"ce161dd8-00d5-50d2-8c0d-578dd75f7c94","name":"01_Gatsby","relativePath":"Frontend/Gatsby/01_Gatsby.md"},"frontmatter":{"title":"01. Gatsby 렌더링 옵션과 프로젝트 구조","createdAt":"2023-06-16","updatedAt":"2023-06-16"},"fields":{"slug":"/posts/Frontend/Gatsby/01_Gatsby/"}},{"id":"9aebcdb2-63dc-552b-b521-6c16e309d09b","excerpt":"1. 프론트엔드 배포란? 프론트엔드 배포를 한 마디로 정리하면, 특정 url을 통한 GET요청에 대해 index.html…","parent":{"id":"7fbea288-e615-5f15-96a9-d71745462e2c","name":"02_Github_Pages","relativePath":"Frontend/Gatsby/02_Github_Pages.md"},"frontmatter":{"title":"02. Gatsby 프로젝트 Github Pages 배포","createdAt":"2023-06-23","updatedAt":"2023-06-23"},"fields":{"slug":"/posts/Frontend/Gatsby/02_Github_Pages/"}},{"id":"3e2351da-7a0c-5c18-b503-c4358b27ab8f","excerpt":"1. import 경로 프로젝트를 진행하다 보면, import 절대경로를 설정하지 않을 수 없다.\n심지어 어쩌다가 한 번, IDE에서 자동 import…","parent":{"id":"cc5bee56-affb-555b-95d9-325b948e4870","name":"03_Import_Settings","relativePath":"Frontend/Gatsby/03_Import_Settings.md"},"frontmatter":{"title":"03. Gatsby 프로젝트(TypeScript) import 경로 설정","createdAt":"2023-06-24","updatedAt":"2023-06-24"},"fields":{"slug":"/posts/Frontend/Gatsby/03_Import_Settings/"}},{"id":"e2e850af-877e-5cc3-afc7-00362ed5273d","excerpt":"1. 개요 1.1. Prettier & ESLint란? Prettier와 ESLint는 각각 코드 포맷팅(Code Formatting)과 린팅(Linting…","parent":{"id":"8e077755-e170-50a6-a0b5-964d3835ef5d","name":"04_ESLint_Prettier","relativePath":"Frontend/Gatsby/04_ESLint_Prettier.md"},"frontmatter":{"title":"04. Gatsby 프로젝트 Prettier & ESLint & Husky 설정","createdAt":"2023-06-25","updatedAt":"2023-06-25"},"fields":{"slug":"/posts/Frontend/Gatsby/04_ESLint_Prettier/"}},{"id":"a0a6e020-13b3-5b8c-a3a9-731d0b01e16c","excerpt":"아래 내용은 주관적인 의견이고, 카카오 FE 기술 블로그의 내용을 참조했습니다. 1. Sass 다크모드 한동안 다크모드를 공부한 적이 있다. Styled Component와 같은 CSS-in-JS…","parent":{"id":"f070924b-4b2c-5a2e-ae60-efbd70ce23c9","name":"05_Dark_Mode","relativePath":"Frontend/Gatsby/05_Dark_Mode.md"},"frontmatter":{"title":"05. Gatsby 다크모드 구현하기 (feat. Sass)","createdAt":"2023-06-26","updatedAt":"2023-06-26"},"fields":{"slug":"/posts/Frontend/Gatsby/05_Dark_Mode/"}},{"id":"8dd7c7ba-002c-5398-92a5-b43faf1f595b","excerpt":"1. SSG 렌더링 React에서는 Nested Route로 손 쉽게 레이아웃을 구현할 수 있다. 그런데 Gatsby는 Single Page Application이 아니다! Gatsby는 정적 사이트 생성기(SSG)로 빌드 시에, 모든 url…","parent":{"id":"7dc89b39-7e64-5368-9d05-118f4f02d985","name":"06_Navigation_Layout","relativePath":"Frontend/Gatsby/06_Navigation_Layout.md"},"frontmatter":{"title":"06. Gatsby 네비게이션 레이아웃 설정","createdAt":"2023-06-27","updatedAt":"2023-06-27"},"fields":{"slug":"/posts/Frontend/Gatsby/06_Navigation_Layout/"}},{"id":"f2e3f78d-324e-5387-b630-101288184fae","excerpt":"1. 튜토리얼 방식의 한계 Gatsby 튜토리얼 Part6 를 보면 file system routes라고 해서 파일시스템에 있는 파일들에 대해서 동적으로 페이지를 생성하는 방법을 소개한다. 예를 들어 아래 그림처럼 src/pages/아래에 {mdx…","parent":{"id":"0384b347-d777-5cc3-943b-91771189a957","name":"07_Custom_Pages","relativePath":"Frontend/Gatsby/07_Custom_Pages.md"},"frontmatter":{"title":"07. Gatsby 커스텀 페이지 생성","createdAt":"2023-06-27","updatedAt":"2023-06-27"},"fields":{"slug":"/posts/Frontend/Gatsby/07_Custom_Pages/"}},{"id":"19ad15a7-720c-5daf-880f-06af0a704144","excerpt":"1. GraphQL 아직 GraphQL을 파일시스템에 대해서 밖에 사용하지 않아, 정확히 GraphQL이 뭔지는 감이 안잡힌다. 하지만 그 제한된 경험으로도 GrqphQL이 기존 API…","parent":{"id":"daf85c35-0844-5cdb-8909-f001a0714f75","name":"08_Diretory_Based_Category","relativePath":"Frontend/Gatsby/08_Diretory_Based_Category.md"},"frontmatter":{"title":"08. 폴더 구조 기반 Gatsby 카테고리 바 생성","createdAt":"2023-06-28","updatedAt":"2023-06-28"},"fields":{"slug":"/posts/Frontend/Gatsby/08_Diretory_Based_Category/"}},{"id":"6ae60c60-1e09-59a3-8a3c-f12ca9abd1c4","excerpt":"gatsby-transformer-remark플러그인을 통한 markdownRemark노드를 사용을 전제합니다. 1. 마크다운 스타일링 나는 분명 Gatsby 공식문서를 따라 gatsby-transformer-remark…","parent":{"id":"e5909625-6638-5137-b366-16bba9f61baf","name":"09_Markdown_Styling","relativePath":"Frontend/Gatsby/09_Markdown_Styling.md"},"frontmatter":{"title":"09. Gatsby 마크다운(md) 스타일링","createdAt":"2023-06-29","updatedAt":"2023-06-29"},"fields":{"slug":"/posts/Frontend/Gatsby/09_Markdown_Styling/"}},{"id":"187472ff-d02f-5104-9b2e-515b0b1898f2","excerpt":"1. URL 프래그먼트 식별자(#) 일단 프래그먼트 식별자(a.k.a. #)이 어떻게 동작하는 알 필요가 있다. 나는 평소 너무 당연하게 써왔지만, 어떻게 동작하는지는 한 번도 생각해보지 않았다. 사용자가 URL…","parent":{"id":"0a367c55-81a1-5059-8814-42d23ceac89a","name":"10_Table_of_Contents","relativePath":"Frontend/Gatsby/10_Table_of_Contents.md"},"frontmatter":{"title":"10. Gatsby 스크롤 반응형 목차(TOC) 생성","createdAt":"2023-06-30","updatedAt":"2023-06-30"},"fields":{"slug":"/posts/Frontend/Gatsby/10_Table_of_Contents/"}},{"id":"1e126097-6df5-5927-8c17-282ca0974e45","excerpt":"1. Utterances와 Giscus 따로 서버를 돌리지 않고서는 댓글/좋아요 기능을 구현할 수 없을 줄 알았다. 그런데 항상 개발자들은 신박한 방법을 찾아낸다. GitHub API…","parent":{"id":"86d49b0e-e662-5a09-8fa5-8d69829c899f","name":"11_utterances_giscus","relativePath":"Frontend/Gatsby/11_utterances_giscus.md"},"frontmatter":{"title":"11. Gatsby 댓글 및 좋아요 기능","createdAt":"2023-07-02","updatedAt":"2023-07-02"},"fields":{"slug":"/posts/Frontend/Gatsby/11_utterances_giscus/"}}]}},"pageContext":{"pagePath":"/posts/Frontend/Gatsby/07_Custom_Pages/","siblingPostsPathRegex":"/^(?!.*README).*Frontend\\/Gatsby.*$/","relativeDirectory":"Gatsby","id":"f2e3f78d-324e-5387-b630-101288184fae","parent":{"id":"0384b347-d777-5cc3-943b-91771189a957","name":"07_Custom_Pages","relativePath":"Frontend/Gatsby/07_Custom_Pages.md"},"fields":{"slug":"/posts/Frontend/Gatsby/07_Custom_Pages/"}}},"staticQueryHashes":["24302420","4059933791"],"slicesMap":{}}