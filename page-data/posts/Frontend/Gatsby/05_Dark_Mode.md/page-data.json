{"componentChunkName":"component---src-templates-post-index-tsx","path":"/posts/Frontend/Gatsby/05_Dark_Mode.md/","result":{"data":{"markdownRemark":{"id":"a0a6e020-13b3-5b8c-a3a9-731d0b01e16c","html":"<blockquote>\n<p>아래 내용은 주관적인 의견이고, <a href=\"https://fe-developers.kakaoent.com/2021/211118-dark-mode/\">카카오 FE 기술 블로그</a>의 내용을 참조했습니다.</p>\n</blockquote>\n<h1 id=\"1-sass-다크모드\" style=\"position:relative;\"><a href=\"#1-sass-%EB%8B%A4%ED%81%AC%EB%AA%A8%EB%93%9C\" aria-label=\"1 sass 다크모드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Sass 다크모드</h1>\n<p>한동안 다크모드를 공부한 적이 있다. Styled Component와 같은 CSS-in-JS를 사용할 때는 나름 다크모드를 구현할 줄 알았는데, Sass와 같은 정적 CSS로 넘어오자 도저히 갈피를 못잡았기 때문이다.</p>\n<p>리액트 기반 프로젝트에서 Sass로 다크모드를 구현하기 위해서는 두가지 기능을 사용할 것이다. CSS variables와 Context API이다. <strong>CSS variables는 정적인 다크모드 UI를 구현하는데 사용할 것이다.</strong> 예를 들어, 다크모드일 때 배경색이 검은색으로 변하는 게 정적인 다크모드에 해당할 것이다.</p>\n<p><img src=\"/TIL/739a0418ad40c51caa10b94c5a9a2139/static-dark-mode.gif\" alt=\"static-dark-mode.gif\"></p>\n<p><strong>반대로 Context API는 동적인 UI를 구현하는데 사용할 것이다.</strong> 단순히 css의 특정 속성값을 바꾸는게 아니라, 모드에 따라 컴포넌트의 클래스명('light', 'dark')을 변경하여 자유롭게 CSS 기능을 추가할 수 있다.</p>\n<p><img src=\"/TIL/48939fe89b03c461d2a0353234326f14/dynamic-dark-mode.gif\" alt=\"dynamic-dark-mode.gif\"></p>\n<h2 id=\"11-css-variables\" style=\"position:relative;\"><a href=\"#11-css-variables\" aria-label=\"11 css variables permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1. CSS variables</h2>\n<p><mark><strong>CSS도 전역적으로 사용할 수 있는 변수</strong>가 있다.</mark> 더 정확히 말하면 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties\">CSS custom properties</a>라고 한다. 진짜 알면 별거 없는데 모르면 큰일이다. 처음 프로젝트에서 Sass를 사용했을 때는, 이 개념을 몰라 다크모드를 위한 코드가 많이 더러웠다.</p>\n<p>이미 Sass 시스템 자체에서 변수를 지원하는데 무슨 소리냐고 할 수 있는데, 아래 예시를 보면 단번에 이해할 수 있을 것이다. <code>:root</code> 태그에 'light'클래스 유무에 따라서 프로젝트 전체에서 사용되는 CSS variable에 할당된 값이 바뀐다.</p>\n<p>참고로 <code>:root</code>는 다른게 아니라 가상선택자로 <code>html</code>태그와 동일한 위치에 있다고 생각하면 된다. <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties#basic_usage\">MDN 공식문서</a>에서 CSS variables를 <strong>전역적으로 사용</strong>하려면 <code>:root</code>요소에 정의하는 것을 권장하고 있다. 또한 이러한 <mark>전역 스타일링 코드는 최종적으로 <a href=\"https://www.gatsbyjs.com/docs/how-to/styling/global-css/#adding-global-styles-without-a-layout-component\">gatsby-browser</a>에 포함되어야 한다.</mark></p>\n<pre><code class=\"language-scss\">// Sass 변수\n$font-white: #ffffff;\n$font-black: #000000;\n$bg-white: #dddddd;\n$bg-black: #292929;\n\n// 다크 모드(default)\n:root {\n  --bg-color: #{$bg-black}; // sass 변수를 css 변수로 사용하기 위해 interpolation\n  --font-color: #{$font-white};\n}\n// 라이트 모드\n:root.light {\n  --bg-color: #{$bg-white};\n  --font-color: #{$font-black};\n}\n</code></pre>\n<p>그러면 실제 컴포넌트의 css에서는 다음처럼 사용하면 된다. css 변수를 사용하기 위해서는 <code>var()</code>를 써줘야한다.</p>\n<pre><code class=\"language-scss\">.component {\n    background-color: var(--bg-color);\n    color: var(--font-color);\n}\n</code></pre>\n<h2 id=\"12-theme-context\" style=\"position:relative;\"><a href=\"#12-theme-context\" aria-label=\"12 theme context permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2. Theme Context</h2>\n<p><strong>Theme Context는 <mark>사용자와 상호작용하며 Theme 정보를 다른 컴포넌트</mark>와 공유하기 위한 Context API이다.</strong> 따라서 반드시 Context API가 아니어도 된다. 다른 Recoil이나 Redux같은 전역저장소를 사용해도 된다. 다만 어차피 대부분의 컴포넌트를 재렌더링해야하기 때문에 Context API를 사용하기 적합하다고 생각한다.</p>\n<p>Theme Context는 별거 없다. React의 context API를 그대로 활용하면 된다. <code>createContext</code>를 이용해 context를 만들고, <code>theme</code>변수와 <code>toggleTheme</code>함수를 정의해서 Provider로 하위 컴포넌트들에게 제공하면 된다.</p>\n<pre><code class=\"language-js\">// src/contexts/theme-context.tsx\nimport React, { createContext ,useState, useCallback } from 'react'\n\ninterface Props {\n  children: React.ReactNode\n}\n\n// Context 생성\nexport const ThemeContext = createContext({\n  theme: 'dark',\n  toggleTheme: null,\n})\n\nexport const ThemeProvider = ({ children }: Props) => {\n  const [theme, setTheme] = useState('dark')    // theme 정의\n  const toggleTheme = useCallback(() => {       // toggleTheme 정의\n    setTheme((theme) => {\n      return theme === 'light' ? 'dark' : 'light'\n    })\n  }, [])\n\n  return (\n    &#x3C;ThemeContext.Provider value={{ theme, toggleTheme }}>\n      {children}\n    &#x3C;/ThemeContext.Provider>\n  )\n}\n\nexport default ThemeProvider\n</code></pre>\n<p>컴포넌트에서는 다음과 같이 읽어와서 쓰면 된다.</p>\n<pre><code class=\"language-js\">import React, { useContext } from 'react'\nimport { ThemeContext } from '@contexts/theme-context'\n\nconst Component: React.FC = () => {\n  const { theme, toggleTheme } = useContext(ThemeContext)\n\n  return (\n    &#x3C;div className={`${theme}`}>\n        ...\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<h2 id=\"13-코드-합치기\" style=\"position:relative;\"><a href=\"#13-%EC%BD%94%EB%93%9C-%ED%95%A9%EC%B9%98%EA%B8%B0\" aria-label=\"13 코드 합치기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.3. 코드 합치기</h2>\n<p>이제 위의 두가지 기능을 연동할 것이다. 별거 아니라 Theme Context에서 <code>theme</code>이 토글됨에 따라서 <code>:root</code>요소의 클래스를 변경하겠다는 말이다. 다음과 같이 <code>useEffect</code>를 하나 추가함으로써 구현할 수 있다.</p>\n<pre><code class=\"language-js\">// src/contexts/theme-context.tsx\nimport React, { createContext ,useState, useEffect, useCallback } from 'react'\n\ninterface Props {\n  children: React.ReactNode\n}\n\nexport const ThemeContext = createContext({\n  theme: 'dark',\n  toggleTheme: null,\n})\n\nexport const ThemeProvider = ({ children }: Props) => {\n  const [theme, setTheme] = useState('dark')    \n  const toggleTheme = useCallback(() => {      \n    setTheme((theme) => {\n      return theme === 'light' ? 'dark' : 'light'\n    })\n  }, [])\n\n  // theme에 따라 :root의 클래스를 토글한다.\n  useEffect(() => {\n    const root = document.querySelector(':root')\n    if (theme === 'light') {\n      root.classList.add('light')\n    } else {\n      root.classList.remove('light')\n    }\n  }, [theme])\n\n  return (\n    &#x3C;ThemeContext.Provider value={{ theme, toggleTheme }}>\n      {children}\n    &#x3C;/ThemeContext.Provider>\n  )\n}\n\nexport default ThemeProvider\n</code></pre>\n<h1 id=\"2-다크모드-ux\" style=\"position:relative;\"><a href=\"#2-%EB%8B%A4%ED%81%AC%EB%AA%A8%EB%93%9C-ux\" aria-label=\"2 다크모드 ux permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 다크모드 UX</h1>\n<p>다크모드는 눈에 띄는 사용자 경험(User Exprience)이다. 사이트의 사용자 경험을 높이기 위해 다크모드라는 클라이언트 데이터를 어떻게 관리할지 고민해볼만하다.</p>\n<p>결론적으로 말하면 나는 <strong>세션 스토리지</strong>에 다크모드 값을 저장해서 우선적으로 읽고, 해당 값이 없을 경우 <strong>prefers-color-scheme</strong>의 다크모드 설정 여부를 판단해 렌더링하기로 했다.</p>\n<h2 id=\"21-prefers-color-scheme\" style=\"position:relative;\"><a href=\"#21-prefers-color-scheme\" aria-label=\"21 prefers color scheme permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. prefers-color-scheme</h2>\n<p>먼저 <strong>prefers-color-scheme</strong>는 CSS 미디어 특성으로, <mark>사용자 웹의 다크모드 설정여부를 확인</mark>한다. 최신 브라우저에서는 모두 지원하기는 하는데, 정확히 어떻게 결정되는지는 모르겠다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/0592b0067c374cbc5dc3f2b2a2cc4eaf/0a013/prefers-color-scheme.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 29.142857142857142%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABJ0AAASdAHeZh94AAABkElEQVR42lWNz0/TcADF97cZD8aDejRGb1yM+g8YM4V4wEQvRghicKIGRib+SHCmZIPSjOGkNl2/7drRLWOsv2fp5uL5YxgXPby8d3jv83JeVyPp64Q9neREEPYNhr5D4lmEx03Crko60JnELX5H1n8ahyZxTyMLTLKky2nskHPkFSJLIvN00hOVkd8kcffIPI1JYjM5G4fm1CexNQX/qzPo+YE5zTlPXSVqS2SxRRoajIdt4o5MNlD5NdAZxRZ/si7joUMWiGkv6WukviD1DU59g1FgMgrEObBVLqF/KCBKr3A2l7GKC9hf1wjcBlHfxK5+Qi08R3xZJ3LqeIcVekLhuFklEDKeXafXqtERCu7PfXIzT64yM3+Fm48vcWPuIrfmL5OfvYaRv0dd+8iDwh2uP7rA3Mu71KQi75/dRpHW2Fy6T3HjIZWDDb7vfkbeLvFuZZHci+pTGk6ZN7VFZrfyrDde03YqJIff6Li7rCoLvN1fwnZlnOYOWqvMkZAxTIkf1hZCbOMaexwZMl1L4S/y4JKCX3pEOgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"prefers-color-scheme.png\" title=\"\" src=\"/TIL/static/0592b0067c374cbc5dc3f2b2a2cc4eaf/8c557/prefers-color-scheme.png\" srcset=\"/TIL/static/0592b0067c374cbc5dc3f2b2a2cc4eaf/4edbd/prefers-color-scheme.png 175w,\n/TIL/static/0592b0067c374cbc5dc3f2b2a2cc4eaf/13ae7/prefers-color-scheme.png 350w,\n/TIL/static/0592b0067c374cbc5dc3f2b2a2cc4eaf/8c557/prefers-color-scheme.png 700w,\n/TIL/static/0592b0067c374cbc5dc3f2b2a2cc4eaf/e996b/prefers-color-scheme.png 1050w,\n/TIL/static/0592b0067c374cbc5dc3f2b2a2cc4eaf/2cefc/prefers-color-scheme.png 1400w,\n/TIL/static/0592b0067c374cbc5dc3f2b2a2cc4eaf/0a013/prefers-color-scheme.png 1703w\" sizes=\"(max-width: 700px) 100vw, 700px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>심지어 운영체제의 설정과도 연관되어 있는 것 같다. 직접 테스트해본 결과, Windows 설정에서 바꾼 선호 모드가 prefers-color-scheme에 영향을 끼쳤다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/17ec1d540e17b650e04c89b778e6d223/b1c31/windows-color-scheme.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 46.28571428571429%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABJ0AAASdAHeZh94AAAB1ElEQVR42m2SS2sTURiG50cJLlyJYHcq0r0L8Se4dl1cCHYjKrbQjYigUDFaW4TWKtYitl3Y5taEpJmT28ycy1wyZyaPZNJAgz3wwoEPnu9933McLQOMMURRhFIayHi28pErC8tcX1zl2q0X3L63xuL9NZ6vlshshJQKrfWlcsqdAf2ej5SaIJCMx5bXbzZZuPuEG3cec/XmEh9Khxij2NzaJQzNJSCJ1tMlTlUEuGfHuG672BzHMYcHf/jxbYdPpRJfNjaoV8r8PTnh595ekWYeZjAmRpsIrUOcdmubZv0pwv2F52kC36PX71Gr12m3WwjhctpoUK/VCHyf0WhEkiTnmtwVwfA7ytshCl2c5lkVf7iP1h2UMkgpC5dhGKKUKrqdQCYnz3OstedKsXZMZn38/nuCwTuS6BSn2u0j3EHR4SzGJJbnefQHQ5Q2RW9JHBfgNE3nZS1Gu0i/SZLEOKI3YDjsY8w8MIpi8szCOCcHxpP3z7ILDqeaVpCS5RQ1OC3RQ7gunu8XMKkUaWqp1Sq8Wt9l5Xeb8tfPiPV9PJGQY4v5RejM7QTuNIRHtysQQkyBUpJlOUdHBzx8ucWDUoXt5SVqj97SqSTFP01H6X9OZ27/Abaol4HxwEngAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"windows-color-scheme.png\" title=\"\" src=\"/TIL/static/17ec1d540e17b650e04c89b778e6d223/8c557/windows-color-scheme.png\" srcset=\"/TIL/static/17ec1d540e17b650e04c89b778e6d223/4edbd/windows-color-scheme.png 175w,\n/TIL/static/17ec1d540e17b650e04c89b778e6d223/13ae7/windows-color-scheme.png 350w,\n/TIL/static/17ec1d540e17b650e04c89b778e6d223/8c557/windows-color-scheme.png 700w,\n/TIL/static/17ec1d540e17b650e04c89b778e6d223/e996b/windows-color-scheme.png 1050w,\n/TIL/static/17ec1d540e17b650e04c89b778e6d223/2cefc/windows-color-scheme.png 1400w,\n/TIL/static/17ec1d540e17b650e04c89b778e6d223/b1c31/windows-color-scheme.png 1413w\" sizes=\"(max-width: 700px) 100vw, 700px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>CSS와 JS에서는 각각 다음과 같이 사용할 수 있다.</p>\n<pre><code class=\"language-scss\">@media (prefers-color-scheme: dark){\n\tbody {\n\t\tbackground: black;\n\t\tcolor: white;\n\t}\n}\n</code></pre>\n<pre><code class=\"language-js\">if (window.matchMedia('(prefers-color-scheme: dark)').matches) {\n    console.log('I prefer dark mode.')\n}\n</code></pre>\n<p>하지만 이 설정에만 의존해서는 안된다. 분명 사용자의 선호 테마를 참조할 수 있다는 것은 좋은 사용자 경험을 제공하지만, 사이트 자체에서 다크모드를 토글하기 위해서는 추가적인 작업이 필요하다.</p>\n<h2 id=\"22-세션-스토리지\" style=\"position:relative;\"><a href=\"#22-%EC%84%B8%EC%85%98-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80\" aria-label=\"22 세션 스토리지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2. 세션 스토리지</h2>\n<p>그래서 나는 세션 스토리지를 사용하기로 했다. 상상해보니까 로컬 스토리지보다 세션 스토리지가 더 나은 사용자 경험을 제공할 것 같았기 때문이다.</p>\n<p>만약 어떤 다크모드 사용자가 내 웹사이트에 놀러왔다고 가정해보자. 그 날 따라 눈이 침침해서, 아니면 그냥 심심해서, 테마를 라이트모드로 전환하고 떠났다. 그리고 며칠이 지난 후, 내 웹사이트에서 본 깔쌈하고 멋진 글이 문득 생각 나서 다시 놀러왔다. 바로 이 때, 해당 사용자는 마지막에 자신이 설정한 테마를 기억이나 하고 있을까? 난 아니라고 생각한다. 밤 늦게 개발을 하면서 들어간 웹사이트가, 예상치 못하게 제공된 라이트모드 때문에 눈뽕을 당했다고 생각할 확률이 더 높을 것이다.</p>\n<p>위와 같이 나름의 사고를 걸쳐 다크모드를 세션 스토리지에 저장하기로 했다.</p>\n<h2 id=\"23-코드-작성\" style=\"position:relative;\"><a href=\"#23-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1\" aria-label=\"23 코드 작성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3. 코드 작성</h2>\n<p>위의 내용을 바탕으로 앞 서 작성한 <code>Theme Context</code>파일에 코드를 추가했다. <code>useEffect</code>페이지 첫 로딩 시, 세션 스토리지와 사용자 선호테마에 따라서 테마를 결정하고, 테마가 변경될 때마다 세션 스토리지에 데이터를 추가하는 코드를 작성한다. 또한 useEffect가 하나 더 추가 됨에 따라 기존 useEffect와 순서가 보장되지 않으므로, <code>isSetted</code>라는 변수를 생성해서 처음 작성한 useEffect문이 첫 마운트 시에는 동작하지 않도록 한다.</p>\n<pre><code class=\"language-js\">// src/contexts/theme-context.tsx\nimport React, { createContext ,useState, useEffect, useRef, useCallback } from 'react'\n\ninterface Props {\n  children: React.ReactNode\n}\n\nexport const ThemeContext = createContext({\n  theme: 'dark',\n  toggleTheme: null,\n})\n\nexport const ThemeProvider = ({ children }: Props) => {\n  const [theme, setTheme] = useState('dark')    \n  const toggleTheme = useCallback(() => {      \n    setTheme((theme) => {\n      return theme === 'light' ? 'dark' : 'light'\n    })\n  }, [])\n\n  const isSetted = useRef(false)\n  useEffect(() => {\n    // 페이지 첫 mount시에는 제외하고 동작\n    if (!isSetted.current) {\n      isSetted.current = true\n      return\n    }\n\n    sessionStorage.setItem('theme', theme)  // theme 변경 시마다 세션스토리지에 저장\n    const root = document.querySelector(':root')\n    if (theme === 'light') {\n      root.classList.add('light')\n    } else {\n      root.classList.remove('light')\n    }\n  }, [theme])\n\n  // 페이지 첫 로딩시 테마 결정\n  // 세션 스토리지 확인 > prefers-color-scheme 확인\n  useEffect(() => {\n    const sessionTheme = sessionStorage.getItem('theme')\n    if (sessionTheme) {\n      setTheme(sessionTheme)\n    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {\n      setTheme('dark')\n    } else {\n      setTheme('light')\n    }\n  }, [])\n\n  return (\n    &#x3C;ThemeContext.Provider value={{ theme, toggleTheme }}>\n      {children}\n    &#x3C;/ThemeContext.Provider>\n  )\n}\n\nexport default ThemeProvider\n</code></pre>\n<h1 id=\"3-wraprootelement\" style=\"position:relative;\"><a href=\"#3-wraprootelement\" aria-label=\"3 wraprootelement permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. wrapRootElement</h1>\n<p>Gatsby는 SSG기반의 프레임워크이어서 모든 url에 대응되는 index.html이 있다. <strong>즉 리액트와 같은 Single Page Application이 아니기 때문에, url를 이동할 때마다 새로운 index.html을 받는다.</strong> 한 마디로 말해서 <mark>url을 이동할 때마다 새로고침</mark>이 일어난다고 생각하면 된다.</p>\n<p>앞에서 설명은 안했지만, Gatsby는 정적인 index.html을 받아 이를 hydration하고 안에 있는 리액트코드를 돌리기까지 시간이 걸린다. 그래서 내가 설정한 다크모드와 웹사이트의 기본 다크모드가 다를 경우, 화면이 반짝거리는 flicker 현상이 일어나는데, 이게 매 url 이동마다 일어난다고 생각하면 끔찍한다.</p>\n<p>따라서 Gatsby는 모든 페이지에서 대해, 어떤 요소를 전역적으로 유지하기 위해 <a href=\"https://www.gatsbyjs.com/docs/reference/config-files/gatsby-browser/#wrapRootElement\">wrapPageElement</a>라는 Browser API를 제공한다. 공식문서에 따르면 <code>wrapRootElement</code>는 context API와 같은 것에 적합하고, 네비게이션바와 같이 UI 관련 요소의 경우 <code>wrapPageElement</code>를 사용하라고 한다.</p>\n<blockquote>\n<p>This is useful to set up any context providers that will wrap your application. For setting persistent UI elements around pages use wrapPageElement. [Gatsby Doc]</p>\n</blockquote>\n<p>또한 ssr API에도 동일한 API들이 있어 이 둘을 같이 사용할 것을 권장하고 있다. 하지만 나는 SSR 방식을 아예 사용하지 않기 때문에 제외했다.</p>\n<blockquote>\n<p>There is an equivalent hook in Gatsby’s SSR API. It is recommended to use both APIs together. [Gatsby Doc]</p>\n</blockquote>\n<h2 id=\"31-gatsby-browser\" style=\"position:relative;\"><a href=\"#31-gatsby-browser\" aria-label=\"31 gatsby browser permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1. gatsby-browser</h2>\n<p>적용 방법은 아주 쉽다. gatsby-browser 파일에 다음처럼 코드를 작성하기만 하면 된다. 좀 특이했던 것은 jsx 문법을 사용하기 때문에</p>\n<ul>\n<li><code>import React from 'react</code> 구문을 넣고</li>\n<li>파일 이름을 <code>gatsby-browser.ts</code>에서 <code>gatsby-browser.tsx</code>로 바꿔야 했다.</li>\n</ul>\n<pre><code class=\"language-js\">import React from 'react'\nimport ThemeProvider from '@contexts/theme-context'\n\nexport const wrapRootElement = ({ element }) => {\n  return &#x3C;ThemeProvider>{element}&#x3C;/ThemeProvider>\n}\n</code></pre>\n<h1 id=\"4-참조\" style=\"position:relative;\"><a href=\"#4-%EC%B0%B8%EC%A1%B0\" aria-label=\"4 참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 참조</h1>\n<ul>\n<li><a href=\"https://fe-developers.kakaoent.com/2021/211118-dark-mode/\">카카오 FE 기술블로그: 웹에서 다크모드 지원하기</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties\">CSS custom properties</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme\">prefers-color-scheme</a></li>\n<li><a href=\"https://www.gatsbyjs.com/docs/reference/config-files/gatsby-browser/\">Gatsby Browser APIs</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-sass-%EB%8B%A4%ED%81%AC%EB%AA%A8%EB%93%9C\">1. Sass 다크모드</a></p>\n<ul>\n<li><a href=\"#11-css-variables\">1.1. CSS variables</a></li>\n<li><a href=\"#12-theme-context\">1.2. Theme Context</a></li>\n<li><a href=\"#13-%EC%BD%94%EB%93%9C-%ED%95%A9%EC%B9%98%EA%B8%B0\">1.3. 코드 합치기</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-%EB%8B%A4%ED%81%AC%EB%AA%A8%EB%93%9C-ux\">2. 다크모드 UX</a></p>\n<ul>\n<li><a href=\"#21-prefers-color-scheme\">2.1. prefers-color-scheme</a></li>\n<li><a href=\"#22-%EC%84%B8%EC%85%98-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80\">2.2. 세션 스토리지</a></li>\n<li><a href=\"#23-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1\">2.3. 코드 작성</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-wraprootelement\">3. wrapRootElement</a></p>\n<ul>\n<li><a href=\"#31-gatsby-browser\">3.1. gatsby-browser</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#4-%EC%B0%B8%EC%A1%B0\">4. 참조</a></p>\n</li>\n</ul>","frontmatter":{"title":"05. Gatsby 다크모드 구현하기 (feat. Sass)","createdAt":"2023-06-26","updatedAt":"2023-06-26","tags":["gatsby","theme","다크모드","Sass","Scss"],"description":"Sass(Scss) 기반 Gatsby 프로젝트에서 ThemeProvider를 이용한 다크모드를 구현한다.","reference":"https://fe-developers.kakaoent.com/2021/211118-dark-mode/"}},"allMarkdownRemark":{"nodes":[{"id":"94b436d7-15e2-57c6-8d40-52cf418e46e6","parent":{"id":"ce161dd8-00d5-50d2-8c0d-578dd75f7c94","name":"01_Gatsby","relativePath":"Frontend/Gatsby/01_Gatsby.md"},"frontmatter":{"title":"01. Gatsby 렌더링 옵션과 프로젝트 구조","createdAt":"2023-06-16","updatedAt":"2023-06-16"},"excerpt":"시작하기 앞서... Gatsby로 Markdown기반의 블로그를 만들려고 한다면, Gatsby 공식문서를 보는 것을 추천한다. 맞춤형 강의라고 해도 믿을 만큼 잘 정리되어 있기 때문이다. 때문에 나는 앞으로 Gatsby…"},{"id":"9aebcdb2-63dc-552b-b521-6c16e309d09b","parent":{"id":"7fbea288-e615-5f15-96a9-d71745462e2c","name":"02_Github_Pages","relativePath":"Frontend/Gatsby/02_Github_Pages.md"},"frontmatter":{"title":"02. Gatsby 프로젝트 Github Pages 배포","createdAt":"2023-06-23","updatedAt":"2023-06-23"},"excerpt":"1. 프론트엔드 배포란? 프론트엔드 배포를 한 마디로 정리하면, 특정 url을 통한 GET요청에 대해 index.html…"},{"id":"3e2351da-7a0c-5c18-b503-c4358b27ab8f","parent":{"id":"cc5bee56-affb-555b-95d9-325b948e4870","name":"03_Import_Settings","relativePath":"Frontend/Gatsby/03_Import_Settings.md"},"frontmatter":{"title":"03. Gatsby 프로젝트(TypeScript) import 경로 설정","createdAt":"2023-06-24","updatedAt":"2023-06-24"},"excerpt":"1. import 경로 프로젝트를 진행하다 보면, import 절대경로를 설정하지 않을 수 없다.\n심지어 어쩌다가 한 번, IDE에서 자동 import…"},{"id":"e2e850af-877e-5cc3-afc7-00362ed5273d","parent":{"id":"8e077755-e170-50a6-a0b5-964d3835ef5d","name":"04_ESLint_Prettier","relativePath":"Frontend/Gatsby/04_ESLint_Prettier.md"},"frontmatter":{"title":"04. Gatsby 프로젝트 Prettier & ESLint & Husky 설정","createdAt":"2023-06-25","updatedAt":"2023-06-25"},"excerpt":"1. 개요 1.1. Prettier & ESLint란? Prettier와 ESLint는 각각 코드 포맷팅(Code Formatting)과 린팅(Linting…"},{"id":"a0a6e020-13b3-5b8c-a3a9-731d0b01e16c","parent":{"id":"f070924b-4b2c-5a2e-ae60-efbd70ce23c9","name":"05_Dark_Mode","relativePath":"Frontend/Gatsby/05_Dark_Mode.md"},"frontmatter":{"title":"05. Gatsby 다크모드 구현하기 (feat. Sass)","createdAt":"2023-06-26","updatedAt":"2023-06-26"},"excerpt":"아래 내용은 주관적인 의견이고, 카카오 FE 기술 블로그의 내용을 참조했습니다. 1. Sass 다크모드 한동안 다크모드를 공부한 적이 있다. Styled Component와 같은 CSS-in-JS…"},{"id":"8dd7c7ba-002c-5398-92a5-b43faf1f595b","parent":{"id":"7dc89b39-7e64-5368-9d05-118f4f02d985","name":"06_Navigation_Layout","relativePath":"Frontend/Gatsby/06_Navigation_Layout.md"},"frontmatter":{"title":"06. Gatsby 네비게이션 레이아웃 설정","createdAt":"2023-06-27","updatedAt":"2023-06-27"},"excerpt":"1. SSG 렌더링 React에서는 Nested Route로 손 쉽게 레이아웃을 구현할 수 있다. 그런데 Gatsby는 Single Page Application이 아니다! Gatsby는 정적 사이트 생성기(SSG)로 빌드 시에, 모든 url…"},{"id":"f2e3f78d-324e-5387-b630-101288184fae","parent":{"id":"0384b347-d777-5cc3-943b-91771189a957","name":"07_Custom_Pages","relativePath":"Frontend/Gatsby/07_Custom_Pages.md"},"frontmatter":{"title":"07. Gatsby 커스텀 페이지 생성","createdAt":"2023-06-27","updatedAt":"2023-06-27"},"excerpt":"1. 튜토리얼 방식의 한계 Gatsby 튜토리얼 Part6 를 보면 file system routes라고 해서 파일시스템에 있는 파일들에 대해서 동적으로 페이지를 생성하는 방법을 소개한다. 예를 들어 아래 그림처럼 src/pages/아래에 {mdx…"},{"id":"19ad15a7-720c-5daf-880f-06af0a704144","parent":{"id":"daf85c35-0844-5cdb-8909-f001a0714f75","name":"08_Diretory_Based_Category","relativePath":"Frontend/Gatsby/08_Diretory_Based_Category.md"},"frontmatter":{"title":"08. 폴더 구조 기반 Gatsby 카테고리 바 생성","createdAt":"2023-06-28","updatedAt":"2023-06-28"},"excerpt":"1. GraphQL 아직 GraphQL을 파일시스템에 대해서 밖에 사용하지 않아, 정확히 GraphQL이 뭔지는 감이 안잡힌다. 하지만 그 제한된 경험으로도 GrqphQL이 기존 API…"},{"id":"6ae60c60-1e09-59a3-8a3c-f12ca9abd1c4","parent":{"id":"e5909625-6638-5137-b366-16bba9f61baf","name":"09_Markdown_Styling","relativePath":"Frontend/Gatsby/09_Markdown_Styling.md"},"frontmatter":{"title":"09. Gatsby 마크다운(md) 스타일링","createdAt":"2023-06-29","updatedAt":"2023-06-29"},"excerpt":"gatsby-transformer-remark플러그인을 통한 markdownRemark노드를 사용을 전제합니다. 1. 마크다운 스타일링 나는 분명 Gatsby 공식문서를 따라 gatsby-transformer-remark…"},{"id":"187472ff-d02f-5104-9b2e-515b0b1898f2","parent":{"id":"0a367c55-81a1-5059-8814-42d23ceac89a","name":"10_Table_of_Contents","relativePath":"Frontend/Gatsby/10_Table_of_Contents.md"},"frontmatter":{"title":"10. Gatsby 스크롤 반응형 목차(TOC) 생성","createdAt":"2023-06-30","updatedAt":"2023-06-30"},"excerpt":"1. URL 프래그먼트 식별자(#) 일단 프래그먼트 식별자(a.k.a. #)이 어떻게 동작하는 알 필요가 있다. 나는 평소 너무 당연하게 써왔지만, 어떻게 동작하는지는 한 번도 생각해보지 않았다. 사용자가 URL…"}]}},"pageContext":{"pagePath":"posts/Frontend/Gatsby/05_Dark_Mode.md","regex":"/^(?!.*README).*Frontend\\/Gatsby.*$/","relativeDirectory":"Gatsby","id":"a0a6e020-13b3-5b8c-a3a9-731d0b01e16c","parent":{"id":"f070924b-4b2c-5a2e-ae60-efbd70ce23c9","name":"05_Dark_Mode","relativePath":"Frontend/Gatsby/05_Dark_Mode.md"}}},"staticQueryHashes":["3300660363","522921546"],"slicesMap":{}}