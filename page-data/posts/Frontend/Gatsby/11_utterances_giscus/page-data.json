{"componentChunkName":"component---src-templates-post-index-tsx","path":"/posts/Frontend/Gatsby/11_utterances_giscus/","result":{"data":{"markdownRemark":{"id":"1e126097-6df5-5927-8c17-282ca0974e45","html":"<h1 id=\"1-utterances와-giscus\" style=\"position:relative;\"><a href=\"#1-utterances%EC%99%80-giscus\" aria-label=\"1 utterances와 giscus permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Utterances와 Giscus</h1>\n<p>따로 서버를 돌리지 않고서는 댓글/좋아요 기능을 구현할 수 없을 줄 알았다.</p>\n<p>그런데 항상 개발자들은 신박한 방법을 찾아낸다.<br>\n<strong>GitHub API</strong>를 이용해서 구현된 서비스가 있었다. 그것도 두 개나 말이다!</p>\n<ul>\n<li>\n<p><strong>Utterances</strong><br>\n<a href=\"https://utteranc.es/\">Utterances</a>는 GitHub의 이슈(Issue)를 활용해서 댓글 서비스를 제공한다. 원래 깃헙 이슈란, 코드 및 프로젝트에 대한 문제점이나 개선사항을 제안하고, 이에 대해 논의하기 위한 기능이다. 따라서 이슈는 레이블, 마일스톤, 이슈 상태, 담당자 등의 다양한 작업추적 기능을 제공한다.</p>\n</li>\n<li>\n<p><strong>Giscus</strong><br>\n<a href=\"https://giscus.app/\">Giscus</a>는 GitHub의 토론(Discussion)을 이용해서 구현된 서비스이다. 원래 깃헙 토론도, 프로젝트와 관련된 주제에 대해서 의견을 교환하기 위한 기능이다. 깃헙 이슈처럼 작업추적 기능은 제공되지 않지만, 더 자유롭게 의견을 교환할 수 있다.</p>\n</li>\n</ul>\n<p>직관적인 사용 기능을 비교하면 다음과 같다.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Utterances</th>\n<th>Giscus</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>댓글</td>\n<td>✔</td>\n<td>✔</td>\n</tr>\n<tr>\n<td>댓글 좋아요</td>\n<td>✔</td>\n<td>✔</td>\n</tr>\n<tr>\n<td>마크다운</td>\n<td>✔</td>\n<td>✔</td>\n</tr>\n<tr>\n<td>테마</td>\n<td>✔</td>\n<td>✔</td>\n</tr>\n<tr>\n<td>대댓글</td>\n<td>❌</td>\n<td>✔</td>\n</tr>\n<tr>\n<td>좋아요</td>\n<td>❌</td>\n<td>✔</td>\n</tr>\n<tr>\n<td>다국어</td>\n<td>❌</td>\n<td>✔</td>\n</tr>\n</tbody>\n</table>\n<p>보면 Utterances를 사용할 이유가 없어보인다. 그런데 <strong>현재 서비스의 안정성이나 유지 보수 측면에서는 Utterances가 더 낫다.</strong> 일단, <a href=\"https://giscus.app/\">공식문서</a>만 들어가봐도 Giscus는 다음과 같이 시인하고 있다.</p>\n<blockquote>\n<p>giscus is still under active development. GitHub is also still actively developing Discussions and its API. Thus, some features of giscus may break or change over time.</p>\n</blockquote>\n<p>아래 <a href=\"https://www.libhunt.com/compare-giscus-vs-utterances\">지표</a>가 현재 Utterances와 Giscus의 현황을 잘 표현해주는 것 같다. Utterances 이미 멘션횟수가 많고 Stars도 많이 받았지만, 성장세는 비교적 완만하다. 반대로 Giscus는 상대적으로 아직 덜 주목받지만, 성장세가 가파르다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/ffff619a1a48e9bb873b6ac559e05e01/218a4/giscus-vs-utterances.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 57.714285714285715%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABJ0AAASdAHeZh94AAABg0lEQVR42pVR2XKkMAzk/z9xtyaZAcMAAWzwffaWtZNKKgsP+9DVkiy12nYTo8d3hOiRk4dQFqMwVMs5Eo9co1s1rHdIP+ZiDPBeoykF+AkUwMdCyLlg33fimtuQkU9mKkJwaGJMiDGeIgQPrTUYY5BSwjuHlOJFf4JzBk3dnHP+ByEEGGOJl2WBcx5aKXjvUcrZTIH39tqhc45cWWsxzzOMMZQ7cpmuHaaUqeEMxloSqg61NiR+1Vt1vDfnDus1lVL0fkpJcM4p/0S99n85rA3rsuA4Diit0Pc9hBAktq4LCaZ84fDrUwpS5VIQvMe2bZBSUXON69vVBVwIWvj5GX8NVbw+ResDUnIcB4dWO6HGnC8QYoGUAtM0EO9iw7bNOI4NSu00p/UOayXBmB1N197wePzG/f0XWHdD193A2Dsx1dgbhuH+qr9hHFus64B5ZviYGTifYIyAMZy4qcPTxDAMD/T9Hc9ni/HZEj+HB9UrP8eWxCh+nde5ceywiw9Yu5PgH05moXHGtoYWAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/TIL/static/ffff619a1a48e9bb873b6ac559e05e01/c54d4/giscus-vs-utterances.webp 175w,\n/TIL/static/ffff619a1a48e9bb873b6ac559e05e01/a3432/giscus-vs-utterances.webp 350w,\n/TIL/static/ffff619a1a48e9bb873b6ac559e05e01/426ac/giscus-vs-utterances.webp 700w,\n/TIL/static/ffff619a1a48e9bb873b6ac559e05e01/c139f/giscus-vs-utterances.webp 1050w,\n/TIL/static/ffff619a1a48e9bb873b6ac559e05e01/c18de/giscus-vs-utterances.webp 1052w\" sizes=\"(max-width: 700px) 100vw, 700px\" type=\"image/webp\">\n          <source srcset=\"/TIL/static/ffff619a1a48e9bb873b6ac559e05e01/4edbd/giscus-vs-utterances.png 175w,\n/TIL/static/ffff619a1a48e9bb873b6ac559e05e01/13ae7/giscus-vs-utterances.png 350w,\n/TIL/static/ffff619a1a48e9bb873b6ac559e05e01/8c557/giscus-vs-utterances.png 700w,\n/TIL/static/ffff619a1a48e9bb873b6ac559e05e01/e996b/giscus-vs-utterances.png 1050w,\n/TIL/static/ffff619a1a48e9bb873b6ac559e05e01/218a4/giscus-vs-utterances.png 1052w\" sizes=\"(max-width: 700px) 100vw, 700px\" type=\"image/png\">\n          <img class=\"gatsby-resp-image-image\" src=\"/TIL/static/ffff619a1a48e9bb873b6ac559e05e01/8c557/giscus-vs-utterances.png\" alt=\"giscus-vs-utterances.png\" title=\"\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span>\n<p>나는 원래 Utterances를 적용했다가, 좋아요 기능이 너무 탐나서 Giscus로 이전했다.</p>\n<h2 id=\"11-동작-원리\" style=\"position:relative;\"><a href=\"#11-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC\" aria-label=\"11 동작 원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1. 동작 원리</h2>\n<p>Utterances와 Giscus 모두 <strong>npm 라이브러가 아니다.</strong> 그냥 하나의 <code>&#x3C;script></code>태그만 주어진다.</p>\n<p>이 <code>&#x3C;script></code>태그를 html에서 원하는 곳에 삽입하면 마법처럼 댓글 UI가 나타난다. 어떻게 이게 가능한 지 모르겠어서, 처음에 리액트 컴포넌트를 만드는데 애를 먹었다. 그런데 좀만 시간을 갖고 알아보니, 재밌게 동작하는 서비스였다.</p>\n<p><mark>Utterances와 Giscus는 서로 매우 유사하게 동작하기 때문에, Utterances만을 예시로 동작과정을 설명해보겠다.</mark></p>\n<p>다음은 utterances의 예시 스크립트이다. <code>src</code>를 제외한 값은 모두 사용자 옵션 값이다.</p>\n<pre><code class=\"language-js\">&#x3C;script\n  src=\"https://utteranc.es/client.js\"\n  repo=\"[ENTER REPO HERE]\"\n  issue-term=\"[ONE OF OPTIONS]\"\n  theme=\"[ONE OF THEMES]\"\n  crossorigin=\"anonymous\"\n  async\n>&#x3C;/script>\n</code></pre>\n<p>위의 src의 값 \"<a href=\"https://utteranc.es/client.js%22%EC%9D%84\">https://utteranc.es/client.js\"을</a> url에 입력해보면, 생각보다 짧은 js문서를 받을 수 있다.<br>\n거기서 핵심만 추려보면 다음과 같이 동작하는 것을 확인할 수 있다.</p>\n<ol>\n<li>현재 스크립트 요소를 기억해둔다.</li>\n<li>사용자 옵션에 따라 <code>&#x3C;div class=\"utterances\" /></code>를 생성한다.</li>\n<li>생성한 <code>&#x3C;div /></code>를 현재 스크립트 뒤(<code>afterend</code>)에 추가한다.</li>\n<li>스크립트는 삭제한다. (giscus는 이 과정이 없다)</li>\n</ol>\n<pre><code class=\"language-js\">https: (() => {\n  ...\n  let r = document.currentScript    // r은 현재 스크립트 요소\n  ...\n  r.insertAdjacentHTML(\n    'afterend',\n    `&#x3C;div class=\"utterances\">\\n    &#x3C;iframe class=\"utterances-frame\" title=\"Comments\" scrolling=\"no\" src=\"${h}?${new URLSearchParams(\n      i\n    )}\" loading=\"lazy\">&#x3C;/iframe>\\n  &#x3C;/div>`\n  )                                 // 현재 스크립트 요소 뒤에, 실제 컨텐츠 &#x3C;div class=\"utterances\"> 추가\n  const m = r.nextElementSibling\n  r.parentElement.removeChild(r)    // 현재 스크립트 삭제 (utterances 한정)\n  ...\n})()\n</code></pre>\n<p>한마디로 <code>&#x3C;script/></code>태그를 기준으로 바로 뒤에(<code>afterend</code>)에 요소를 추가하기 때문에, <code>&#x3C;script/></code>를 곧 댓글 UI라고 보아도 무방한 것이다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/7107017cbbee33392081b8d6e57c82f0/4352a/giscus-chrome-dev.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 64.57142857142857%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABJ0AAASdAHeZh94AAACNUlEQVR42m2SS2/VMBCF868RK5ZsWLAtK1awpogViCWi5dEHFUVCFVKr9t6bxHacsT1+H+TcW5DajvRpksiaOefEXX71GhVACQGoBc4aOGtRa0EpGbVklJxgjIEQGpubDTYbgdVaQAiFWWsoqaqcCFpr6srVFZYqZWnMDGYHLGu2lFKQUkLJBXqjIQeLSRdYm5FSRS7LwTaDOk0zrDUI3i94z6i1HYwYxxGTnqG0Xt5bUf8T0+oQ/foXxOYMcn0Mkl9r5i+I7oQ6Iy20mkGGEJuKUlDrf1U5l+V7jKlJgNc/oPsjXK+OsO6PIeU3yPVhFf0fWPWZulkzjGGUuh30ULUsHTOCI0wfX2K9/wI3b59jePMY/f4jiHdPKn14Bvv+KXWKIzRHYKcq3yGmDB8CQgxIMUKfHIBOP4HPv8OfHSD/PkK+OKu4PEe6OKVu6i1W1wNW/YjZMDgkOB/vEJYMcyww2mJ2BZorXKgoW1O31qgj6zGICVITjPVwHO9h2SPGAJ4tgjEIi31GdIwcAkoKtY1MwVPn2MNYt4Se8tbiQ6hJoR8kRqGgpFiQUi0MQ1+VmtH3A3XehyUj45q69pzuwT6AiGCtXf56Kc1q/dd9iLUtnclQZyxjmg3I8nbovfy2lh0ZkFBoAuruztcdtxk666hr2+0DQ/7BAWwdSGvMwwitZ4QQEGPc3c/YqO3KOeeoc45hnb+PZdhm4/IKtLeHzTBAqglCSAzjNr/WRyEwjrKSMVCTpr/vc+a++Nup/wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/TIL/static/7107017cbbee33392081b8d6e57c82f0/c54d4/giscus-chrome-dev.webp 175w,\n/TIL/static/7107017cbbee33392081b8d6e57c82f0/a3432/giscus-chrome-dev.webp 350w,\n/TIL/static/7107017cbbee33392081b8d6e57c82f0/426ac/giscus-chrome-dev.webp 700w,\n/TIL/static/7107017cbbee33392081b8d6e57c82f0/c139f/giscus-chrome-dev.webp 1050w,\n/TIL/static/7107017cbbee33392081b8d6e57c82f0/1bc7b/giscus-chrome-dev.webp 1364w\" sizes=\"(max-width: 700px) 100vw, 700px\" type=\"image/webp\">\n          <source srcset=\"/TIL/static/7107017cbbee33392081b8d6e57c82f0/4edbd/giscus-chrome-dev.png 175w,\n/TIL/static/7107017cbbee33392081b8d6e57c82f0/13ae7/giscus-chrome-dev.png 350w,\n/TIL/static/7107017cbbee33392081b8d6e57c82f0/8c557/giscus-chrome-dev.png 700w,\n/TIL/static/7107017cbbee33392081b8d6e57c82f0/e996b/giscus-chrome-dev.png 1050w,\n/TIL/static/7107017cbbee33392081b8d6e57c82f0/4352a/giscus-chrome-dev.png 1364w\" sizes=\"(max-width: 700px) 100vw, 700px\" type=\"image/png\">\n          <img class=\"gatsby-resp-image-image\" src=\"/TIL/static/7107017cbbee33392081b8d6e57c82f0/8c557/giscus-chrome-dev.png\" alt=\"giscus-chrome-dev.png\" title=\"\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span>\n<h1 id=\"2-utterances\" style=\"position:relative;\"><a href=\"#2-utterances\" aria-label=\"2 utterances permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Utterances🔮</h1>\n<h2 id=\"21-앱-등록-및-script-생성\" style=\"position:relative;\"><a href=\"#21-%EC%95%B1-%EB%93%B1%EB%A1%9D-%EB%B0%8F-script-%EC%83%9D%EC%84%B1\" aria-label=\"21 앱 등록 및 script 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. 앱 등록 및 script 생성</h2>\n<p>걍 <a href=\"https://utteranc.es/\">공식문서</a>를 따라하면 된다.</p>\n<h2 id=\"22-리액트-컴포넌트\" style=\"position:relative;\"><a href=\"#22-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\" aria-label=\"22 리액트 컴포넌트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2. 리액트 컴포넌트</h2>\n<p>단순히 script태그를 원하는 곳에 정적으로 추가해도 되지만, <strong>다크모드 등의 옵션을 사용하려면 prop을 받아 동적으로 렌더링하는 리액트 컴포넌트를 만들어야 한다.</strong> 아래는 내가 만든 Utterances 리액트 컴포넌트이다.</p>\n<pre><code class=\"language-js\">import React, { createRef, useEffect } from 'react'\n\nexport interface UtterancesProps {\n  theme?:\n    | 'github-light'\n    | 'github-dark'\n    | 'preferred-color-scheme'\n    | 'github-dark-orange'\n    | 'icy-dark'\n    | 'dark-blue'\n    | 'photon-dark'\n    | 'boxy-light'\n    | 'gruvbox-dark'; // utterances 지원 가능 테마 목록\n}\n\n// 쓸데없는 재렌더링이 일어나지 않돌고 React.memo\nconst Utterances: React.FC&#x3C;UtterancesProps> = React.memo(\n  ({ theme = 'github-light' }) => {\n    const utterRef = createRef &#x3C; HTMLElement > null\n\n    useEffect(() => {\n      const utterance = utterRef.current\n      const utterScript = document.createElement('script') // script 태그 생성\n\n      // prop에 따라서 script 속성 추가\n      const attributes = {\n        src: 'https://utteranc.es/client.js',\n        repo: 'byongho96/TIL',\n        'issue-term': 'pathname',\n        theme: theme,\n        label: '🔮comments🔮',\n        crossOrigin: 'anonymous',\n        async: true,\n      }\n      Object.entries(attributes).forEach(([key, value]) => {\n        utterScript.setAttribute(key, value)\n      })\n\n      // script 태그 DOM에 추가\n      utterance.appendChild(utterScript)\n\n      return () => {\n        // utternance 내부 요소 삭제 후, 재렌더링 작업\n        utterance.childNodes.forEach((utterance) => {\n          utterance.remove()\n        })\n      }\n    }, [theme])\n\n    return &#x3C;section ref={utterRef} />\n  }\n)\n\nexport default Utterances\n</code></pre>\n<h2 id=\"23-사용-예시\" style=\"position:relative;\"><a href=\"#23-%EC%82%AC%EC%9A%A9-%EC%98%88%EC%8B%9C\" aria-label=\"23 사용 예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3. 사용 예시</h2>\n<p>나는 Context API를 활용하여 <code>theme</code>을 관리하기 때문에 아래와 같이 사용했다.</p>\n<pre><code class=\"language-js\">import React, { useContext } from 'react'\nimport { ThemeContext } from '@contexts/theme-context'\nimport Utterances from '@components/utterances'\n\nconst PostPage: React.FC&#x3C;PageProps> = ({ pageContext, data }) => {\n  const { theme } = useContext(ThemeContext)\n\n  return (\n    &#x3C;Utterances theme={theme === 'dark' ? 'github-dark' : 'github-light'} />\n  )\n}\n</code></pre>\n<h1 id=\"3-giscus\" style=\"position:relative;\"><a href=\"#3-giscus\" aria-label=\"3 giscus permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Giscus💎</h1>\n<h2 id=\"31-앱-등록-및-script-생성\" style=\"position:relative;\"><a href=\"#31-%EC%95%B1-%EB%93%B1%EB%A1%9D-%EB%B0%8F-script-%EC%83%9D%EC%84%B1\" aria-label=\"31 앱 등록 및 script 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1. 앱 등록 및 script 생성</h2>\n<p>역시 걍 <a href=\"https://giscus.app/\">공식문서</a>를 따라하면 된다. Utterances와 다르게 discussion 기능을 열어주는 단계가 추가된다.</p>\n<h2 id=\"32-리액트-컴포넌트\" style=\"position:relative;\"><a href=\"#32-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\" aria-label=\"32 리액트 컴포넌트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2. 리액트 컴포넌트</h2>\n<p>역시 prop에 따라 동적으로 재렌더링 시키기 위해 아래와 같은 리액트 컴포넌트를 만들었다.</p>\n<pre><code class=\"language-js\">import React, { createRef, useEffect } from 'react'\n\nexport interface GiscusProps {\n  theme?:\n    | 'light'\n    | 'light_high_contrast'\n    | 'light_protanopia'\n    | 'light_tritanopia'\n    | 'dark'\n    | 'dark_high_contrast'\n    | 'dark_protanopia'\n    | 'dark_tritanopia'\n    | 'dark_dimmed'\n    | 'preferred_color_scheme'\n    | 'transparent_dark'\n    | 'noborder_light'\n    | 'noborder_dark'\n    | 'cobalt'  // giscus 지원 가능 테마 목록\n  lang?: 'en' | 'ko'\n}\n\n// 쓸데없는 재렌더링이 일어나지 않돌고 React.memo\nconst Giscus: React.FC&#x3C;GiscusProps> = React.memo(\n  ({ theme = 'light', lang = 'ko' }) => {\n    const giscusRef = createRef&#x3C;HTMLElement>(null)\n\n    // utternace를 적용하기 위한 script를 html에 성생\n    useEffect(() => {\n      const giscusContainer = giscusRef.current\n      const giscusScript = document.createElement('script') // script 태그 생성\n\n      // prop에 따라서 script 속성 추가\n      const attributes = {\n        src: 'https://giscus.app/client.js',\n        'data-repo': 'Byongho96/TIL',\n        'data-repo-id': 'R_kgDOHqT9Kw',\n        'data-category': 'Announcements',\n        'data-category-id': 'DIC_kwDOHqT9K84CXqXc',\n        'data-mapping': 'pathname',\n        'data-strict': '0',\n        'data-reactions-enabled': '1',\n        'data-emit-metadata': '0',\n        'data-input-position': 'bottom',\n        'data-theme': theme,\n        'data-lang': lang,\n        crossorigin: 'anonymous',\n        async: true,\n      }\n      Object.entries(attributes).forEach(([key, value]) => {\n        giscusScript.setAttribute(key, value)\n      })\n\n      // script 태그 DOM에 추가\n      giscusContainer.appendChild(giscusScript)\n\n      return () => {\n        // giscuss 내부 요소 삭제 후, 제 랜더링\n        giscusContainer.childNodes.forEach((giscusance) => {\n          giscusance.remove()\n        })\n      }\n    }, [theme, lang])\n\n    return &#x3C;section ref={giscusRef} />\n  }\n)\n\nexport default Giscus\n</code></pre>\n<h2 id=\"33-사용-예시\" style=\"position:relative;\"><a href=\"#33-%EC%82%AC%EC%9A%A9-%EC%98%88%EC%8B%9C\" aria-label=\"33 사용 예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.3. 사용 예시</h2>\n<p>나는 Context API를 활용하여 <code>theme</code>을 관리하기 때문에 아래와 같이 사용했다.</p>\n<pre><code class=\"language-js\">import React, { useContext } from 'react'\nimport { ThemeContext } from '@contexts/theme-context'\nimport Giscus from '@components/giscus'\n\nconst PostPage: React.FC&#x3C;PageProps> = ({ pageContext, data }) => {\n  const { theme } = useContext(ThemeContext)\n\n  return &#x3C;Giscus theme={theme === 'dark' ? 'dark' : 'light'} />\n}\n</code></pre>\n<h2 id=\"34-cross-origin\" style=\"position:relative;\"><a href=\"#34-cross-origin\" aria-label=\"34 cross origin permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.4. cross-origin</h2>\n<p>Giscus는 Cross Origin에 대응하기 위해 giscus.json 설정파일을 제공한다.</p>\n<p>Utterances를 사용할 때는 한 번도 생각해보지 않았는데, 곰곰히 생각해보니 Script만 있으면 아무 웹사이트에서 내 레포지토리에 대한 댓글 UI를 생성할 수 있다는게 이상하기는 하다.</p>\n<p><a href=\"https://github.com/giscus/giscus/blob/main/ADVANCED-USAGE.md#giscusjson\">공식문서</a>의 설명에 따르면, giscus.json 파이을 레포지토리 루트 경로에 생성함으로써 추가 설정을 걸 수 있다고 한다. 그 중에서 <code>origin</code>설정은 내 <code>&#x3C;script/></code>를 로드할 수 있는 도메인을 제한하는 설정이다.</p>\n<pre><code class=\"language-json\">// giscus.json\n{\n  \"origins\": [\"https://byongho96.github.io\"] // '/TIL'까지 붙이고 싶지만, 도메인이 아니라서 에러난다.\n}\n</code></pre>\n<h1 id=\"4-참조\" style=\"position:relative;\"><a href=\"#4-%EC%B0%B8%EC%A1%B0\" aria-label=\"4 참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 참조</h1>\n<ul>\n<li><a href=\"https://utteranc.es/\">Utterances</a></li>\n<li><a href=\"https://giscus.app/\">Giscus</a></li>\n<li><a href=\"https://ricale.kr/blog/posts/230211-gatsby-8-comments/\">Ricale.kr: Gatsby 블로그 만들기 8 - 댓글</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-utterances%EC%99%80-giscus\">1. Utterances와 Giscus</a></p>\n<ul>\n<li><a href=\"#11-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC\">1.1. 동작 원리</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-utterances\">2. Utterances🔮</a></p>\n<ul>\n<li><a href=\"#21-%EC%95%B1-%EB%93%B1%EB%A1%9D-%EB%B0%8F-script-%EC%83%9D%EC%84%B1\">2.1. 앱 등록 및 script 생성</a></li>\n<li><a href=\"#22-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\">2.2. 리액트 컴포넌트</a></li>\n<li><a href=\"#23-%EC%82%AC%EC%9A%A9-%EC%98%88%EC%8B%9C\">2.3. 사용 예시</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-giscus\">3. Giscus💎</a></p>\n<ul>\n<li><a href=\"#31-%EC%95%B1-%EB%93%B1%EB%A1%9D-%EB%B0%8F-script-%EC%83%9D%EC%84%B1\">3.1. 앱 등록 및 script 생성</a></li>\n<li><a href=\"#32-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\">3.2. 리액트 컴포넌트</a></li>\n<li><a href=\"#33-%EC%82%AC%EC%9A%A9-%EC%98%88%EC%8B%9C\">3.3. 사용 예시</a></li>\n<li><a href=\"#34-cross-origin\">3.4. cross-origin</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#4-%EC%B0%B8%EC%A1%B0\">4. 참조</a></p>\n</li>\n</ul>","frontmatter":{"title":"11. Gatsby 댓글 및 좋아요 기능","createdAt":"2023-07-02","updatedAt":"2023-07-02","tags":["gatsby","댓글","좋아요","대댓글","giscus","utterances"],"description":"Gatsby 웹사이트에 댓글과 좋아요 기능을 구현한다.","reference":"https://ricale.kr/blog/posts/230211-gatsby-8-comments/"}},"allMarkdownRemark":{"nodes":[{"id":"94b436d7-15e2-57c6-8d40-52cf418e46e6","excerpt":"시작하기 앞서... Gatsby로 Markdown기반의 블로그를 만들려고 한다면, Gatsby 공식문서를 보는 것을 추천한다. 맞춤형 강의라고 해도 믿을 만큼 잘 정리되어 있기 때문이다. 때문에 나는 앞으로 Gatsby…","parent":{"id":"ce161dd8-00d5-50d2-8c0d-578dd75f7c94","name":"01_Gatsby","relativePath":"Frontend/Gatsby/01_Gatsby.md"},"frontmatter":{"title":"01. Gatsby 렌더링 옵션과 프로젝트 구조","createdAt":"2023-06-16","updatedAt":"2023-06-16"},"fields":{"slug":"/posts/Frontend/Gatsby/01_Gatsby/"}},{"id":"9aebcdb2-63dc-552b-b521-6c16e309d09b","excerpt":"1. 프론트엔드 배포란? 프론트엔드 배포를 한 마디로 정리하면, 특정 url을 통한 GET요청에 대해 index.html…","parent":{"id":"7fbea288-e615-5f15-96a9-d71745462e2c","name":"02_Github_Pages","relativePath":"Frontend/Gatsby/02_Github_Pages.md"},"frontmatter":{"title":"02. Gatsby 프로젝트 Github Pages 배포","createdAt":"2023-06-23","updatedAt":"2023-06-23"},"fields":{"slug":"/posts/Frontend/Gatsby/02_Github_Pages/"}},{"id":"3e2351da-7a0c-5c18-b503-c4358b27ab8f","excerpt":"1. import 경로 프로젝트를 진행하다 보면, import 절대경로를 설정하지 않을 수 없다.\n심지어 어쩌다가 한 번, IDE에서 자동 import…","parent":{"id":"cc5bee56-affb-555b-95d9-325b948e4870","name":"03_Import_Settings","relativePath":"Frontend/Gatsby/03_Import_Settings.md"},"frontmatter":{"title":"03. Gatsby 프로젝트(TypeScript) import 경로 설정","createdAt":"2023-06-24","updatedAt":"2023-06-24"},"fields":{"slug":"/posts/Frontend/Gatsby/03_Import_Settings/"}},{"id":"e2e850af-877e-5cc3-afc7-00362ed5273d","excerpt":"1. 개요 1.1. Prettier & ESLint란? Prettier와 ESLint는 각각 코드 포맷팅(Code Formatting)과 린팅(Linting…","parent":{"id":"8e077755-e170-50a6-a0b5-964d3835ef5d","name":"04_ESLint_Prettier","relativePath":"Frontend/Gatsby/04_ESLint_Prettier.md"},"frontmatter":{"title":"04. Gatsby 프로젝트 Prettier & ESLint & Husky 설정","createdAt":"2023-06-25","updatedAt":"2023-06-25"},"fields":{"slug":"/posts/Frontend/Gatsby/04_ESLint_Prettier/"}},{"id":"a0a6e020-13b3-5b8c-a3a9-731d0b01e16c","excerpt":"아래 내용은 주관적인 의견이고, 카카오 FE 기술 블로그의 내용을 참조했습니다. 1. Sass 다크모드 한동안 다크모드를 공부한 적이 있다. Styled Component와 같은 CSS-in-JS…","parent":{"id":"f070924b-4b2c-5a2e-ae60-efbd70ce23c9","name":"05_Dark_Mode","relativePath":"Frontend/Gatsby/05_Dark_Mode.md"},"frontmatter":{"title":"05. Gatsby 다크모드 구현하기 (feat. Sass)","createdAt":"2023-06-26","updatedAt":"2023-06-26"},"fields":{"slug":"/posts/Frontend/Gatsby/05_Dark_Mode/"}},{"id":"8dd7c7ba-002c-5398-92a5-b43faf1f595b","excerpt":"1. SSG 렌더링 React에서는 Nested Route로 손 쉽게 레이아웃을 구현할 수 있다. 그런데 Gatsby는 Single Page Application이 아니다! Gatsby는 정적 사이트 생성기(SSG)로 빌드 시에, 모든 url…","parent":{"id":"7dc89b39-7e64-5368-9d05-118f4f02d985","name":"06_Navigation_Layout","relativePath":"Frontend/Gatsby/06_Navigation_Layout.md"},"frontmatter":{"title":"06. Gatsby 네비게이션 레이아웃 설정","createdAt":"2023-06-27","updatedAt":"2023-06-27"},"fields":{"slug":"/posts/Frontend/Gatsby/06_Navigation_Layout/"}},{"id":"f2e3f78d-324e-5387-b630-101288184fae","excerpt":"1. 튜토리얼 방식의 한계 Gatsby 튜토리얼 Part6 를 보면 file system routes라고 해서 파일시스템에 있는 파일들에 대해서 동적으로 페이지를 생성하는 방법을 소개한다. 예를 들어 아래 그림처럼 src/pages/아래에 {mdx…","parent":{"id":"0384b347-d777-5cc3-943b-91771189a957","name":"07_Custom_Pages","relativePath":"Frontend/Gatsby/07_Custom_Pages.md"},"frontmatter":{"title":"07. Gatsby 커스텀 페이지 생성","createdAt":"2023-06-27","updatedAt":"2023-06-27"},"fields":{"slug":"/posts/Frontend/Gatsby/07_Custom_Pages/"}},{"id":"19ad15a7-720c-5daf-880f-06af0a704144","excerpt":"1. GraphQL 아직 GraphQL을 파일시스템에 대해서 밖에 사용하지 않아, 정확히 GraphQL이 뭔지는 감이 안잡힌다. 하지만 그 제한된 경험으로도 GrqphQL이 기존 API…","parent":{"id":"daf85c35-0844-5cdb-8909-f001a0714f75","name":"08_Diretory_Based_Category","relativePath":"Frontend/Gatsby/08_Diretory_Based_Category.md"},"frontmatter":{"title":"08. 폴더 구조 기반 Gatsby 카테고리 바 생성","createdAt":"2023-06-28","updatedAt":"2023-06-28"},"fields":{"slug":"/posts/Frontend/Gatsby/08_Diretory_Based_Category/"}},{"id":"6ae60c60-1e09-59a3-8a3c-f12ca9abd1c4","excerpt":"gatsby-transformer-remark플러그인을 통한 markdownRemark노드를 사용을 전제합니다. 1. 마크다운 스타일링 나는 분명 Gatsby 공식문서를 따라 gatsby-transformer-remark…","parent":{"id":"e5909625-6638-5137-b366-16bba9f61baf","name":"09_Markdown_Styling","relativePath":"Frontend/Gatsby/09_Markdown_Styling.md"},"frontmatter":{"title":"09. Gatsby 마크다운(md) 스타일링","createdAt":"2023-06-29","updatedAt":"2023-06-29"},"fields":{"slug":"/posts/Frontend/Gatsby/09_Markdown_Styling/"}},{"id":"187472ff-d02f-5104-9b2e-515b0b1898f2","excerpt":"1. URL 프래그먼트 식별자(#) 일단 프래그먼트 식별자(a.k.a. #)이 어떻게 동작하는 알 필요가 있다. 나는 평소 너무 당연하게 써왔지만, 어떻게 동작하는지는 한 번도 생각해보지 않았다. 사용자가 URL…","parent":{"id":"0a367c55-81a1-5059-8814-42d23ceac89a","name":"10_Table_of_Contents","relativePath":"Frontend/Gatsby/10_Table_of_Contents.md"},"frontmatter":{"title":"10. Gatsby 스크롤 반응형 목차(TOC) 생성","createdAt":"2023-06-30","updatedAt":"2023-06-30"},"fields":{"slug":"/posts/Frontend/Gatsby/10_Table_of_Contents/"}},{"id":"1e126097-6df5-5927-8c17-282ca0974e45","excerpt":"1. Utterances와 Giscus 따로 서버를 돌리지 않고서는 댓글/좋아요 기능을 구현할 수 없을 줄 알았다. 그런데 항상 개발자들은 신박한 방법을 찾아낸다. GitHub API…","parent":{"id":"86d49b0e-e662-5a09-8fa5-8d69829c899f","name":"11_utterances_giscus","relativePath":"Frontend/Gatsby/11_utterances_giscus.md"},"frontmatter":{"title":"11. Gatsby 댓글 및 좋아요 기능","createdAt":"2023-07-02","updatedAt":"2023-07-02"},"fields":{"slug":"/posts/Frontend/Gatsby/11_utterances_giscus/"}}]}},"pageContext":{"pagePath":"/posts/Frontend/Gatsby/11_utterances_giscus/","siblingPostsPathRegex":"/^(?!.*README).*Frontend\\/Gatsby\\/.*$/","relativeDirectory":"Gatsby","id":"1e126097-6df5-5927-8c17-282ca0974e45","parent":{"id":"86d49b0e-e662-5a09-8fa5-8d69829c899f","name":"11_utterances_giscus","relativePath":"Frontend/Gatsby/11_utterances_giscus.md"},"fields":{"slug":"/posts/Frontend/Gatsby/11_utterances_giscus/"}}},"staticQueryHashes":["24302420","4059933791"],"slicesMap":{}}