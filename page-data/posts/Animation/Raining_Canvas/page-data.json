{"componentChunkName":"component---src-templates-post-index-tsx","path":"/posts/Animation/Raining_Canvas/","result":{"data":{"markdownRemark":{"id":"d9a53b8e-d65a-5893-8f92-fa3574405c56","html":"<h1 id=\"1-목표\" style=\"position:relative;\"><a href=\"#1-%EB%AA%A9%ED%91%9C\" aria-label=\"1 목표 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 목표</h1>\n<p><a href=\"https://www.youtube.com/watch?v=o9DWbtkQ5g8\">\"YouTube: 자바스크립트 Canvas로 비내리는 인터렉티브한 배경 만들기 튜토리얼, 맛있는 코딩\"</a> 를 따라잡고, Prop을 받아 커스텀할 수 있는 리액트 컴포넌트로 만드는게 목표다.</p>\n<p><img src=\"/TIL/868b90757d1434b1c0157a1a446fe96b/raining-canvas.gif\" alt=\"raining-canvas.gif)\"></p>\n<p>다음과 같은 Prop을 받아 리액트 컴포넌트를 커스텀할 수 있도록 할 것이다.</p>\n<pre><code class=\"language-js\">type Props = {\n  amount?: number   // 빗줄기 갯수: 1 ~ 100\n  speed?: number    // 빗줄기 속도: 1 ~ 50\n  color?: string    // 빗줄기 색깔\n  isThunder?: boolean   // 천둥 여부\n  thunderRate?: number  // 천둥 빈도: 0 ~ 1\n}\n</code></pre>\n<h1 id=\"2-리액트-코드\" style=\"position:relative;\"><a href=\"#2-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BD%94%EB%93%9C\" aria-label=\"2 리액트 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 리액트 코드</h1>\n<p><a href=\"https://github.com/Byongho96/TIL/tree/master/src/components/raining-canvas\">Github 소스코드</a></p>\n<p>강의의 자바스크립트 코드를, 약간만 커스텀해서 리액트 컴포넌트로 바꿨다.<br>\n그 과정에서 특별히 언급할 만한 부분이 2개가 있다.</p>\n<ul>\n<li>\n<p><strong>useEffect</strong><br>\nProp에 따라 렌더링이 다시 일어나야했기 때문에 <code>useEffect</code>문에 실행함수를 넣어주고, 적절하게 클린업 함수를 추가해주었다.</p>\n</li>\n<li>\n<p><strong>바람</strong><br>\n<a href=\"https://www.youtube.com/watch?v=o9DWbtkQ5g8\">강의</a>의 9:58를 보면, 마우스 위치에 따른 바람 효과를 주고자 다음과 같이 코드를 작성한다.</p>\n<pre><code class=\"language-js\">this.velocity.x += mouse.isActive\n  ? randomBetween(-1, 1) + (-innerWidth / 2 + mouse.x)\n  : randomBetween(-1, 1)\n</code></pre>\n<p>근데 위와 같이 코드를 작성하면, <code>velocity.x</code>가 계속해서 랜덤하게 바뀌기 때문에 빗줄기가 마치 지렁이처럼 꿈틀거린다.</p>\n<p><img src=\"/TIL/72cb67d6ceca814e1bf1eac86909c79d/raining-canvas-before.gif\" alt=\"raining-canvas-before.gif\"></p>\n<p>그래서 나는 처음할당 된<code>velocity.x</code>(<code>dx</code>)를 랜덤하게 재할당 하지 않고, <code>wind</code>변수를 추가로 만들어 적절한 위치에 추가했다. 그 결과 빗줄기가 아래처럼 깔끔하게 떨어진다.</p>\n<p><img src=\"/TIL/f14dccc835f0899f6ced15f36207b867/raining-canvas-after.gif\" alt=\"raining-canvas-after.gif\"></p>\n</li>\n</ul>\n<pre><code class=\"language-js\">import React, { useEffect, useRef } from 'react'\n\ntype Props = {\n  amount?: number\n  speed?: number\n  color?: string\n  isThunder?: boolean\n  thunderRate?: number\n}\n\nconst RainingCanvas: React.FC&#x3C;Props> = ({\n  amount = 30,\n  speed = 15,\n  color = '#ffffff',\n  isThunder = true,\n  thunderRate = 0.1,\n  containerRef = null,\n}) => {\n  const canvasRef = useRef&#x3C;HTMLCanvasElement>(null)\n\n  useEffect(() => {\n    // amount 제한 1 ~ 100\n    if (amount &#x3C;= 0 || 100 &#x3C; amount) {\n      throw new Error(\n        'amount is out of range, It should be greater than 0 and less than 100'\n      )\n    }\n    // speed 제한 1 ~ 50\n    if (speed &#x3C;= 0 || 50 &#x3C; speed) {\n      throw new Error(\n        'speed is out of range, It should be greater than 0 and less than 50'\n      )\n    }\n    // thunderRate 제한 0~1\n    if (thunderRate &#x3C;= 0 || 1 &#x3C; thunderRate) {\n      throw new Error(\n        'thunderRate is out of range, It should be greater than 0 and less than 1'\n      )\n    }\n  }, [amount, speed, thunderRate])\n\n  useEffect(() => {\n    const canvas = canvasRef.current\n\n    if (\n      !(canvas instanceof HTMLCanvasElement) ||\n      !(canvas.parentElement instanceof HTMLElement)\n    )\n      return\n\n    const ctx = canvas.getContext('2d')\n    const mouse = { x: 0, y: 0, isActive: false } // 마우스 정보\n    let rainDropArray: RainDrop[] = [] // 빗줄기 인스턴스를 담는 배열\n    let rainSplashArray: RainSplash[] = [] // 튀기는 빗방울 인스턴스름 담는 배열\n    let thunder: Thunder = null\n    if (isThunder) {\n      thunder = new Thunder()\n    }\n\n    // canvas 초기화 함수\n    const init = function () {\n      rainDropArray = []\n      rainSplashArray = []\n\n      // containerRef에 따라 캔버스 크기 조절\n      const innerWidth = canvas.parentElement.clientWidth\n      const innerHeight = canvas.parentElement.clientHeight\n      canvas.width = innerWidth\n      canvas.height = innerHeight\n\n      // 캔버스 크기에 따라 빗줄기 갯수 설정\n      const total = Math.floor((innerWidth * innerHeight * amount) / 400000)\n      // 빗줄기 생성\n      for (let i = 0; i &#x3C; total; i++) {\n        const x = Math.random() * innerWidth\n        const y = Math.random() * innerHeight\n        const dx = Math.random() * 0.1 - 0.05\n        const dy = Math.random() * 5 + parseInt(speed) // 왜인지 오류가 남\n        rainDropArray.push(new RainDrop(x, y, dx, dy, color, rainSplashArray))\n      }\n    }\n\n    // cavnas 렌더링(애니메이션) 함수\n    let requestAnimationId: number = null\n    const render = function () {\n      ctx.clearRect(0, 0, canvas.width, canvas.height)\n      // 빗줄기 애니메이션\n      const wind = mouse.isActive ? (mouse.x - ctx.canvas.width / 2) / 80 : 0 // 마우스 위치에 따른 바람\n      rainDropArray.forEach((rainDrop) => {\n        rainDrop.animate(ctx, wind)\n      })\n      // 튀기는 빗방울 애니메이션\n      rainSplashArray.forEach((rainSplash, idx) => {\n        rainSplash.animate(ctx)\n        if (rainSplash.y > canvas.height) {\n          rainSplashArray.splice(idx, 1) // 튀기는 물방울은 1회성으로 제거\n        }\n      })\n      // 천둥 애니메이션\n      if (thunder) {\n        if (Math.random() &#x3C; thunderRate * 0.05) {\n          thunder.opacity = 0.3\n        }\n        thunder.animate(ctx)\n      }\n      requestAnimationId = window.requestAnimationFrame(render) // requestAnmiationFrame\n    }\n\n    init() // 초기화\n    render() // 애니메이션 시작\n\n    // 화면 리사이즈 시, 초기화 함수 동작\n    window.addEventListener('resize', init)\n\n    // 캔버스에 마우스 관련 이벤트리스너 등록 => mouse 객체 업데이트\n    const setMouseActive = function () {\n      mouse.isActive = true\n    }\n    const setMouseInactive = function () {\n      mouse.isActive = false\n    }\n    const setMousePosition = function (e: React.MouseEvent) {\n      mouse.x = e.clientX\n      mouse.y = e.clientY\n    }\n    canvas.addEventListener('mouseenter', setMouseActive)\n    canvas.addEventListener('mouseleave', setMouseInactive)\n    canvas.addEventListener('mousemove', setMousePosition)\n\n    return () => {\n      window.cancelAnimationFrame(requestAnimationId)\n      window.removeEventListener('resize', init)\n      canvas.removeEventListener('mouseenter', setMouseActive)\n      canvas.removeEventListener('mouseleave', setMouseInactive)\n      canvas.removeEventListener('mousemove', setMousePosition)\n    }\n  }, [color, amount, speed, isThunder, thunderRate, containerRef])\n\n  return &#x3C;canvas ref={canvasRef} />\n}\n\nexport default RainingCanvas\n\n// 떨어지는 빗방울\nclass RainDrop {\n  x: number\n  y: number\n  dx: number\n  dy: number\n  wind: number\n  color: string\n  splashArray: RainSplash[]\n  // 생성자 (위치 좌표, 이동 속도)\n  constructor(\n    x: number,\n    y: number,\n    dx: number,\n    dy: number,\n    color: string,\n    splashArray: RainSplash[]\n  ) {\n    this.x = x\n    this.y = y\n    this.dx = dx\n    this.dy = dy\n    this.wind = 0\n    this.color = color\n    this.splashArray = splashArray\n  }\n\n  // 빗줄기 그리기\n  draw(ctx: CanvasRenderingContext2D) {\n    const { x, y, dx, dy, wind, color } = this\n    ctx.beginPath()\n    ctx.moveTo(x, y)\n    ctx.lineTo(x + dx + wind, y + 1.5 * dy) // MAGIC_NUMBER: 적절히 빗줄기를 길게 그려줌\n    ctx.strokeStyle = color\n    ctx.lineWidth = 1\n    ctx.stroke()\n  }\n\n  // 튀기는 물방울 생성\n  splash() {\n    const { x, y, dx, dy, color, splashArray } = this\n    for (let i = 0; i &#x3C; 3; i++) {\n      const splash_dx = Math.random() * 6 + dx - 1 // 물방울의 x축 속도 (적절히 커스텀)\n      const splash_dy = Math.random() * 0.7 - dy * 0.24 // 물방울의 y축 속도 (적절히 커스텀)\n      splashArray.push(new RainSplash(x, y, splash_dx, splash_dy, color))\n    }\n  }\n\n  // 빗줄기 이동\n  animate(ctx: CanvasRenderingContext2D, wind = 0) {\n    // 빗줄기가 캔버스 아래로 내려가면, 다시 위로 이동\n    if (this.y > ctx.canvas.height) {\n      this.splash()\n      this.x = Math.random() * ctx.canvas.width * 1.4 - ctx.canvas.width * 0.2 // 적당히 캔버스의 너비를 초과하게\n      this.y = -50 // 적당히 캔버스 위\n    }\n    this.wind = wind\n    this.x += this.dx + wind\n    this.y += this.dy\n    this.draw(ctx)\n  }\n}\n\n// 빗방울 떨어졌을 때 튀기는 물방울\nclass RainSplash {\n  x: number\n  y: number\n  dx: number\n  dy: number\n  color: string\n  // 생성자 (위치 좌표, 이동 속도)\n  constructor(x: number, y: number, dx: number, dy: number, color: string) {\n    this.x = x\n    this.y = y\n    this.dx = dx\n    this.dy = dy\n    this.color = color\n    this.GRAVITY = 1.5 // MAGIC_NUMBER: 중력가속도\n  }\n\n  // 물방울(동그라미) 그리기\n  draw(ctx: CanvasRenderingContext2D) {\n    const { x, y, color } = this\n    const radius = Math.random() * 0.5 + 0.85\n    ctx.beginPath()\n    ctx.arc(x, y, radius, 0, Math.PI * 2) // 원 그리기 arc(x, y, radius, startAngle, endAngle)\n    ctx.fillStyle = color\n    ctx.fill()\n  }\n\n  // 물방울 애니메이션 (포물선 형태로 올라갔다가 떨어짐)\n  animate(ctx: CanvasRenderingContext2D) {\n    this.x += this.dx\n    this.y += this.dy\n    this.dy += this.GRAVITY // 중력 가속도\n    this.draw(ctx)\n  }\n}\n\nclass Thunder {\n  opacity: number\n  // 생성자\n  constructor() {\n    this.opacity = 0\n  }\n\n  // 천둥 그리기\n  draw(ctx: CanvasRenderingContext2D) {\n    const gradient = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height) // gradient 좌표정보 (시작 x, 시작 y, 끝 x, 끝 y)\n    gradient.addColorStop(0, `rgba(180, 190, 255, ${this.opacity})`) // 시작 색상 (offset, color)\n    gradient.addColorStop(1, `rgba(0, 0, 0, 0)`) // 끝 색상(offset, color)\n    ctx.fillStyle = gradient\n    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n  }\n\n  // 천둥 애니메이션\n  animate(ctx: CanvasRenderingContext2D) {\n    if (this.opacity &#x3C; 0) return\n    this.opacity -= 0.003\n    this.draw(ctx)\n  }\n}\n\n</code></pre>\n<h1 id=\"3-사용-예시\" style=\"position:relative;\"><a href=\"#3-%EC%82%AC%EC%9A%A9-%EC%98%88%EC%8B%9C\" aria-label=\"3 사용 예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 사용 예시</h1>\n<p><a href=\"https://byongho96.github.io/TIL/404/\">애니메이션 라이브 페이지로!</a></p>\n<p><img src=\"/TIL/868b90757d1434b1c0157a1a446fe96b/raining-canvas.gif\" alt=\"raining-canvas.gif)\"></p>\n<p>Context API를 이용해 <code>theme</code>을 관리하는 상황에서, 아래와 같이 <code>theme</code>에 따라 동적으로 prop을 내려줄 수도 있다.</p>\n<pre><code class=\"language-js\">import React, { useContext } from 'react'\nimport RainingCanvas from './ RainingCanvas.tsx'\nimport { ThemeContext } from '@contexts/theme-context'\n\nconst App: React.FC = () => {\n  const { theme } = useContext(ThemeContext)\n\n  // theme에 따라 비의 색깔과 천둥 여부 결정\n  const { color, isThunder } = useMemo(() => {\n    let color = '#eeeeeeaa'\n    let isThunder = true\n    if (theme === 'light') {\n      color = '#888888aa'\n      isThunder = false\n    }\n    return { color, isThunder }\n  }, [theme])\n\n  return (\n    &#x3C;RainingCanvas\n      color={color}\n      isThunder={isThunder}\n      amount={amount}\n      speed={speed}\n      thunderRate={thunderRate}\n    />\n  )\n}\n\nexport default App\n</code></pre>\n<p><a href=\"https://byongho96.github.io/TIL/404/\">애니메이션 라이브 페이지로 이동!</a></p>","tableOfContents":"<ul>\n<li><a href=\"#1-%EB%AA%A9%ED%91%9C\">1. 목표</a></li>\n<li><a href=\"#2-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BD%94%EB%93%9C\">2. 리액트 코드</a></li>\n<li><a href=\"#3-%EC%82%AC%EC%9A%A9-%EC%98%88%EC%8B%9C\">3. 사용 예시</a></li>\n</ul>","frontmatter":{"title":"비 내리는 캔버스 애니메이션 (React 컴포넌트)","createdAt":"2023-07-06","updatedAt":"2023-07-06","tags":["CSS","JavaScript","canvas","애니메이션","캔버스","비"],"description":"비 내리는 캔버스 애니메이션을 리액트 컴포넌트로 만들어본다.","reference":"https://www.youtube.com/watch?v=o9DWbtkQ5g8"}},"allMarkdownRemark":{"nodes":[{"id":"e342031d-15e0-5a29-b5e7-06d909d9d342","excerpt":"1. 목표 \"YouTube: 자바스크립트로 11분만에 카드 스크롤 애니메이션 마스터하기, 맛있는 코딩\" 를 따라잡고, 이를 커스텀할 수 있는 리액트 컴포넌트로 만드는게 목표다. scroll-3d-card.gif) 안타깝지만 나는 저 강의를 1…","parent":{"id":"ef34e23c-385f-582d-8e54-f832e8635936","name":"Scroll_3D_Card","relativePath":"Animation/Scroll_3D_Card.md"},"frontmatter":{"title":"3D 카드 스크롤 애니메이션 (React 컴포넌트)","createdAt":"2023-07-05","updatedAt":"2023-07-05"},"fields":{"slug":"/posts/Animation/Scroll_3D_Card/"}},{"id":"d1e1686e-9471-574a-ae2f-18e680057aca","excerpt":"1. 사건의 발단 CSS를 하다보면 종종 개빡치는 일이 생기기 마련이다. 빡침의 이유도 가지 각색인데, 오늘 다루고자 하는 주제는 '이게 안된다고?'하는 느낌이다. 바로 CSS에서 height를 0에서 auto…","parent":{"id":"5aaae26e-1553-5935-8ffb-cb59b5945904","name":"Height_Animation","relativePath":"Animation/Height_Animation.md"},"frontmatter":{"title":"CSS 높이(height) 0 to auto 애니메이션","createdAt":"2023-06-28","updatedAt":"2023-06-28"},"fields":{"slug":"/posts/Animation/Height_Animation/"}},{"id":"b0cbb5c6-bb89-5972-8720-50aadbc98a6f","excerpt":"1. 목표 \"YouTube: 자바스크립트로 5분만에 텍스트 스크롤 애니메이션 효과(text marquee effect) 마스터하기, 맛있는 코딩\" 를 따라잡고, 이를 커스텀할 수 있는 리액트 컴포넌트로 만드는게 목표다. infinite-text…","parent":{"id":"81cc7ed8-e576-5259-b6b6-2fab4b244e3e","name":"Infinite_Text_Tape","relativePath":"Animation/Infinite_Text_Tape.md"},"frontmatter":{"title":"무한 텍스트 테이프 애니메이션 (React 컴포넌트)","createdAt":"2023-07-07","updatedAt":"2023-07-07"},"fields":{"slug":"/posts/Animation/Infinite_Text_Tape/"}},{"id":"e2a3d898-cf20-5094-9d67-6f7df95da780","excerpt":"1. 목표 1.1. react-responsive-carousel 오늘은 'npm react carousel'을 구글링하면 제일 상단에 나오는 react-responsive-carousel과 유사하게 동작하는 리액트 컴포넌트를 만들어 볼 것이다. 2d…","parent":{"id":"6a368a04-1577-5c38-9c67-7018548c05f4","name":"2D_Carousel","relativePath":"Animation/2D_Carousel.md"},"frontmatter":{"title":"반응형 2D 캐러셀 (React 컴포넌트)","createdAt":"2023-07-10","updatedAt":"2023-07-10"},"fields":{"slug":"/posts/Animation/2D_Carousel/"}},{"id":"d9a53b8e-d65a-5893-8f92-fa3574405c56","excerpt":"1. 목표 \"YouTube: 자바스크립트 Canvas로 비내리는 인터렉티브한 배경 만들기 튜토리얼, 맛있는 코딩\" 를 따라잡고, Prop을 받아 커스텀할 수 있는 리액트 컴포넌트로 만드는게 목표다. raining-canvas.gif…","parent":{"id":"15a32b0f-ab8e-5cd8-bdc9-173af52b7323","name":"Raining_Canvas","relativePath":"Animation/Raining_Canvas.md"},"frontmatter":{"title":"비 내리는 캔버스 애니메이션 (React 컴포넌트)","createdAt":"2023-07-06","updatedAt":"2023-07-06"},"fields":{"slug":"/posts/Animation/Raining_Canvas/"}},{"id":"e070d9f5-57b8-53c2-bb0e-25ef3e98fcb6","excerpt":"1. 목표 1.1. react-type-animation 구글링하면 react-type-animation라는 리액트용 타이핑 애니메이션 라이브러리가 바로 나온다. 이 라이브러리와 유사하게 동작하는 리액트 컴포넌트를 만드는 것이 오늘의 목표다. my…","parent":{"id":"df0725c8-ac33-5639-b391-21726edd7c7b","name":"Typing_Animation","relativePath":"Animation/Typing_Animation.md"},"frontmatter":{"title":"타이핑 애니메이션 (React 컴포넌트)","createdAt":"2023-06-22","updatedAt":"2023-06-22"},"fields":{"slug":"/posts/Animation/Typing_Animation/"}}]}},"pageContext":{"pagePath":"/posts/Animation/Raining_Canvas/","siblingPostsPathRegex":"/^(?!.*README).*Animation.*$/","relativeDirectory":"Animation","id":"d9a53b8e-d65a-5893-8f92-fa3574405c56","parent":{"id":"15a32b0f-ab8e-5cd8-bdc9-173af52b7323","name":"Raining_Canvas","relativePath":"Animation/Raining_Canvas.md"},"fields":{"slug":"/posts/Animation/Raining_Canvas/"}}},"staticQueryHashes":["24302420","4059933791"],"slicesMap":{}}