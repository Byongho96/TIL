{"componentChunkName":"component---src-templates-post-index-tsx","path":"/posts/Animation/Typing_Animation.md/","result":{"data":{"markdownRemark":{"id":"e070d9f5-57b8-53c2-bb0e-25ef3e98fcb6","html":"<h1 id=\"1-목표\" style=\"position:relative;\"><a href=\"#1-%EB%AA%A9%ED%91%9C\" aria-label=\"1 목표 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 목표</h1>\n<h2 id=\"11-react-type-animation\" style=\"position:relative;\"><a href=\"#11-react-type-animation\" aria-label=\"11 react type animation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1. react-type-animation</h2>\n<p>구글링하면 <a href=\"https://www.npmjs.com/package/react-type-animation\">react-type-animation</a>라는 리액트용 타이핑 애니메이션 라이브러리가 바로 나온다. <strong>이 라이브러리와 유사하게 동작하는 리액트 컴포넌트</strong>를 만드는 것이 오늘의 목표다.</p>\n<p><img src=\"/TIL/b64a4653fb40705b3ded4f94dd6d99f9/react-type-animation.gif\" alt=\"react-type-animation.gif\"></p>\n<h2 id=\"12-props-설정\" style=\"position:relative;\"><a href=\"#12-props-%EC%84%A4%EC%A0%95\" aria-label=\"12 props 설정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2. props 설정</h2>\n<p>오늘 만들 Type 컴포넌트는 다음과 같은 prop을 받는다.</p>\n<pre><code class=\"language-js\">type Props = {\n  phrases: string[] // 순서대로 타이핑 할 문구 리스트\n  speed?: number // 타이핑 속도\n  style?: object // 인라인 스타일 객체\n  pause?: number // 한 개의 텍스트가 완성되고, 다음 텍스트가 타이핑 되기 전 대기시간\n  isInfinite?: boolean // 타이핑 무한 반복 여부\n}\n\n</code></pre>\n<h1 id=\"2-전체-코드\" style=\"position:relative;\"><a href=\"#2-%EC%A0%84%EC%B2%B4-%EC%BD%94%EB%93%9C\" aria-label=\"2 전체 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 전체 코드</h1>\n<p>타이핑 애니메이션을 구현하기 위해서 JS와 CSS를 모두 사용했다. 특별하게 설명하고 싶은 부분이 2개 있다.</p>\n<ul>\n<li>\n<p><strong><code>element.textContext</code></strong></p>\n<ul>\n<li><code>useState</code>를 사용하는 것은 추천하지 않는다. <code>setState</code>자체가 비동기적이어서 그런지, 속도가 아주 빨라지면 철자 오류가 발생했다.</li>\n<li><code>element.innerText</code>가 공백을 인식하지 못해서 <code>textContext</code>를 사용했다.</li>\n</ul>\n</li>\n<li>\n<p><strong>CSS 가상선택자</strong></p>\n<ul>\n<li>YouTube강의를 보면 <code>border-right</code>요소로 커서를 구현하는 경우가 있다. 하지만 그럴 경우, 코드가 2줄 이상이 되면 요소 전체의 오른쪽에 커서 크게 생기는 오류가 발생했다. 또한 <code>font</code>와 <code>border</code>설정을 맞춰줘야하는 번거로움이 있다.</li>\n<li>가상선택자로 <code>'|'</code>라는 문자를 표시하면 위의 문제를 모두 해결할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">import React, { useRef, useState, useEffect } from 'react'\nimport './style.scss'\n\ntype Props = {\n  phrases: string[] // 순서대로 타이핑 할 문구 리스트\n  speed?: number // 타이핑 속도\n  style?: object // 인라인 스타일 객체\n  pause?: number // 한 개의 텍스트가 완성되고, 다음 텍스트가 타이핑 되기 전 대기시간\n  isInfinite?: boolean // 타이핑 무한 반복 여부\n}\n\nconst TypeAnimation: React.FC&#x3C;Props> = ({\n  phrases,\n  speed = 5,\n  style = {},\n  pause = 2000, // 기본 대기 시간 2초\n  isInfinite = false,\n}) => {\n  const textElementRef = useRef&#x3C;HTMLSpanElement>(null)\n\n  useEffect(() => {\n    const textElement = textElementRef.current // 타이핑을 입력한 타겟 Element\n\n    if (!textElement) return\n\n    let phraseIdx = 0 // 현재 타이핑하는 문구의 인덱스\n    let charIdx = 0 // 현재 타이핑하는 글자 인덱스\n    let interval = null // setInterval을 담을 변수\n\n    // 2. 타이핑 메인 함수\n    function typeText() {\n      textElement.style.setProperty('--cursor-opacity', 1) // 타이핑 하는 동안은 커서 깜빡이지 않도록\n      const currentPhrase = phrases[phraseIdx] // 현재 타이핑하는 문구\n\n      // 현재 문구 타이핑이 안 끝났을 경우\n      if (charIdx &#x3C; currentPhrase.length) {\n        textElement.textContent += currentPhrase[charIdx++] // innerText 대신 textContent 사용해야 공백을 담을 수 있음\n        return\n      }\n      // 현재 문구가 마지막 문구가 아닐 경우\n      if (phraseIdx &#x3C; phrases.length - 1) {\n        phraseIdx++ // 다음 문구로 이동\n        charIdx = 0 // 첫 번째 글자로 이동\n        retypeAfterPause()\n        return\n      }\n      // 무한 반복이 설정되어 있을 경우\n      if (isInfinite) {\n        phraseIdx = 0 // 처음 문구로 이동\n        charIdx = 0 // 첫 번재 글자로 이동\n        retypeAfterPause()\n        return\n      }\n      // 타이핑 종료\n      textElement.style.setProperty('--cursor-opacity', 0) // 타이핑 종료 후 커서 깜빡이도록\n      interval &#x26;&#x26; clearInterval(interval)\n    }\n\n    // 3. 일시 정지 후, 문구 초기화한 뒤 타이핑 재시작하는 함수\n    function retypeAfterPause() {\n      textElement.style.setProperty('--cursor-opacity', 0) // 이리 정지하는 동안 커서 깜빡이도록\n      interval &#x26;&#x26; clearInterval(interval) // 기존 setInterval 제거\n\n      // pause 이 후, setInterval 재시작\n      setTimeout(() => {\n        textElement.innerText = '' // 문구 초기화\n        interval = setInterval(typeText, 1000 / speed)\n      }, pause)\n    }\n\n    // 1. setInterval로 타이핑 시작\n    interval = setInterval(typeText, 1000 / speed)\n\n    // clear 함수\n    return () => {\n      interval &#x26;&#x26; clearInterval(interval)\n    }\n  }, [phrases, speed, pause, isInfinite])\n\n  return (\n    &#x3C;span\n      ref={textElementRef}\n      className=\"type-animation-text\"\n      style={style}>&#x3C;/span>\n  )\n}\n\nexport default TypeAnimation\n\n</code></pre>\n<pre><code class=\"language-scss\">.type-animation-text {\n  // 가상 선택자로 커서 생성\n  &#x26;::after {\n    content: '|';\n    opacity: 1;\n    animation: blink 1s steps(1, end) infinite;\n  }\n}\n\n// 커서가 깜빡이는 애니메이션\n// js에서 전달받은 값에 따라 깝빡임 여부 결정\n@keyframes blink {\n  50% {\n    opacity: var(--cursor-opacity);\n  }\n}\n</code></pre>\n<h1 id=\"3-사용-예시\" style=\"position:relative;\"><a href=\"#3-%EC%82%AC%EC%9A%A9-%EC%98%88%EC%8B%9C\" aria-label=\"3 사용 예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 사용 예시</h1>\n<p><img src=\"/TIL/a1df2c0299339c1c7a39feff27e6acef/my-type-animation.gif\" alt=\"my-type-animation.gif\"></p>\n<pre><code class=\"language-js\">import * as React from 'react'\nimport TypeAnimation from './TypeAnimation.tsx'\n\nconst App: React.FC = () => {\n  return (\n    &#x3C;div\n      style={{\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'center',\n      }}>\n      &#x3C;TypeAnimation\n        phrases={['I love chicken', 'Do you like chicken?', 'Of course!!!']}\n        speed={7}\n        style={{\n          color: 'gray',\n          fontSize: '4rem',\n          fontWeight: 'bold',\n        }}\n        pause={2000}\n        isInfinite={true}\n      />\n    &#x3C;/div>\n  )\n}\n\nexport default App\n</code></pre>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-%EB%AA%A9%ED%91%9C\">1. 목표</a></p>\n<ul>\n<li><a href=\"#11-react-type-animation\">1.1. react-type-animation</a></li>\n<li><a href=\"#12-props-%EC%84%A4%EC%A0%95\">1.2. props 설정</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-%EC%A0%84%EC%B2%B4-%EC%BD%94%EB%93%9C\">2. 전체 코드</a></p>\n</li>\n<li>\n<p><a href=\"#3-%EC%82%AC%EC%9A%A9-%EC%98%88%EC%8B%9C\">3. 사용 예시</a></p>\n</li>\n</ul>","frontmatter":{"title":"타이핑 애니메이션 (React 컴포넌트)","createdAt":"2023-06-22","updatedAt":"2023-06-22","tags":["CSS","Animation","JavaScript","타이핑"],"description":"타이핑 애니메이션(Typing Animation) 리액트 컴포넌트","reference":null}},"allMarkdownRemark":{"nodes":[{"id":"e070d9f5-57b8-53c2-bb0e-25ef3e98fcb6","parent":{"id":"df0725c8-ac33-5639-b391-21726edd7c7b","name":"Typing_Animation","relativePath":"Animation/Typing_Animation.md"},"frontmatter":{"title":"타이핑 애니메이션 (React 컴포넌트)","createdAt":"2023-06-22","updatedAt":"2023-06-22"},"excerpt":"1. 목표 1.1. react-type-animation 구글링하면 react-type-animation…"}]}},"pageContext":{"pagePath":"posts/Animation/Typing_Animation.md","regex":"/^(?!.*README).*Animation.*$/","relativeDirectory":"Animation","id":"e070d9f5-57b8-53c2-bb0e-25ef3e98fcb6","parent":{"id":"df0725c8-ac33-5639-b391-21726edd7c7b","name":"Typing_Animation","relativePath":"Animation/Typing_Animation.md"}}},"staticQueryHashes":["3300660363","3571427910"],"slicesMap":{}}