{"componentChunkName":"component---src-templates-post-index-tsx","path":"/posts/Language/JavaScript/proxy/","result":{"data":{"markdownRemark":{"id":"129e1e6c-97e5-54fe-8f18-bdb6f91f4c7c","html":"<blockquote>\n<p>진짜 가볍게 작성하려고 했는데 이틀이 걸렸다. 자바스크립트의 모든 문제는 결국 this인 것 같다.</p>\n</blockquote>\n<h1 id=\"1-proxy\" style=\"position:relative;\"><a href=\"#1-proxy\" aria-label=\"1 proxy permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Proxy</h1>\n<p><code>Proxy</code> 객체는 자바스크립트 <code>Object</code>에 대한 기본적인 접근(set, get, define) 요청에 대해 인터셉터를 구현하여, 특정로직을 수행한다.</p>\n<p>객체에 대한 접근 로그를 기록하거나, 입력값에 대한 그것을 제공한다. 간다니 말해서 이미 생성된 <code>Object</code>에 대해 손쉽게 getter와 setter 구현하는 것이다.</p>\n<h2 id=\"11-proxy-트랩-종류\" style=\"position:relative;\"><a href=\"#11-proxy-%ED%8A%B8%EB%9E%A9-%EC%A2%85%EB%A5%98\" aria-label=\"11 proxy 트랩 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1. Proxy 트랩 종류</h2>\n<p>handler 안에 구현된 인터셉터 함수를 <code>trap</code>이라고 한다. 각각의 함수들은 특정한 시점에 동작하여, 객체에 대한 접근을 가로챈다. 각 트랩이 받는 인자 정보는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy#handler_functions\">MDN 문서</a>에서 확인할 수 있다.</p>\n<table>\n<thead>\n<tr>\n<th>트랩</th>\n<th>작동 시점</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>get</td>\n<td>프로퍼티를 읽을 때</td>\n</tr>\n<tr>\n<td>set</td>\n<td>프로퍼티를 쓸 때</td>\n</tr>\n<tr>\n<td>has</td>\n<td>in 연산자가 동작할 때</td>\n</tr>\n<tr>\n<td>deleteProperty</td>\n<td>delete 연산자가 동작할 때</td>\n</tr>\n<tr>\n<td>apply</td>\n<td>함수를 호출할 때</td>\n</tr>\n<tr>\n<td>construct</td>\n<td>new 연산자가 동작할 때</td>\n</tr>\n<tr>\n<td>getPrototypeOf</td>\n<td>Object.getPrototypeOf 가 작동할 때</td>\n</tr>\n<tr>\n<td>setPrototypeOf</td>\n<td>Object.setPrototypeOf 가 작동할 때</td>\n</tr>\n<tr>\n<td>isExtensible</td>\n<td>Object.isExtensible 가 작동할 때</td>\n</tr>\n<tr>\n<td>preventExtensions</td>\n<td>Object.preventExtensions 가 작동할 때</td>\n</tr>\n<tr>\n<td>getOwnPropertyDescriptor</td>\n<td>Object.getOwnPropertyDescriptor 가 작동할 때</td>\n</tr>\n<tr>\n<td>ownKeys</td>\n<td>Object.getOwnPropertyNames 가 작동할 때 <br/>Object.getOwnPropertySymbols 가 작동할 때</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"12-기본-활용-예제\" style=\"position:relative;\"><a href=\"#12-%EA%B8%B0%EB%B3%B8-%ED%99%9C%EC%9A%A9-%EC%98%88%EC%A0%9C\" aria-label=\"12 기본 활용 예제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2. 기본 활용 예제</h2>\n<p>아래 예제들은 <a href=\"https://ko.javascript.info/proxy\">JavaScript.info 문서</a>를 기반으로 작성했다.</p>\n<h3 id=\"121-get\" style=\"position:relative;\"><a href=\"#121-get\" aria-label=\"121 get permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2.1. get</h3>\n<p>get 트랩으로 프로퍼티의 기본값을 설정할 수 있다.</p>\n<ul>\n<li><code>target</code>: 원본 객체</li>\n<li><code>property</code>: 프로퍼티 네임</li>\n<li><code>receiver</code>: 프록시 혹은 프록시를 상속받은 객체. 이녀석에 대한 자세한 내용은 Reflect에서 확인할 수 있다.</li>\n</ul>\n<pre><code class=\"language-js\">let numbers = [0, 1, 2]\n\nnumbers = new Proxy(numbers, {\n  get(target, prop, receiver) {\n    if (prop in target) {\n      return target[prop]\n    } else {\n      return 0 // 기본값\n    }\n  },\n})\n\nconsole.log(numbers[1]) // 1\nconsole.log(numbers[123]) // 0\n</code></pre>\n<h3 id=\"122-set\" style=\"position:relative;\"><a href=\"#122-set\" aria-label=\"122 set permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2.2. set</h3>\n<p>set 트랩으로 프로퍼티에 쓰려는 값을 검증할 수 있다.</p>\n<ul>\n<li><code>target</code>: 원본 객체</li>\n<li><code>property</code>: 프로퍼티 이름</li>\n<li><code>value</code> : 프로퍼티에 쓰려는 값</li>\n<li><code>receiver</code>: 프록시 혹은 프록시를 상속받은 객체. 이녀석에 대한 자세한 내용은 Reflect에서 확인할 수 있다.</li>\n</ul>\n<blockquote>\n<p>set 트랩이 성공했을 때 반드시 true를 반환해야한다. true이외의 값이 반환되면 TypeError가 발생한다.</p>\n</blockquote>\n<pre><code class=\"language-js\">let numbers = []\n\nnumbers = new Proxy(numbers, {\n  set(target, prop, val) {\n    if (typeof val == 'number') {\n      target[prop] = val\n      return true\n    } else {\n      return false\n    }\n  },\n})\n\nnumbers.push(1)\nnumbers.push(2)\nnumbers.push('test') // Error: 'set' on proxy\n\nconsole.log('윗줄에서 에러가 발생했기 때문에 이 줄이 실행되지 않음')\n</code></pre>\n<h3 id=\"123-has\" style=\"position:relative;\"><a href=\"#123-has\" aria-label=\"123 has permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2.3. has</h3>\n<p>has 트랩으로 범위 내 여부를 확인하는 프록시 객체를 만들 수 있다.</p>\n<ul>\n<li><code>target</code>: 원본 객체</li>\n<li><code>property</code>: 프로퍼티 네임</li>\n</ul>\n<pre><code class=\"language-js\">let range = {\n  start: 1,\n  end: 10,\n}\n\nrange = new Proxy(range, {\n  has(target, prop) {\n    return prop >= target.start &#x26;&#x26; prop &#x3C;= target.end\n  },\n})\n\nconsole.log(5 in range) // true\nconsole.log(50 in range) // false\n</code></pre>\n<h3 id=\"124-deleteproperty와-여러-트랩으로-프로퍼티-보호\" style=\"position:relative;\"><a href=\"#124-deleteproperty%EC%99%80-%EC%97%AC%EB%9F%AC-%ED%8A%B8%EB%9E%A9%EC%9C%BC%EB%A1%9C-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EB%B3%B4%ED%98%B8\" aria-label=\"124 deleteproperty와 여러 트랩으로 프로퍼티 보호 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2.4. deleteProperty와 여러 트랩으로 프로퍼티 보호</h3>\n<p>보통 프로그래밍에서 <code>_</code>가 프로퍼티 이름 앞에 붙으면, 이는 외부에서 접근할 수 없는 내부용 프로퍼티임을 암시한다. <code>deleteProperty</code>를 포함한 여러 트랩을 조합하여 해당 기능이 구현된 Proxy 객체를 만들 수 있다.</p>\n<ul>\n<li><code>target</code>: 원본 객체</li>\n<li><code>property</code>: 프로퍼티 네임</li>\n</ul>\n<pre><code class=\"language-js\">let user = {\n  name: 'John',\n  _password: '***',\n}\n\nuser = new Proxy(user, {\n  get(target, prop) {\n    if (prop.startsWith('_')) {\n      return '접근이 제한되어있습니다.'\n    }\n    let value = target[prop]\n    return typeof value === 'function' ? value.bind(target) : value\n  },\n  deleteProperty(target, prop) {\n    if (prop.startsWith('_')) {\n      return '접근이 제한되어있습니다.'\n    }\n    delete target[prop]\n    return true\n  },\n  ownKeys(target) {\n    return Object.keys(target).filter((key) => !key.startsWith('_'))\n  },\n})\n\nconsole.log(user._password) // 접근이 제한되어있습니다.\nconsole.log(delete user._password) // true\nconsole.log(user.keys()) //[ 'name' ]\n</code></pre>\n<h3 id=\"125-유의-사항\" style=\"position:relative;\"><a href=\"#125-%EC%9C%A0%EC%9D%98-%EC%82%AC%ED%95%AD\" aria-label=\"125 유의 사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2.5. 유의 사항</h3>\n<p>위 코드에서 <code>get</code> 트랩을 보면 최초 접근하는 프로퍼티가 함수일 경우에 <code>this</code>를 바인딩 했다. <code>this</code>에서 직감할 수 있듯이 결국 누가 함수를 호출하는지의 문제이다.</p>\n<pre><code class=\"language-js\">get(target, prop) {\n  // ...\n  let value = target[prop];\n  return (typeof value === 'function') ? value.bind(target) : value;\n}\n</code></pre>\n<p>만일 user 객체에 다음과 같은 <code>checkPassword</code>라는 메소드가 있다고 가정해자. <code>checkPassword</code>는 객체의 메소드이기 때문에 내부 변수에 문제없이 접근할 수 있어야 한다.</p>\n<pre><code class=\"language-js\">let user = {\n  // ...\n  checkPassword(value) {\n    return value === this._password // 이 this는 Proxy가 아닌, 원본 객체여야 한다.\n  },\n}\n</code></pre>\n<p>즉 아래 코드에서 <code>user</code>는 Proxy 객체이지만, 실제 <code>checkPassword</code>를 실행하는 녀석은 Proxy가 아닌 원본 객체여야 한다. 이것을 구현하기 위해 <code>get</code> 트랩에서 최초 접근 프로퍼티가 함수일 경우 바인딩 하는 것이다.</p>\n<pre><code class=\"language-js\">let user = {...}\nuser = new Proxy(user, {...})\nuser.checkPassword('password')  // user는 Proxy 객체지만, 실제 checkPassword를 호출은 원본 객체가 해야한다.\n</code></pre>\n<p>물론 메소드간 연관성이 복잡해져서, 애초에 <strong>원본 객체</strong>가 넘어가거나 <strong>Proxy가 여러번 덧대어진 객체</strong>가 넘어가면 불상사가 발생한다.</p>\n<h1 id=\"2-reflect\" style=\"position:relative;\"><a href=\"#2-reflect\" aria-label=\"2 reflect permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Reflect</h1>\n<p>Reflect는 <mark>Proxy의 모든 트랩에 대응하는 함수들을 가진 namespace</mark>이다. 단순한 namespace이기 때문에 생성자로 객체를 생성하지 않고 바로 사용한다. 정적 클래스라고 생각하면 더 직관적이겠다.</p>\n<pre><code class=\"language-js\">let user = {}\n\nReflect.set(user, 'name', 'John')\n</code></pre>\n<p>Proxy 트랩에 대응하는 모든 함수를 가지고 있다고 하지만, 특별한 기능이 구현되어 있지는 않다. 그런걸 왜 쓰는지는 아래에 정리했다.</p>\n<h2 id=\"21-proxy의-return-값\" style=\"position:relative;\"><a href=\"#21-proxy%EC%9D%98-return-%EA%B0%92\" aria-label=\"21 proxy의 return 값 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. Proxy의 return 값</h2>\n<blockquote>\n<p>So, return Reflect... provides a safe no-brainer to forward the operation and make sure we don’t forget anything related to that. [Ilya kantor, 모던 JavaScript 튜토리얼 저자]</p>\n</blockquote>\n<p>Proxy 트랩에 반환값을 작성해야 하는데, 늘 대응되는 객체 메소드와 인자를 쓰는 것은 어려운 일이다 (<code>get</code>하고 <code>set</code>밖에 안써서 어렵다고 느낄 일이 없지만...). 그럴 때 구글링하지 말고 그냥 <code>Reflect</code>에서 <strong>동일한 함수</strong>에 <strong>동일한 인자</strong>를 넣어 반환하면 된다.</p>\n<pre><code class=\"language-js\">let user = {\n  name: 'John',\n}\n\nuser = new Proxy(user, {\n  get(target, prop, receiver) {\n    console.log(`GET ${prop}`)\n    return Reflect.get(target, prop, receiver)\n  },\n  set(target, prop, val, receiver) {\n    console.log(`SET ${prop}=${val}`)\n    return Reflect.set(target, prop, val, receiver)\n  },\n})\n\nlet name = user.name // GET name\nuser.name = 'Pete' // \"SET name=Pete\n</code></pre>\n<h2 id=\"22-proxy-상속-객체-핸들링\" style=\"position:relative;\"><a href=\"#22-proxy-%EC%83%81%EC%86%8D-%EA%B0%9D%EC%B2%B4-%ED%95%B8%EB%93%A4%EB%A7%81\" aria-label=\"22 proxy 상속 객체 핸들링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2. Proxy 상속 객체 핸들링</h2>\n<p>또한 <strong>Proxy를 상속받은 객체</strong>가 마치 <strong>Proxy가 가장 밖에 둘러싼 것</strong>처럼 동작하게 만든다.</p>\n<p>다음과 같이 <code>_name</code> 프로퍼티에 대한 getter를 Proxy로 구현했다.</p>\n<pre><code class=\"language-js\">let user = {\n  _name: 'Guest',\n  get name() {\n    return this._name\n  },\n}\n\nlet userProxy = new Proxy(user, {\n  get(target, prop, receiver) {\n    return target[prop]\n  },\n})\n\nconsole.log(userProxy.name) // Guest\n</code></pre>\n<p>위에 정의한 <code>userProxy</code>를 상속 받고 <code>_name</code> 프로퍼티가 오버라이딩한 <code>admin</code>객체가 있다. 이 객체는 Proxy를 프로토타입으로 가지기 때문에 아래와 같이 Proxy가 새로 정의된 프로퍼티를 커버하지 못하는 것이 당연하다.</p>\n<pre><code class=\"language-js\">let admin = {\n  __proto__: userProxy,\n  _name: 'Admin',\n}\n\nalert(admin.name) // Guest\n</code></pre>\n<p>하지만 내가 Proxy를 상속받았을지라도, 결국에는 Proxy가 가장 바깥에서 동작하는 것처럼 보이고 싶을 때 <code>Reflect</code>를 쓰면 된다. 앞 서 Proxy 핸들러 메소드 중 몇개가 <code>receiver</code>를 인자로 받았다.</p>\n<p>바로 이 <code>receiver</code>에 Proxy를 상속받은 객체에 대한 정보가 있기 때문에, <code>Reflect</code>에 넘겨주면 내부적으로 잘 처리하여 원하는 기능이 구현된다.</p>\n<pre><code class=\"language-js\">let user = {\n  _name: 'Guest',\n  get name() {\n    return this._name\n  },\n}\n\nlet userProxy = new Proxy(user, {\n  get(target, prop, receiver) {\n    return Reflect.get(target, prop, receiver) // receiver = admin\n  },\n})\n\nlet admin = {\n  __proto__: userProxy,\n  _name: 'Admin',\n}\n\nconsole.log(admin.name) // Admin\n</code></pre>\n<h1 id=\"참조\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EC%A1%B0\" aria-label=\"참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참조</h1>\n<ul>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">MDN : \"Proxy\"</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect\">MDN : \"Reflect\"</a></li>\n<li><a href=\"https://ko.javascript.info/proxy\">JAVASCRIPT.INFO : \"Proxy와 Reflect\"</a></li>\n<li><a href=\"https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-Proxy-Reflect-%EA%B3%A0%EA%B8%89-%EA%B8%B0%EB%B2%95\">Inpa Dev : \"자바스크립트 Proxy &#x26; Reflect 고급 기법\"</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-proxy\">1. Proxy</a></p>\n<ul>\n<li>\n<p><a href=\"#11-proxy-%ED%8A%B8%EB%9E%A9-%EC%A2%85%EB%A5%98\">1.1. Proxy 트랩 종류</a></p>\n</li>\n<li>\n<p><a href=\"#12-%EA%B8%B0%EB%B3%B8-%ED%99%9C%EC%9A%A9-%EC%98%88%EC%A0%9C\">1.2. 기본 활용 예제</a></p>\n<ul>\n<li><a href=\"#121-get\">1.2.1. get</a></li>\n<li><a href=\"#122-set\">1.2.2. set</a></li>\n<li><a href=\"#123-has\">1.2.3. has</a></li>\n<li><a href=\"#124-deleteproperty%EC%99%80-%EC%97%AC%EB%9F%AC-%ED%8A%B8%EB%9E%A9%EC%9C%BC%EB%A1%9C-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EB%B3%B4%ED%98%B8\">1.2.4. deleteProperty와 여러 트랩으로 프로퍼티 보호</a></li>\n<li><a href=\"#125-%EC%9C%A0%EC%9D%98-%EC%82%AC%ED%95%AD\">1.2.5. 유의 사항</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-reflect\">2. Reflect</a></p>\n<ul>\n<li><a href=\"#21-proxy%EC%9D%98-return-%EA%B0%92\">2.1. Proxy의 return 값</a></li>\n<li><a href=\"#22-proxy-%EC%83%81%EC%86%8D-%EA%B0%9D%EC%B2%B4-%ED%95%B8%EB%93%A4%EB%A7%81\">2.2. Proxy 상속 객체 핸들링</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EC%A1%B0\">참조</a></p>\n</li>\n</ul>","frontmatter":{"title":"자바스크립트 Proxy & Reflect 객체","createdAt":"2024-03-08","updatedAt":"2024-03-08","tags":["JavaScript","자바스크립트","Proxy","프록시","Reflect"],"description":"자바스크립트의 Proxy와 Reflect 객체를 알아보자","reference":null}},"allMarkdownRemark":{"nodes":[{"id":"d213caa5-57cc-5e67-a96c-cfebe6f529f8","excerpt":"1. Intro 1.1. What is JavaScript? 1.2. The History of JavaScript 1.3. Write to HTML Script 1.4. When to Run JS 1.4.1. Synchronous execution…","parent":{"id":"1720b21e-2873-54b9-8fe5-5ec0e54d9d2e","name":"01_JavaScript_Basics","relativePath":"Language/JavaScript/01_JavaScript_Basics.md"},"frontmatter":{"title":"01. JavaScript Basics","createdAt":"2022-10-23","updatedAt":"2023-01-05"},"fields":{"slug":"/posts/Language/JavaScript/01_JavaScript_Basics/"}},{"id":"e1b04b22-c025-5266-a823-8a21c8214924","excerpt":"1. DOM 1.1. Document Object Model 1.2. Special DOM objects 1.3. Handling DOM 1.3.1. Select 1.3.2. Manipulation 2. Event 2.1. Event handler…","parent":{"id":"24abc79b-ec97-585b-8097-7a47a24aca42","name":"02_JavaScript_Advanced","relativePath":"Language/JavaScript/02_JavaScript_Advanced.md"},"frontmatter":{"title":"02. JavaScript DOM and this ","createdAt":"2022-10-24","updatedAt":"2023-01-02"},"fields":{"slug":"/posts/Language/JavaScript/02_JavaScript_Advanced/"}},{"id":"cad56ff3-d893-52b1-a35c-0e1fce4070ba","excerpt":"1. Synchronous and Asynchronous 1.1. Asynchronous JavaScript 1.2. JavaScript Runtime 2. Axios 2.1. The Structure of Axios 2.2. Promise 2.…","parent":{"id":"15ee5a55-2b53-5813-bdea-be1e3c51ae09","name":"03_JavaScript_Asynchronous","relativePath":"Language/JavaScript/03_JavaScript_Asynchronous.md"},"frontmatter":{"title":"03. JavaScript Async","createdAt":"2022-11-01","updatedAt":"2023-01-02"},"fields":{"slug":"/posts/Language/JavaScript/03_JavaScript_Asynchronous/"}},{"id":"0f51505a-6206-5a85-b28e-02b0dae340db","excerpt":"1. Promise 1.1. Promise(executor) 2. Aysnc & Await 2.1. async 2.2. await 2.3. try / catch 3. Example 3.1. Chaining 처리, Hard Code 3.1.…","parent":{"id":"3585fbfd-fa62-5290-a175-1bd09c1dfd3a","name":"Promise_Await","relativePath":"Language/JavaScript/Promise_Await.md"},"frontmatter":{"title":"Promise와 await를 활용하 JS 8가지 비동기 처리","createdAt":"2023-01-02","updatedAt":"2023-01-02"},"fields":{"slug":"/posts/Language/JavaScript/Promise_Await/"}},{"id":"b4de88cf-2fb7-533b-9cc7-ce8c17b8211a","excerpt":"이 글은 드림코딩: 자바스크립드 11 ~ 13 비동기 강의를 듣고 정리한 문서이다. 1. Callback 콜백 함수란, 다른 함수의 매개변수로 전달되어 전달된 함수 내부에서 실행될 수 있는 함수를 말한다. 1.…","parent":{"id":"f2176031-fe05-57f2-9438-3aa69da6a4f7","name":"Promise_Async_2","relativePath":"Language/JavaScript/Promise_Async_2.md"},"frontmatter":{"title":"JavaScript 비동기 처리 Promise & Async","createdAt":"2023-09-07","updatedAt":"2023-09-07"},"fields":{"slug":"/posts/Language/JavaScript/Promise_Async_2/"}},{"id":"f0396719-efaf-5d7c-8544-52108c97d3b3","excerpt":"1. JavaScript 모듈 1.1. 모듈의 부재 JavaScript는 과거 인터넷 브라우저 회사였던, Netscape의 Brendan Eich(브렌던 아이크)에 의해 만들어졌다. 처음에는 Mocha…","parent":{"id":"afba6128-4a8a-524a-a8fe-b7fc2e236d7e","name":"Modules","relativePath":"Language/JavaScript/Modules.md"},"frontmatter":{"title":"JavaScript 모듈 시스템 비교","createdAt":"2023-09-09","updatedAt":"2023-09-09"},"fields":{"slug":"/posts/Language/JavaScript/Modules/"}},{"id":"3c0103d9-947d-584e-b271-b2aa243f3f08","excerpt":"1. 번들러 1.1. 번들러란? 번들러는 여러 자바스크립트 모듈 간의 관계를 분석하여 하나의 자바스크립트 파일로 만드는 도구이다. 반드시 하나의 자바스크립트 파일일 필요는 없고, 원한면 몇 개로 나눌 수도 있다. 이를 코드 스프리팅(Code…","parent":{"id":"ce744717-0985-5344-94de-496d38113237","name":"Webpack_Rollup_Vite","relativePath":"Language/JavaScript/Webpack_Rollup_Vite.md"},"frontmatter":{"title":"Webpack vs Rollup vs Vite 비교 분석","createdAt":"2023-09-10","updatedAt":"2023-09-10"},"fields":{"slug":"/posts/Language/JavaScript/Webpack_Rollup_Vite/"}},{"id":"4d47e063-d4d4-5864-ade9-a8a2d0f1e051","excerpt":"10분 테코톡: 하루의 실행 컨텍스트 영상을 참조해서 작성한 글이다 우테코는 도대체 무슨 짓을 꾸미고 있는 것일까... 여기 테코톡은 매번 볼 때마다 놀랍다. 특히 이번 영상은 감탄마저 나올 정도다👍 1. 실행 컨텍스트 (Execute Context…","parent":{"id":"598fda13-e699-5500-a0d0-5bad07868743","name":"Execute_Context","relativePath":"Language/JavaScript/Execute_Context.md"},"frontmatter":{"title":"실행 컨텍스트로 이해하는 Hoisting, Scope, Closure","createdAt":"2023-09-22","updatedAt":"2023-09-22"},"fields":{"slug":"/posts/Language/JavaScript/Execute_Context/"}},{"id":"b58b9818-4c5e-5467-b86c-efe2f684e298","excerpt":"1. 핵심 내용 브라우저는 HTML, CSS, JS 등 렌더링에 필요한 리소스르르 요청하고 서버로부터 응답받는다. 브라우저 렌더링 엔진이 HTML과 CSS를 파싱하역 각각 DOM과 CSSOM…","parent":{"id":"42b699e3-ea21-552c-b603-8b9b032568f5","name":"Browser_Rendering","relativePath":"Language/JavaScript/Browser_Rendering.md"},"frontmatter":{"title":"브라우저 렌더링 과정","createdAt":"2023-09-23","updatedAt":"2023-09-23"},"fields":{"slug":"/posts/Language/JavaScript/Browser_Rendering/"}},{"id":"c0ad1c54-8714-5e5d-b1d2-7aa89b3d115d","excerpt":"1. this 란? this는 함수가 실행컨텍스트에서 참조하고 있는 객체이다. 따라서 모든 함수는 자신만의 this를 가지고 있다. 문제는 이 this…","parent":{"id":"bb3ac8ea-a2b4-5a78-8914-0bd7a6c5891c","name":"this","relativePath":"Language/JavaScript/this.md"},"frontmatter":{"title":"자바스크립트 this 정복하기","createdAt":"2023-09-24","updatedAt":"2023-09-24"},"fields":{"slug":"/posts/Language/JavaScript/this/"}},{"id":"61ce8ae2-05de-5484-9960-76b1d878106a","excerpt":"1. 생성자 함수 & new 키워드 new 키워드와 생성자 함수를 사용하면 손쉽게 객체를 찍어낼 수 있다. 자바스크립트 버전의 OOP라고 생각할 수 있다. 자바가 객체를 찍어내기 위해 class 키워드를 사용한다면, 자바스크립트는 생성자 함수와 new…","parent":{"id":"7dbfcf53-cb94-5255-aa1d-4181665d88dd","name":"new","relativePath":"Language/JavaScript/new.md"},"frontmatter":{"title":"자바스크립트 생성자 함수 & new 키워드","createdAt":"2023-10-11","updatedAt":"2023-10-11"},"fields":{"slug":"/posts/Language/JavaScript/new/"}},{"id":"722f2b6c-0335-5a25-94e3-44e6a96d9d17","excerpt":"1. 개요 자바스크립트는 프로토타입 기반의 객체 지향 언어이다. ES6부터 클래스형 문법이 도입되었다고 하지만, 이는 \"다른 객체 지향 언어처럼\" 사용하도록 도와주는 API…","parent":{"id":"43f9daad-bb94-5bfb-b40f-e16699d3d50e","name":"prototype","relativePath":"Language/JavaScript/prototype.md"},"frontmatter":{"title":"자바스크립트 Prototype 이해하기","createdAt":"2023-10-12","updatedAt":"2023-10-12"},"fields":{"slug":"/posts/Language/JavaScript/prototype/"}},{"id":"bc3cf8c8-9ffc-5759-8384-1081ab0862e2","excerpt":"1. 클래스란? 1.1. 정의 자바스크립트의 클래스를 흔히 문법적 설탕(synthetic sugar…","parent":{"id":"3c48b83c-3bf7-5dda-9fce-72c29b8107a4","name":"class","relativePath":"Language/JavaScript/class.md"},"frontmatter":{"title":"자바스크립트 ES6 class 문법","createdAt":"2023-10-17","updatedAt":"2023-10-17"},"fields":{"slug":"/posts/Language/JavaScript/class/"}},{"id":"129e1e6c-97e5-54fe-8f18-bdb6f91f4c7c","excerpt":"진짜 가볍게 작성하려고 했는데 이틀이 걸렸다. 자바스크립트의 모든 문제는 결국 this인 것 같다. 1. Proxy Proxy 객체는 자바스크립트 Object에 대한 기본적인 접근(set, get, define…","parent":{"id":"3e2529cd-00c5-57b8-a789-064c412598ec","name":"proxy","relativePath":"Language/JavaScript/proxy.md"},"frontmatter":{"title":"자바스크립트 Proxy & Reflect 객체","createdAt":"2024-03-08","updatedAt":"2024-03-08"},"fields":{"slug":"/posts/Language/JavaScript/proxy/"}}]}},"pageContext":{"pagePath":"/posts/Language/JavaScript/proxy/","siblingPostsPathRegex":"/^(?!.*README).*Language\\/JavaScript\\/.*$/","relativeDirectory":"JavaScript","id":"129e1e6c-97e5-54fe-8f18-bdb6f91f4c7c","parent":{"id":"3e2529cd-00c5-57b8-a789-064c412598ec","name":"proxy","relativePath":"Language/JavaScript/proxy.md"},"fields":{"slug":"/posts/Language/JavaScript/proxy/"}}},"staticQueryHashes":["24302420","4059933791"],"slicesMap":{}}