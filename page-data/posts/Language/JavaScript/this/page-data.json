{"componentChunkName":"component---src-templates-post-index-tsx","path":"/posts/Language/JavaScript/this/","result":{"data":{"markdownRemark":{"id":"c0ad1c54-8714-5e5d-b1d2-7aa89b3d115d","html":"<h1 id=\"1-this-란\" style=\"position:relative;\"><a href=\"#1-this-%EB%9E%80\" aria-label=\"1 this 란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. this 란?</h1>\n<p>this는 <strong>함수가 실행컨텍스트에서 참조하고 있는 객체</strong>이다. 따라서 모든 함수는 자신만의 this를 가지고 있다. 문제는 이 this가 <strong>호출되는 시점</strong>에 따라 다이나믹하게 결정된다는 것이다. 물론 아무렇게나 결정되는 것은 아니고 앞으로 설명하는 규칙들을 따른다.</p>\n<h1 id=\"2-기본-바인딩\" style=\"position:relative;\"><a href=\"#2-%EA%B8%B0%EB%B3%B8-%EB%B0%94%EC%9D%B8%EB%94%A9\" aria-label=\"2 기본 바인딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 기본 바인딩</h1>\n<p>함수 <strong>단독으로 실행 시</strong>, this는 <strong>전역객체</strong>를 가리킨다. 전역객체란 브라우저에서는 <code>window</code>이며, Node.js에서는 <code>global</code>을 말한다. 그런데 아주 사소한 차이가 있다.</p>\n<h2 id=\"21-browser\" style=\"position:relative;\"><a href=\"#21-browser\" aria-label=\"21 browser permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. Browser</h2>\n<ul>\n<li>\n<p><strong>비엄격모드</strong><br>\n비엄격모드에서는 <code>window</code> 객체가 그대로 출력된다.</p>\n<pre><code class=\"language-js\">const printThis = function () {\n  console.log(this)\n}\n\nprintThis() // Window\n</code></pre>\n</li>\n<li>\n<p><strong>엄격모드</strong><br>\n엄격모드에서는 <code>window</code> 객체 참조가 막히기 때문에 <code>undefined</code>가 출력된다.</p>\n<pre><code class=\"language-js\">'use strict'\n\nconst printThis = function () {\n  console.log(this)\n}\n\nprintThis() // undefined\n</code></pre>\n</li>\n</ul>\n<h2 id=\"32-nodejs\" style=\"position:relative;\"><a href=\"#32-nodejs\" aria-label=\"32 nodejs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2. Node.js</h2>\n<ul>\n<li>\n<p><strong>함수코드</strong><br>\n함수 내부에서 가리키는 this가 단독 실행되었을 때, <code>global</code>객체가 출력된다.</p>\n<pre><code class=\"language-js\">const printThis = function () {\n  console.log(this)\n}\n\nprintThis() // Object [global]\n</code></pre>\n</li>\n<li>\n<p><strong>전역코드</strong><br>\n전역 코드에서 this를 바로 확인할 경우, 빈 객체(<code>{}</code>)가 출력되는데 이는 파일의 모듈 객체(<code>module.exports</code>)를 가리킨다.</p>\n<pre><code class=\"language-js\">console.log(this) // {}\nconsole.log(this === module.exports) // True\n</code></pre>\n</li>\n</ul>\n<h1 id=\"3-암시적-바인딩\" style=\"position:relative;\"><a href=\"#3-%EC%95%94%EC%8B%9C%EC%A0%81-%EB%B0%94%EC%9D%B8%EB%94%A9\" aria-label=\"3 암시적 바인딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 암시적 바인딩</h1>\n<p><strong>객체의 메소드로 함수를 실행</strong>할 경우, this는 <strong>함수를 호출한 객체</strong>를 가리킨다. 즉 '.'앞의 객체를 가리키는 것이다.</p>\n<pre><code class=\"language-js\">const obj = {\n  name: 'Hi',\n  printThis() {\n    console.log(this)\n  },\n}\n\nobj.printThis() // { name: 'Hi', printThis: [Function: printThis] }\n</code></pre>\n<p>그러나 메소드를 <strong>다른 변수에 할당</strong>하거나, <strong>콜백함수 인자</strong>로 넘겨주게 되면 단독실행과 동일하게 동작한다. 함수가 참조타입 임에도 this에 대한 정보는 전달되지 않기 때문이다.</p>\n<pre><code class=\"language-js\">const obj = {\n  name: 'Hi',\n  printThis() {\n    console.log(this)\n  },\n}\n\nconst pT = obj.printThis\npT() // Object [global]\n</code></pre>\n<pre><code class=\"language-js\">const obj = {\n  name: 'Hi',\n  printThis() {\n    console.log(this)\n  },\n}\n\nconst callbackThis = function (callback) {\n  callback()\n}\n\ncallbackThis(obj.printThis) // Object [global]\n</code></pre>\n<h1 id=\"4-명시적-바인딩\" style=\"position:relative;\"><a href=\"#4-%EB%AA%85%EC%8B%9C%EC%A0%81-%EB%B0%94%EC%9D%B8%EB%94%A9\" aria-label=\"4 명시적 바인딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 명시적 바인딩</h1>\n<p>명시적 바인딩을 통해 함수의 this가 <strong>항상 특정 객체를 바라보도록</strong> 지정할 수 있다. <code>bind</code>와 <code>apply</code> 두가지 메소드로 구현된다.</p>\n<ul>\n<li>\n<p><strong>bind(thisArg, arg1, arg2, ...)</strong><br>\n<code>bind</code>는 첫번째 인자로 바인딩할 객체를 받고, 이어서 <strong>추가 인자를 개별 전달</strong>한다. 또한 this가 <strong>바인딩된 콜백함수를 반환</strong>한다.</p>\n<pre><code class=\"language-js\">const obj = {\n  printThis(...args) {\n    console.log(this, args)\n  },\n}\n\nconst bindObj = {\n  name: 'Hello',\n}\n\nconst bindPrintThis = obj.printThis.bind(bindObj, 1, 2)\nbindPrintThis() // { name: 'Hello' } [ 1, 2 ]\n</code></pre>\n</li>\n<li>\n<p><strong>apply(thisArg, argsArray)</strong><br>\n<code>apply</code>는 첫번째 인자로 바인딩할 객체를 받고, 이어서 <strong>추가 인자를 배열로 묶음 전달</strong>한다. 또한 this가 <strong>바인딩된 함수를 즉시 실행</strong>한다.</p>\n<pre><code class=\"language-js\">const obj = {\n  printThis(...args) {\n    console.log(this, args)\n  },\n}\n\nconst bindObj = {\n  name: 'Hello',\n}\n\nobj.printThis.apply(bindObj, [1, 2]) // { name: 'Hello' } [ 1, 2 ]\n</code></pre>\n</li>\n</ul>\n<h2 id=\"41-바인딩-중첩\" style=\"position:relative;\"><a href=\"#41-%EB%B0%94%EC%9D%B8%EB%94%A9-%EC%A4%91%EC%B2%A9\" aria-label=\"41 바인딩 중첩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.1. 바인딩 중첩</h2>\n<ul>\n<li>\n<p><strong>bind(thisArg, arg1, arg2, ...)</strong><br>\n<code>bind</code>는 두번째 이후 바인딩을 무시하고, 인자는 계속해서 추가한다.</p>\n<pre><code class=\"language-js\">const obj = {\n  printThis(...args) {\n    console.log(this, args)\n  },\n}\n\nconst firstBindObj = {\n  name: 'Hello',\n}\n\nconst secondBindObj = {\n  name: 'Hi',\n}\n\nconst firstBindPrintThis = obj.printThis.bind(firstBindObj, 1, 2)\nconst secondBindPrintThis = firstBindPrintThis.bind(secondBindObj, 3, 4)\nfirstBindPrintThis() // { name: 'Hello' } [ 1, 2 ]\nsecondBindPrintThis() // { name: 'Hello' } [ 1, 2, 3, 4 ]\n</code></pre>\n</li>\n<li>\n<p><strong>apply(thisArg, argsArray)</strong><br>\n<code>apply</code>는 모든 바인딩이 독립적이다.</p>\n<pre><code class=\"language-js\">const obj = {\n  printThis(...args) {\n    console.log(this, args)\n  },\n}\n\nconst firstBindObj = {\n  name: 'Hello',\n}\n\nconst secondBindObj = {\n  name: 'Hi',\n}\n\nobj.printThis.apply(firstBindObj, [1, 2]) // { name: 'Hello' } [ 1, 2 ]\nobj.printThis.apply(secondBindObj, [3, 4]) // { name: 'Hi' } [ 3, 4 ]\n</code></pre>\n</li>\n</ul>\n<h1 id=\"5-화살표-함수\" style=\"position:relative;\"><a href=\"#5-%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98\" aria-label=\"5 화살표 함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 화살표 함수</h1>\n<p>화살표 함수를 사용할 경우, this는 <strong>렉시컬 스코프를 기준으로 상위 스코프의 this</strong>를 가리킨다. 즉 화살표 함수는 this를 정적 스코프로 묶어준다. 화살표 함수로 this를 직관적으로 사용할 수 있지만, 객체 선언과 이벤트 리스너 등록에서 <strong>사용에 주의가 필요</strong>하다.</p>\n<pre><code class=\"language-js\">const obj = {\n  name: 'Hi',\n  printThis() {\n    setTimeout(() => {\n      console.log(this)\n    }, 1000)\n  },\n}\n\nobj.printThis()\n</code></pre>\n<h2 id=\"51-객체-메소드-선언\" style=\"position:relative;\"><a href=\"#51-%EA%B0%9D%EC%B2%B4-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%84%A0%EC%96%B8\" aria-label=\"51 객체 메소드 선언 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5.1. 객체 메소드 선언</h2>\n<p>일번적으로 객체 메소드 안의 this는 <strong>메소드가 포함된 객체를 가리키길 희망</strong>할 것이다. 그러나 메소드를 화살표함수로 선언하면, 렉시컬 스코프에 따라 객체 상위 스코프의 this를 물려받는다.</p>\n<pre><code class=\"language-js\">const obj = {\n  printThis: () => {\n    console.log(this)\n  },\n}\n\nobj.printThis() // {}\n</code></pre>\n<h2 id=\"52-이벤트-리스너\" style=\"position:relative;\"><a href=\"#52-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A6%AC%EC%8A%A4%EB%84%88\" aria-label=\"52 이벤트 리스너 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5.2. 이벤트 리스너</h2>\n<p><code>addEventListener</code>에 등록된 콜백함수는 원래 <strong>함수가 등록된 HTML요소를 참조</strong>한다.</p>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en\">\n  &#x3C;head>\n    &#x3C;meta charset=\"UTF-8\" />\n    &#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    &#x3C;title>Document&#x3C;/title>\n    &#x3C;script defer src=\"./test.mjs\">&#x3C;/script>\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;button>클릭&#x3C;/button>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<pre><code class=\"language-js\">// test.mjs\nconst button = document.getElementsByTagName('button')[0]\n\nbutton.addEventListener('click', function () {\n  console.log(this) // &#x3C;button>클릭&#x3C;/button>\n})\n</code></pre>\n<p>그러나 콜백함수를 화살표 함수로 넘겨줄 경우 <strong>Window 전역 객체</strong>를 가리킨다.</p>\n<pre><code class=\"language-js\">// test.mjs\nconst button = document.getElementsByTagName('button')[0]\n\nbutton.addEventListener('click', () => {\n  console.log(this) // Window\n})\n</code></pre>\n<h1 id=\"참고-자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0-%EC%9E%90%EB%A3%8C\" aria-label=\"참고 자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고 자료</h1>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=7RiMu2DQrb4\">10분 테코톡: 브콜의 This</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=GteV4zfqPIk\">짐코딩: 자바스크립트 this란 무엇인가?</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\">MDN: this</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind\">MDN: Function.prototype.bind()</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\">MDN: Function.prototype.apply()</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-this-%EB%9E%80\">1. this 란?</a></p>\n</li>\n<li>\n<p><a href=\"#2-%EA%B8%B0%EB%B3%B8-%EB%B0%94%EC%9D%B8%EB%94%A9\">2. 기본 바인딩</a></p>\n<ul>\n<li><a href=\"#21-browser\">2.1. Browser</a></li>\n<li><a href=\"#32-nodejs\">3.2. Node.js</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-%EC%95%94%EC%8B%9C%EC%A0%81-%EB%B0%94%EC%9D%B8%EB%94%A9\">3. 암시적 바인딩</a></p>\n</li>\n<li>\n<p><a href=\"#4-%EB%AA%85%EC%8B%9C%EC%A0%81-%EB%B0%94%EC%9D%B8%EB%94%A9\">4. 명시적 바인딩</a></p>\n<ul>\n<li><a href=\"#41-%EB%B0%94%EC%9D%B8%EB%94%A9-%EC%A4%91%EC%B2%A9\">4.1. 바인딩 중첩</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#5-%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98\">5. 화살표 함수</a></p>\n<ul>\n<li><a href=\"#51-%EA%B0%9D%EC%B2%B4-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%84%A0%EC%96%B8\">5.1. 객체 메소드 선언</a></li>\n<li><a href=\"#52-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A6%AC%EC%8A%A4%EB%84%88\">5.2. 이벤트 리스너</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EA%B3%A0-%EC%9E%90%EB%A3%8C\">참고 자료</a></p>\n</li>\n</ul>","frontmatter":{"title":"자바스크립트 this 정복하기","createdAt":"2023-09-24","updatedAt":"2023-09-24","tags":["this","bind","apply","new","화살표 함수","바인딩"],"description":"자바스크립트 this의 동작원리","reference":null}},"allMarkdownRemark":{"nodes":[{"id":"d213caa5-57cc-5e67-a96c-cfebe6f529f8","excerpt":"1. Intro 1.1. What is JavaScript? 1.2. The History of JavaScript 1.3. Write to HTML Script 1.4. When to Run JS 1.4.1. Synchronous execution…","parent":{"id":"1720b21e-2873-54b9-8fe5-5ec0e54d9d2e","name":"01_JavaScript_Basics","relativePath":"Language/JavaScript/01_JavaScript_Basics.md"},"frontmatter":{"title":"01. JavaScript Basics","createdAt":"2022-10-23","updatedAt":"2023-01-05"},"fields":{"slug":"/posts/Language/JavaScript/01_JavaScript_Basics/"}},{"id":"e1b04b22-c025-5266-a823-8a21c8214924","excerpt":"1. DOM 1.1. Document Object Model 1.2. Special DOM objects 1.3. Handling DOM 1.3.1. Select 1.3.2. Manipulation 2. Event 2.1. Event handler…","parent":{"id":"24abc79b-ec97-585b-8097-7a47a24aca42","name":"02_JavaScript_Advanced","relativePath":"Language/JavaScript/02_JavaScript_Advanced.md"},"frontmatter":{"title":"02. JavaScript DOM and this ","createdAt":"2022-10-24","updatedAt":"2023-01-02"},"fields":{"slug":"/posts/Language/JavaScript/02_JavaScript_Advanced/"}},{"id":"cad56ff3-d893-52b1-a35c-0e1fce4070ba","excerpt":"1. Synchronous and Asynchronous 1.1. Asynchronous JavaScript 1.2. JavaScript Runtime 2. Axios 2.1. The Structure of Axios 2.2. Promise 2.…","parent":{"id":"15ee5a55-2b53-5813-bdea-be1e3c51ae09","name":"03_JavaScript_Asynchronous","relativePath":"Language/JavaScript/03_JavaScript_Asynchronous.md"},"frontmatter":{"title":"03. JavaScript Async","createdAt":"2022-11-01","updatedAt":"2023-01-02"},"fields":{"slug":"/posts/Language/JavaScript/03_JavaScript_Asynchronous/"}},{"id":"0f51505a-6206-5a85-b28e-02b0dae340db","excerpt":"1. Promise 1.1. Promise(executor) 2. Aysnc & Await 2.1. async 2.2. await 2.3. try / catch 3. Example 3.1. Chaining 처리, Hard Code 3.1.…","parent":{"id":"3585fbfd-fa62-5290-a175-1bd09c1dfd3a","name":"Promise_Await","relativePath":"Language/JavaScript/Promise_Await.md"},"frontmatter":{"title":"Promise와 await를 활용하 JS 8가지 비동기 처리","createdAt":"2023-01-02","updatedAt":"2023-01-02"},"fields":{"slug":"/posts/Language/JavaScript/Promise_Await/"}},{"id":"b4de88cf-2fb7-533b-9cc7-ce8c17b8211a","excerpt":"이 글은 드림코딩: 자바스크립드 11 ~ 13 비동기 강의를 듣고 정리한 문서이다. 1. Callback 콜백 함수란, 다른 함수의 매개변수로 전달되어 전달된 함수 내부에서 실행될 수 있는 함수를 말한다. 1.…","parent":{"id":"f2176031-fe05-57f2-9438-3aa69da6a4f7","name":"Promise_Async_2","relativePath":"Language/JavaScript/Promise_Async_2.md"},"frontmatter":{"title":"JavaScript 비동기 처리 Promise & Async","createdAt":"2023-09-07","updatedAt":"2023-09-07"},"fields":{"slug":"/posts/Language/JavaScript/Promise_Async_2/"}},{"id":"f0396719-efaf-5d7c-8544-52108c97d3b3","excerpt":"1. JavaScript 모듈 1.1. 모듈의 부재 JavaScript는 과거 인터넷 브라우저 회사였던, Netscape의 Brendan Eich(브렌던 아이크)에 의해 만들어졌다. 처음에는 Mocha…","parent":{"id":"afba6128-4a8a-524a-a8fe-b7fc2e236d7e","name":"Modules","relativePath":"Language/JavaScript/Modules.md"},"frontmatter":{"title":"JavaScript 모듈 시스템 비교","createdAt":"2023-09-09","updatedAt":"2023-09-09"},"fields":{"slug":"/posts/Language/JavaScript/Modules/"}},{"id":"3c0103d9-947d-584e-b271-b2aa243f3f08","excerpt":"1. 번들러 1.1. 번들러란? 번들러는 여러 자바스크립트 모듈 간의 관계를 분석하여 하나의 자바스크립트 파일로 만드는 도구이다. 반드시 하나의 자바스크립트 파일일 필요는 없고, 원한면 몇 개로 나눌 수도 있다. 이를 코드 스프리팅(Code…","parent":{"id":"ce744717-0985-5344-94de-496d38113237","name":"Webpack_Rollup_Vite","relativePath":"Language/JavaScript/Webpack_Rollup_Vite.md"},"frontmatter":{"title":"Webpack vs Rollup vs Vite 비교 분석","createdAt":"2023-09-10","updatedAt":"2023-09-10"},"fields":{"slug":"/posts/Language/JavaScript/Webpack_Rollup_Vite/"}},{"id":"4d47e063-d4d4-5864-ade9-a8a2d0f1e051","excerpt":"10분 테코톡: 하루의 실행 컨텍스트 영상을 참조해서 작성한 글이다 우테코는 도대체 무슨 짓을 꾸미고 있는 것일까... 여기 테코톡은 매번 볼 때마다 놀랍다. 특히 이번 영상은 감탄마저 나올 정도다👍 1. 실행 컨텍스트 (Execute Context…","parent":{"id":"598fda13-e699-5500-a0d0-5bad07868743","name":"Execute_Context","relativePath":"Language/JavaScript/Execute_Context.md"},"frontmatter":{"title":"실행 컨텍스트로 이해하는 Hoisting, Scope, Closure","createdAt":"2023-09-22","updatedAt":"2023-09-22"},"fields":{"slug":"/posts/Language/JavaScript/Execute_Context/"}},{"id":"b58b9818-4c5e-5467-b86c-efe2f684e298","excerpt":"1. 핵심 내용 브라우저는 HTML, CSS, JS 등 렌더링에 필요한 리소스르르 요청하고 서버로부터 응답받는다. 브라우저 렌더링 엔진이 HTML과 CSS를 파싱하역 각각 DOM과 CSSOM…","parent":{"id":"42b699e3-ea21-552c-b603-8b9b032568f5","name":"Browser_Rendering","relativePath":"Language/JavaScript/Browser_Rendering.md"},"frontmatter":{"title":"브라우저 렌더링 과정","createdAt":"2023-09-23","updatedAt":"2023-09-23"},"fields":{"slug":"/posts/Language/JavaScript/Browser_Rendering/"}},{"id":"c0ad1c54-8714-5e5d-b1d2-7aa89b3d115d","excerpt":"1. this 란? this는 함수가 실행컨텍스트에서 참조하고 있는 객체이다. 따라서 모든 함수는 자신만의 this를 가지고 있다. 문제는 이 this…","parent":{"id":"bb3ac8ea-a2b4-5a78-8914-0bd7a6c5891c","name":"this","relativePath":"Language/JavaScript/this.md"},"frontmatter":{"title":"자바스크립트 this 정복하기","createdAt":"2023-09-24","updatedAt":"2023-09-24"},"fields":{"slug":"/posts/Language/JavaScript/this/"}},{"id":"61ce8ae2-05de-5484-9960-76b1d878106a","excerpt":"1. 생성자 함수 & new 키워드 new 키워드와 생성자 함수를 사용하면 손쉽게 객체를 찍어낼 수 있다. 자바스크립트 버전의 OOP라고 생각할 수 있다. 자바가 객체를 찍어내기 위해 class 키워드를 사용한다면, 자바스크립트는 생성자 함수와 new…","parent":{"id":"7dbfcf53-cb94-5255-aa1d-4181665d88dd","name":"new","relativePath":"Language/JavaScript/new.md"},"frontmatter":{"title":"자바스크립트 생성자 함수 & new 키워드","createdAt":"2023-10-11","updatedAt":"2023-10-11"},"fields":{"slug":"/posts/Language/JavaScript/new/"}},{"id":"722f2b6c-0335-5a25-94e3-44e6a96d9d17","excerpt":"1. 개요 자바스크립트는 프로토타입 기반의 객체 지향 언어이다. ES6부터 클래스형 문법이 도입되었다고 하지만, 이는 \"다른 객체 지향 언어처럼\" 사용하도록 도와주는 API…","parent":{"id":"43f9daad-bb94-5bfb-b40f-e16699d3d50e","name":"prototype","relativePath":"Language/JavaScript/prototype.md"},"frontmatter":{"title":"자바스크립트 Prototype 이해하기","createdAt":"2023-10-12","updatedAt":"2023-10-12"},"fields":{"slug":"/posts/Language/JavaScript/prototype/"}},{"id":"bc3cf8c8-9ffc-5759-8384-1081ab0862e2","excerpt":"1. 클래스란? 1.1. 정의 자바스크립트의 클래스를 흔히 문법적 설탕(synthetic sugar…","parent":{"id":"3c48b83c-3bf7-5dda-9fce-72c29b8107a4","name":"class","relativePath":"Language/JavaScript/class.md"},"frontmatter":{"title":"자바스크립트 ES6 class 문법","createdAt":"2023-10-17","updatedAt":"2023-10-17"},"fields":{"slug":"/posts/Language/JavaScript/class/"}}]}},"pageContext":{"pagePath":"/posts/Language/JavaScript/this/","siblingPostsPathRegex":"/^(?!.*README).*Language\\/JavaScript\\/.*$/","relativeDirectory":"JavaScript","id":"c0ad1c54-8714-5e5d-b1d2-7aa89b3d115d","parent":{"id":"bb3ac8ea-a2b4-5a78-8914-0bd7a6c5891c","name":"this","relativePath":"Language/JavaScript/this.md"},"fields":{"slug":"/posts/Language/JavaScript/this/"}}},"staticQueryHashes":["24302420","4059933791"],"slicesMap":{}}