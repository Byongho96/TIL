{"componentChunkName":"component---src-templates-post-index-tsx","path":"/posts/Language/JavaScript/Promise_Async_2/","result":{"data":{"markdownRemark":{"id":"b4de88cf-2fb7-533b-9cc7-ce8c17b8211a","html":"<blockquote>\n<p>이 글은 <a href=\"https://www.youtube.com/@dream-coding\">드림코딩: 자바스크립드 11 ~ 13 비동기 강의</a>를 듣고 정리한 문서이다.</p>\n</blockquote>\n<h1 id=\"1-callback\" style=\"position:relative;\"><a href=\"#1-callback\" aria-label=\"1 callback permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Callback</h1>\n<p>콜백 함수란, <strong>다른 함수의 매개변수로 전달되어 전달된 함수 내부에서 실행될 수 있는 함수</strong>를 말한다.</p>\n<h2 id=\"11-동기적-콜백\" style=\"position:relative;\"><a href=\"#11-%EB%8F%99%EA%B8%B0%EC%A0%81-%EC%BD%9C%EB%B0%B1\" aria-label=\"11 동기적 콜백 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1. 동기적 콜백</h2>\n<p>전달된 콜백함수가 동기적으로 바로 실행되는 것을 말한다.</p>\n<pre><code class=\"language-js\">function runImmediately(cb) {\n  cb()\n}\n\nconsole.log(1)\nrunImmediately(() => console.log(2))\nconsole.log(3)\n\n// 1\n// 2\n// 3\n</code></pre>\n<h2 id=\"12-비동기적-콜백\" style=\"position:relative;\"><a href=\"#12-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%A0%81-%EC%BD%9C%EB%B0%B1\" aria-label=\"12 비동기적 콜백 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2. 비동기적 콜백</h2>\n<p>전달된 콜백함수가 시간차를 두고 비동기적으로 실행되는 것을 말한다. 아래는 <code>setTimeout</code>을 썼지만, 보통 프론트에서는 AJAX 요청에 의한 비동기 실행이 더 빈번하다.</p>\n<pre><code class=\"language-js\">function runWithDelay(cb, timeout) {\n  setTimeout(cb, timebout)\n}\n\nconsole.log(1)\nrunWithDelay(() => console.log(2), 1000)\nconsole.log(3)\n\n// 1\n// 3\n// 2\n</code></pre>\n<h2 id=\"13-비동기-api-코드-예시\" style=\"position:relative;\"><a href=\"#13-%EB%B9%84%EB%8F%99%EA%B8%B0-api-%EC%BD%94%EB%93%9C-%EC%98%88%EC%8B%9C\" aria-label=\"13 비동기 api 코드 예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.3. 비동기 api 코드 예시</h2>\n<p>실제 AJAX 통신을 구현하는 대신, 임의로 3초 이후에 콜백함수를 실행시키도록 설계했다.</p>\n<pre><code class=\"language-js\">class Api {\n  loginUser(id, password, onSuccess, onError) {\n    setTimeout(() => {\n      if (id === 'user' &#x26;&#x26; password === '1q2w3e4r!') {\n        onSuccess(id)\n      } else {\n        onError(new Error('not found'))\n      }\n    }, 3000)\n  }\n}\n\nApi.loginUSer(\n  id,\n  password,\n  (res) => console.log(res),\n  (error) => console.log(err)\n)\n</code></pre>\n<h1 id=\"2-promise\" style=\"position:relative;\"><a href=\"#2-promise\" aria-label=\"2 promise permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Promise</h1>\n<p>Promise는 <strong>비동기 작업의 대기, 완료, 실패를 나타내는 객체</strong>이다. 또한 체이닝을 통해 작업의 완료/실패에 따라 실행할 콜백함수를 가독성 있게 작성할 수 있다.</p>\n<h2 id=\"21-promise-producer\" style=\"position:relative;\"><a href=\"#21-promise-producer\" aria-label=\"21 promise producer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. Promise Producer</h2>\n<p>Promise 객체는 생성 시에, <code>executor</code>라는 콜백 함수를 전달해줘야 한다. <code>executor</code>는 생성자에 전달 된 이후 <strong>바로 실행되는 함수</strong>이며, 아래와 같이 <strong>두 개의 콜백함수를 인자</strong>로 받는다.</p>\n<pre><code class=\"language-ts\">// 두 개의 콜백 함수를 인자로 받는다\nexecutor: (resolve, reject) => void\n\n// 동작 시에 promise를 fulfilled 상태로 만들며, 다음 then 체이닝에 value를 전달한다.\nresolve: (value?: any) => void\n\n// 동작 시에 promise를 rejected 상태로 만들며, 다음 catch 체이닝에 reason을 전달한다.\nreject: (reason?: any) => void\n</code></pre>\n<pre><code class=\"language-js\">const promise = new Promise((resolve, reject) => {\n  console.log('run executor')\n  setTimeout(() => {\n    resolve('success')\n    // reject(new Error('no network'))\n  }, 1000)\n})\n</code></pre>\n<h2 id=\"22-promise-consumer\" style=\"position:relative;\"><a href=\"#22-promise-consumer\" aria-label=\"22 promise consumer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2. Promise Consumer</h2>\n<p>체이닝을 이용하면, Promise의 상태에 따라 <strong>어떤 콜백함수를 이어 실행할 지</strong> 가독성 있게 작성할 수 있다.</p>\n<ul>\n<li><strong>then</strong>\n<ul>\n<li>바로 앞 선 Promise가 성공(fulfilled) 상태일 때 실행된다.</li>\n</ul>\n</li>\n<li><strong>catch</strong>\n<ul>\n<li>앞 선 Promise중 하나라도 실패(rejected) 상태일 때 실행된다.</li>\n</ul>\n</li>\n<li><strong>finally</strong>\n<ul>\n<li>Promise상태에 관련없이 마지막에 항상 실행된다.</li>\n</ul>\n</li>\n</ul>\n<p>위의 모든 메소드들은 <strong>또 다시 Promise를 반환</strong>하기 때문에, 아래 코드처럼 연달아 작성할 수 있다. 따라서 이를 프로미스 체이닝이라고 일컫는다.</p>\n<pre><code class=\"language-js\">promise\n  .then((value) => {\n    console.log(value)\n  })\n  .catch((error) => {\n    console.log(error)\n  })\n  .finally(() => {\n    console.log('finally')\n  })\n</code></pre>\n<h2 id=\"23-에러-핸들링\" style=\"position:relative;\"><a href=\"#23-%EC%97%90%EB%9F%AC-%ED%95%B8%EB%93%A4%EB%A7%81\" aria-label=\"23 에러 핸들링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3. 에러 핸들링</h2>\n<p>먼저 정상 동작하는 코드는 다음과 같다.</p>\n<pre><code class=\"language-js\">const getHen = () => {\n  new Promise((resolve, reject) => {\n    setTimeout(() => resolve('🐔'), 1000)\n  })\n}\nconst getEgg = (hen) => {\n  new Promise((resolve, reject) => {\n    setTimeout(() => resolve(`${hen} => 🥚`), 1000)\n  })\n}\nconst getCook = (egg) => {\n  new Promise((resolve, reject) => {\n    setTimeout(() => resolve(`${egg} => 🍳`), 1000)\n  })\n}\n\ngetHen()\n  .then((hen) => getEgg(hen))\n  .then((egg) => getCook(egg))\n  .then((meal) => console.log(meal))\n\n// 🐔 => 🥚 => 🍳\n</code></pre>\n<p>두번째 <code>getEgg</code>에서 임의로 에러를 발생시켰는데, 이를 잡은 <code>catch</code>문이 <strong>return 문으로 정상적인 값을 반환</strong>하면, 이어서 <code>then</code>문이 정상적으로 동작할 수 있다.</p>\n<pre><code class=\"language-js\">const getHen = () => {\n  new Promise((resolve, reject) => {\n    setTimeout(() => resolve('🐔'), 1000)\n  })\n}\nconst getEgg = (hen) => {\n  new Promise((resolve, reject) => {\n    setTimeout(() => reject(new Error(`error! ${hen} => 🥚`)), 1000)\n  })\n}\nconst getCook = (egg) => {\n  new Promise((resolve, reject) => {\n    setTimeout(() => resolve(`${egg} => 🍳`), 1000)\n  })\n}\n\ngetHen()\n  .then((hen) => getEgg(hen))\n  .catch((error) => {\n    return '🍞'\n  })\n  .then((egg) => getCook(egg))\n  .then((meal) => console.log(meal))\n\n// 🍞 => 🍳\n</code></pre>\n<h2 id=\"24-비동기-api-코드-예시\" style=\"position:relative;\"><a href=\"#24-%EB%B9%84%EB%8F%99%EA%B8%B0-api-%EC%BD%94%EB%93%9C-%EC%98%88%EC%8B%9C\" aria-label=\"24 비동기 api 코드 예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.4. 비동기 api 코드 예시</h2>\n<p>위의 <a href=\"#13-api-%EC%98%88%EC%8B%9C\">[1.3. 비동기 api 코드 예시]</a> 항목에서 콜백함수로 작성되었던 코드를 Promise를 이용해서 업데이트했다.</p>\n<pre><code class=\"language-js\">class Api {\n  loginUser(id, password) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        if (id === 'user' &#x26;&#x26; password === '1q2w3e4r!') {\n          resolve(id)\n        } else {\n          reject(new Error('not found'))\n        }\n      }, 1000)\n    })\n  }\n}\n\nApi.loginUSer(id, password)\n  .then((res) => console.log(res))\n  .catch((err) => console.log(err))\n</code></pre>\n<h1 id=\"3-async--await\" style=\"position:relative;\"><a href=\"#3-async--await\" aria-label=\"3 async  await permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. async / await</h1>\n<p>async와 await는 문법적 설탕(syntatic sugar)로써, <strong>Promise의 생성과 체이닝을 더 쉽게 구현</strong>하도록 도와준다.</p>\n<h2 id=\"21-async\" style=\"position:relative;\"><a href=\"#21-async\" aria-label=\"21 async permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. async</h2>\n<p><code>async</code>를 이용하여 함수를 선언하면, <strong>해당 함수는 Promise 객체로 반환</strong>된다.><code>return</code>문으로 <code>resolve</code> 콜백함수를 대체할 수 있고, <code>throw</code>문으로 <code>reject</code> 콜백함수를 대체할 수 있다.</p>\n<pre><code class=\"language-js\">async function fetchUser() {\n  return 'user'\n}\n\nconst user = fetchUser()\nconsole.log(user)\nuser.then(console.log)\n\n// Promise\n// user\n</code></pre>\n<h2 id=\"22-await\" style=\"position:relative;\"><a href=\"#22-await\" aria-label=\"22 await permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2. await</h2>\n<p><code>await</code>키워드는 <code>async</code>로 선언된 함수 내부에서만 사용 가능하다. 비동기 함수가 평가될 때까지 뒤의 코드를 지연시킨다. <strong>Promsie 객체의 <code>then</code> 메소드처럼 동작</strong>한다.</p>\n<pre><code class=\"language-js\">function delay(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms))\n}\n\nasync function getBanana() {\n  await delay(3000)\n  return '🍌'\n}\n\nfunction getBanana() {\n  return delay(3000).then(() => '🍌')\n}\n</code></pre>\n<h2 id=\"23-에러-핸들링-1\" style=\"position:relative;\"><a href=\"#23-%EC%97%90%EB%9F%AC-%ED%95%B8%EB%93%A4%EB%A7%81-1\" aria-label=\"23 에러 핸들링 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3. 에러 핸들링</h2>\n<p><code>async</code> 함수는 <code>try... catch...</code>문을 통해 에러를 핸들링 할 수 있다.</p>\n<pre><code class=\"language-js\">function delay(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms))\n}\n\nasync function getApple() {\n  await delay(3000)\n  return '🍎'\n}\n\nasync function getBanana() {\n  await delay(3000)\n  return '🍌'\n}\n\nasync function pickFruits() {\n  try {\n    const apple = await getApple()\n    const banana = await getBanana()\n  } catch (error) {\n    throw error\n  }\n  return `${apple} + ${banana}`\n}\n</code></pre>\n<h1 id=\"4-promise-vs-async\" style=\"position:relative;\"><a href=\"#4-promise-vs-async\" aria-label=\"4 promise vs async permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Promise vs async</h1>\n<p>언뜻 보면 async가 Promise보다 항상 더 나을 것 같다. 하지만 Promise를 적절하게 활용하면, async보다 성능 상의 이점을 얻을 수 있다.</p>\n<pre><code class=\"language-js\">function delay(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms))\n}\n\nasync function getApple() {\n  await delay(3000)\n  return '🍎'\n}\n\nasync function getBanana() {\n  await delay(3000)\n  return '🍌'\n}\n\n// 아래 코드는 총 6초가 소요된다\nasync function pickFruits() {\n  const apple = await getApple()\n  const banana = await getBanana()\n  return `${apple} + ${banana}`\n}\n\n// 아래 코드는 총 3초가 소요된다\nasync function pickFruits() {\n  const applePromise = getApple()\n  const bananaPromise = getBanana()\n  const apple = await applePromise()\n  const banana = await bananaPromise()\n  return `${apple} + ${banana}`\n}\n</code></pre>\n<h2 id=\"41-promiseall\" style=\"position:relative;\"><a href=\"#41-promiseall\" aria-label=\"41 promiseall permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.1. Promise.all</h2>\n<p>Promise의 <code>all</code> 메소드는 여러 개의 Promise 객체를 배열로 받아, <strong>모든 Promise가 완료되었을 때</strong> 그 결과값을 동일한 순서의 배열로 반환한다.</p>\n<pre><code class=\"language-js\">function delay(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms))\n}\n\nasync function getApple() {\n  await delay(3000)\n  return '🍎'\n}\n\nasync function getBanana() {\n  await delay(3000)\n  return '🍌'\n}\n\nfunction pickAllFruits() {\n  return Promise.all([getApple(), getBanana()]).then((fruits) =>\n    fruits.join(' + ')\n  )\n}\n</code></pre>\n<h2 id=\"42-promiserace\" style=\"position:relative;\"><a href=\"#42-promiserace\" aria-label=\"42 promiserace permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.2. Promise.race</h2>\n<p>Promise의 <code>race</code> 메소드는 여러 개의 Promise 객체를 배열로 받아, <strong>가장 빨리 완료된 Promise 객체</strong>의 결과값을 반환한다.</p>\n<pre><code class=\"language-js\">function delay(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms))\n}\n\nasync function getApple() {\n  await delay(3000)\n  return '🍎'\n}\n\nasync function getBanana() {\n  await delay(3000)\n  return '🍌'\n}\n\nfunction pickOnlyone() {\n  return Promise.race([getApple(), getBanana()])\n}\n</code></pre>\n<h1 id=\"5-참고자료\" style=\"position:relative;\"><a href=\"#5-%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\" aria-label=\"5 참고자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 참고자료</h1>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=s1vpVCrT8f4&#x26;list=PLv2d7VI9OotTVOL4QmPfvJWPJvkmv6h-2&#x26;index=11\">드림코딩: 자바스크립트 11. 비동기 처리의 시작 콜백 이해하기, 콜백 지옥 체험</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=JB_yU6Oe2eE&#x26;list=PLv2d7VI9OotTVOL4QmPfvJWPJvkmv6h-2&#x26;index=12\">드림코딩: 자바스크립트 12. 프로미스 개념부터 활용까지</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=aoQSOZfz3vQ&#x26;list=PLv2d7VI9OotTVOL4QmPfvJWPJvkmv6h-2&#x26;index=13\">드림코딩: 자바스크립트 13. 비동기의 꽃 JavaScript async 와 await 그리고 유용한 Promise APIs</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-callback\">1. Callback</a></p>\n<ul>\n<li><a href=\"#11-%EB%8F%99%EA%B8%B0%EC%A0%81-%EC%BD%9C%EB%B0%B1\">1.1. 동기적 콜백</a></li>\n<li><a href=\"#12-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%A0%81-%EC%BD%9C%EB%B0%B1\">1.2. 비동기적 콜백</a></li>\n<li><a href=\"#13-%EB%B9%84%EB%8F%99%EA%B8%B0-api-%EC%BD%94%EB%93%9C-%EC%98%88%EC%8B%9C\">1.3. 비동기 api 코드 예시</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-promise\">2. Promise</a></p>\n<ul>\n<li><a href=\"#21-promise-producer\">2.1. Promise Producer</a></li>\n<li><a href=\"#22-promise-consumer\">2.2. Promise Consumer</a></li>\n<li><a href=\"#23-%EC%97%90%EB%9F%AC-%ED%95%B8%EB%93%A4%EB%A7%81\">2.3. 에러 핸들링</a></li>\n<li><a href=\"#24-%EB%B9%84%EB%8F%99%EA%B8%B0-api-%EC%BD%94%EB%93%9C-%EC%98%88%EC%8B%9C\">2.4. 비동기 api 코드 예시</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-async--await\">3. async / await</a></p>\n<ul>\n<li><a href=\"#21-async\">2.1. async</a></li>\n<li><a href=\"#22-await\">2.2. await</a></li>\n<li><a href=\"#23-%EC%97%90%EB%9F%AC-%ED%95%B8%EB%93%A4%EB%A7%81-1\">2.3. 에러 핸들링</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#4-promise-vs-async\">4. Promise vs async</a></p>\n<ul>\n<li><a href=\"#41-promiseall\">4.1. Promise.all</a></li>\n<li><a href=\"#42-promiserace\">4.2. Promise.race</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#5-%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\">5. 참고자료</a></p>\n</li>\n</ul>","frontmatter":{"title":"JavaScript 비동기 처리 Promise & Async","createdAt":"2023-09-07","updatedAt":"2023-09-07","tags":["promise","async","await","try","catch","비동기"],"description":null,"reference":"https://www.youtube.com/watch?v=aoQSOZfz3vQ"}},"allMarkdownRemark":{"nodes":[{"id":"d213caa5-57cc-5e67-a96c-cfebe6f529f8","excerpt":"1. Intro 1.1. What is JavaScript? 1.2. The History of JavaScript 1.3. Write to HTML Script 1.4. When to Run JS 1.4.1. Synchronous execution…","parent":{"id":"1720b21e-2873-54b9-8fe5-5ec0e54d9d2e","name":"01_JavaScript_Basics","relativePath":"Language/JavaScript/01_JavaScript_Basics.md"},"frontmatter":{"title":"01. JavaScript Basics","createdAt":"2022-10-23","updatedAt":"2023-01-05"},"fields":{"slug":"/posts/Language/JavaScript/01_JavaScript_Basics/"}},{"id":"e1b04b22-c025-5266-a823-8a21c8214924","excerpt":"1. DOM 1.1. Document Object Model 1.2. Special DOM objects 1.3. Handling DOM 1.3.1. Select 1.3.2. Manipulation 2. Event 2.1. Event handler…","parent":{"id":"24abc79b-ec97-585b-8097-7a47a24aca42","name":"02_JavaScript_Advanced","relativePath":"Language/JavaScript/02_JavaScript_Advanced.md"},"frontmatter":{"title":"02. JavaScript DOM and this ","createdAt":"2022-10-24","updatedAt":"2023-01-02"},"fields":{"slug":"/posts/Language/JavaScript/02_JavaScript_Advanced/"}},{"id":"cad56ff3-d893-52b1-a35c-0e1fce4070ba","excerpt":"1. Synchronous and Asynchronous 1.1. Asynchronous JavaScript 1.2. JavaScript Runtime 2. Axios 2.1. The Structure of Axios 2.2. Promise 2.…","parent":{"id":"15ee5a55-2b53-5813-bdea-be1e3c51ae09","name":"03_JavaScript_Asynchronous","relativePath":"Language/JavaScript/03_JavaScript_Asynchronous.md"},"frontmatter":{"title":"03. JavaScript Async","createdAt":"2022-11-01","updatedAt":"2023-01-02"},"fields":{"slug":"/posts/Language/JavaScript/03_JavaScript_Asynchronous/"}},{"id":"f0396719-efaf-5d7c-8544-52108c97d3b3","excerpt":"1. JavaScript 모듈 1.1. 모듈의 부재 JavaScript는 과거 인터넷 브라우저 회사였던, Netscape의 Brendan Eich(브렌던 아이크)에 의해 만들어졌다. 처음에는 Mocha…","parent":{"id":"afba6128-4a8a-524a-a8fe-b7fc2e236d7e","name":"Modules","relativePath":"Language/JavaScript/Modules.md"},"frontmatter":{"title":"JavaScript 모듈 시스템 비교","createdAt":"2023-09-09","updatedAt":"2023-09-09"},"fields":{"slug":"/posts/Language/JavaScript/Modules/"}},{"id":"b4de88cf-2fb7-533b-9cc7-ce8c17b8211a","excerpt":"이 글은 드림코딩: 자바스크립드 11 ~ 13 비동기 강의를 듣고 정리한 문서이다. 1. Callback 콜백 함수란, 다른 함수의 매개변수로 전달되어 전달된 함수 내부에서 실행될 수 있는 함수를 말한다. 1.…","parent":{"id":"f2176031-fe05-57f2-9438-3aa69da6a4f7","name":"Promise_Async_2","relativePath":"Language/JavaScript/Promise_Async_2.md"},"frontmatter":{"title":"JavaScript 비동기 처리 Promise & Async","createdAt":"2023-09-07","updatedAt":"2023-09-07"},"fields":{"slug":"/posts/Language/JavaScript/Promise_Async_2/"}},{"id":"0f51505a-6206-5a85-b28e-02b0dae340db","excerpt":"1. Promise 1.1. Promise(executor) 2. Aysnc & Await 2.1. async 2.2. await 2.3. try / catch 3. Example 3.1. Chaining 처리, Hard Code 3.1.…","parent":{"id":"3585fbfd-fa62-5290-a175-1bd09c1dfd3a","name":"Promise_Await","relativePath":"Language/JavaScript/Promise_Await.md"},"frontmatter":{"title":"Promise와 await를 활용하 JS 8가지 비동기 처리","createdAt":"2023-01-02","updatedAt":"2023-01-02"},"fields":{"slug":"/posts/Language/JavaScript/Promise_Await/"}},{"id":"3c0103d9-947d-584e-b271-b2aa243f3f08","excerpt":"1. 번들러 1.1. 번들러란? 번들러는 여러 자바스크립트 모듈 간의 관계를 분석하여 하나의 자바스크립트 파일로 만드는 도구이다. 반드시 하나의 자바스크립트 파일일 필요는 없고, 원한면 몇 개로 나눌 수도 있다. 이를 코드 스프리팅(Code…","parent":{"id":"ce744717-0985-5344-94de-496d38113237","name":"Webpack_Rollup_Vite","relativePath":"Language/JavaScript/Webpack_Rollup_Vite.md"},"frontmatter":{"title":"Webpack vs Rollup vs Vite 비교 분석","createdAt":"2023-09-10","updatedAt":"2023-09-10"},"fields":{"slug":"/posts/Language/JavaScript/Webpack_Rollup_Vite/"}},{"id":"b58b9818-4c5e-5467-b86c-efe2f684e298","excerpt":"1. 핵심 내용 브라우저는 HTML, CSS, JS 등 렌더링에 필요한 리소스르르 요청하고 서버로부터 응답받는다. 브라우저 렌더링 엔진이 HTML과 CSS를 파싱하역 각각 DOM과 CSSOM…","parent":{"id":"42b699e3-ea21-552c-b603-8b9b032568f5","name":"Browser_Rendering","relativePath":"Language/JavaScript/Browser_Rendering.md"},"frontmatter":{"title":"브라우저 렌더링 과정","createdAt":"2023-09-23","updatedAt":"2023-09-23"},"fields":{"slug":"/posts/Language/JavaScript/Browser_Rendering/"}},{"id":"4d47e063-d4d4-5864-ade9-a8a2d0f1e051","excerpt":"10분 테코톡: 하루의 실행 컨텍스트 영상을 참조해서 작성한 글이다 우테코는 도대체 무슨 짓을 꾸미고 있는 것일까... 여기 테코톡은 매번 볼 때마다 놀랍다. 특히 이번 영상은 감탄마저 나올 정도다👍 1. 실행 컨텍스트 (Execute Context…","parent":{"id":"598fda13-e699-5500-a0d0-5bad07868743","name":"Execute_Context","relativePath":"Language/JavaScript/Execute_Context.md"},"frontmatter":{"title":"실행 컨텍스트로 이해하는 Hoisting, Scope, Closure","createdAt":"2023-09-22","updatedAt":"2023-09-22"},"fields":{"slug":"/posts/Language/JavaScript/Execute_Context/"}},{"id":"bc3cf8c8-9ffc-5759-8384-1081ab0862e2","excerpt":"1. 클래스란? 1.1. 정의 자바스크립트의 클래스를 흔히 **문법적 설탕(synthetic sugar…","parent":{"id":"3c48b83c-3bf7-5dda-9fce-72c29b8107a4","name":"class","relativePath":"Language/JavaScript/class.md"},"frontmatter":{"title":"자바스크립트 ES6 class 문법","createdAt":"2023-10-17","updatedAt":"2023-10-17"},"fields":{"slug":"/posts/Language/JavaScript/class/"}},{"id":"722f2b6c-0335-5a25-94e3-44e6a96d9d17","excerpt":"1. 개요 자바스크립트는 프로토타입 기반의 객체 지향 언어이다. ES6부터 클래스형 문법이 도입되었다고 하지만, 이는 \"다른 객체 지향 언어처럼\" 사용하도록 도와주는 API…","parent":{"id":"43f9daad-bb94-5bfb-b40f-e16699d3d50e","name":"prototype","relativePath":"Language/JavaScript/prototype.md"},"frontmatter":{"title":"자바스크립트 Prototype 이해하기","createdAt":"2023-10-12","updatedAt":"2023-10-12"},"fields":{"slug":"/posts/Language/JavaScript/prototype/"}},{"id":"c0ad1c54-8714-5e5d-b1d2-7aa89b3d115d","excerpt":"1. this 란? this는 함수가 실행컨텍스트에서 참조하고 있는 객체이다. 따라서 모든 함수는 자신만의 this를 가지고 있다. 문제는 이 this…","parent":{"id":"bb3ac8ea-a2b4-5a78-8914-0bd7a6c5891c","name":"this","relativePath":"Language/JavaScript/this.md"},"frontmatter":{"title":"자바스크립트 this 정복하기","createdAt":"2023-09-24","updatedAt":"2023-09-24"},"fields":{"slug":"/posts/Language/JavaScript/this/"}},{"id":"61ce8ae2-05de-5484-9960-76b1d878106a","excerpt":"1. 생성자 함수 & new 키워드 new 키워드와 생성자 함수를 사용하면 손쉽게 객체를 찍어낼 수 있다. 자바스크립트 버전의 OOP라고 생각할 수 있다. 자바가 객체를 찍어내기 위해 class 키워드를 사용한다면, 자바스크립트는 생성자 함수와 new…","parent":{"id":"7dbfcf53-cb94-5255-aa1d-4181665d88dd","name":"new","relativePath":"Language/JavaScript/new.md"},"frontmatter":{"title":"자바스크립트 생성자 함수 & new 키워드","createdAt":"2023-10-11","updatedAt":"2023-10-11"},"fields":{"slug":"/posts/Language/JavaScript/new/"}}]}},"pageContext":{"pagePath":"/posts/Language/JavaScript/Promise_Async_2/","siblingPostsPathRegex":"/^(?!.*README).*Language\\/JavaScript.*$/","relativeDirectory":"JavaScript","id":"b4de88cf-2fb7-533b-9cc7-ce8c17b8211a","parent":{"id":"f2176031-fe05-57f2-9438-3aa69da6a4f7","name":"Promise_Async_2","relativePath":"Language/JavaScript/Promise_Async_2.md"},"fields":{"slug":"/posts/Language/JavaScript/Promise_Async_2/"}}},"staticQueryHashes":["24302420","4059933791"],"slicesMap":{}}