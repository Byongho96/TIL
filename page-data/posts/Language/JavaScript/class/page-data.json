{"componentChunkName":"component---src-templates-post-index-tsx","path":"/posts/Language/JavaScript/class/","result":{"data":{"markdownRemark":{"id":"bc3cf8c8-9ffc-5759-8384-1081ab0862e2","html":"<h1 id=\"1-클래스란\" style=\"position:relative;\"><a href=\"#1-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%9E%80\" aria-label=\"1 클래스란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 클래스란?</h1>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/eefddadab706dc91f212bfc5329795c4/6af66/es6-logo.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 62.28571428571429%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABpUlEQVR42n2Q3yukURjH5w+RdbXM+T5HDEpKUts2Ihfyo3AhSpLsFReu2DtqrrYk5IIrF6MkrsTWTrFJuxga7IzmfV/zOjOLZEM479nOK+THTH16Os8553ue7/l6lIVnTDgPWC4mXpy+wfOit6EE1AkcAcfWC3XsbiZc7DRiPcRGageHIWZusNg6s38zYxNXf3C+h38HuIjgbBfS0NzHta9nsTSgUvi5iIkAgpMsMMQmAmz6m3dxxjs77h0dZqtBNjfFbqKP1t6xbUGauIvjzsKtoRfSwHUU5oau0oIUSG5ppNBOX4v1JxNwnqpAKowaP3W3022cDfajoIB/zOUdrbjcZ54MYeogBOxfyM3jzY30PYisD7yulob6MTaix2QS6yAExDby83lrE+2soKSYGHhHC9aXmEpmFGvnNqJrzFfI62pI/UVogQ18QZ6XFxfx03AasXQNx9ZQ7aeKcp6dw3s7aWsZ/k/U10M+Hy8rpYtIGrHjJncTQ+Arqj7zlgbaD+EghK42qqyg5nr6MQ/XtkFpsUglcR9z30qQOiElII/cVugL/wG8/bFgNWqA4AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/TIL/static/eefddadab706dc91f212bfc5329795c4/c54d4/es6-logo.webp 175w,\n/TIL/static/eefddadab706dc91f212bfc5329795c4/a3432/es6-logo.webp 350w,\n/TIL/static/eefddadab706dc91f212bfc5329795c4/0ba47/es6-logo.webp 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" type=\"image/webp\">\n          <source srcset=\"/TIL/static/eefddadab706dc91f212bfc5329795c4/4edbd/es6-logo.png 175w,\n/TIL/static/eefddadab706dc91f212bfc5329795c4/13ae7/es6-logo.png 350w,\n/TIL/static/eefddadab706dc91f212bfc5329795c4/6af66/es6-logo.png 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" type=\"image/png\">\n          <img class=\"gatsby-resp-image-image\" src=\"/TIL/static/eefddadab706dc91f212bfc5329795c4/6af66/es6-logo.png\" alt=\"자바스크립트 ES6 포스터\" title=\"\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span>\n<h2 id=\"11-정의\" style=\"position:relative;\"><a href=\"#11-%EC%A0%95%EC%9D%98\" aria-label=\"11 정의 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1. 정의</h2>\n<p>자바스크립트의 클래스를 흔히 <b>문법적 설탕(synthetic sugar)</b>, 혹은 <strong>새로운 객체 생성 패턴</strong>이라 말하기도 한다. 이러한 장황한 수식언이 붙는 까닭은 원래 자바스크립트가 <strong>프로토타입 기반 객체지향 언어</strong>이기 때문이다. 때문에 다른 객체지향언어(Java, Python, ...)를 사용하는 개발자들이 사용에 어색함을 느꼈고, 마침내 ECMAScript가 ES6에서 클래스 문법 도입하기에 이르렀다.</p>\n<p>이제는 자바스크립트도 다른 언어들과 아주 유사한 문법으로 객체지향 프로그래밍 할 수 있게 되었다. 하지만 겉모습만 그렇게 보일 뿐, 여전히 내부 동작은 프로토타입에 기반한다. 따라서 자바스크립트의 객체지향을 제대로 이해하기 위해서는 <strong>프로토타입에 대한 이해가 선행</strong>되어야 한다. 마침 여기에 누군가가 <a href=\"https://byongho96.github.io/TIL/posts/Language/JavaScript/prototype/\">프로토타입을 잘 정리한 글</a>이 있다.</p>\n<h2 id=\"12-특징\" style=\"position:relative;\"><a href=\"#12-%ED%8A%B9%EC%A7%95\" aria-label=\"12 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2. 특징</h2>\n<p>자바스크립트의 class는 기존 생성자 함수와 다음과 같은 차이가 있다.</p>\n<ul>\n<li>클래스는 <code>new</code> 키워드 없이 호출하면 에러가 발생한다.</li>\n<li>클래스는 상속을 지원하는 <code>extends</code>와 <code>super</code>키워드를 지원한다.</li>\n<li>클래스는 Temporal Dead Zone(일시적 사각 지대)를 가져 호이스팅이 발생하지 않는 것처럼 보인다.</li>\n<li>클래스 내의 모든 코드에는 암묵적으로 strict mode가 적용된다.</li>\n</ul>\n<h2 id=\"13-기본-사용법\" style=\"position:relative;\"><a href=\"#13-%EA%B8%B0%EB%B3%B8-%EC%82%AC%EC%9A%A9%EB%B2%95\" aria-label=\"13 기본 사용법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.3. 기본 사용법</h2>\n<p>간단하게 다음과 같이 선언하고 사용할 수 있다. 얼핏 봐도 다른 언어들과 문법이 비슷하다.</p>\n<pre><code class=\"language-js\">class Person {\n  constructor(name) {\n    this.name = name\n  }\n\n  sayHi() {\n    console.log(`Hi! I'm ${this.name}`)\n  }\n\n  static syHello() {\n    console.log('Hello!')\n  }\n}\n\nconst lee = new Person('Lee')\n\nconsole.log(lee.name) // Lee\nlee.sayHi() // Hi! I'm Lee\nPerson.sayHello() // Hello!\n</code></pre>\n<h1 id=\"2-메소드\" style=\"position:relative;\"><a href=\"#2-%EB%A9%94%EC%86%8C%EB%93%9C\" aria-label=\"2 메소드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 메소드</h1>\n<p>메소드란 <strong>클래스 내부에 정의된 함수</strong>를 말한다. constructor(생성자), 프로토타입 메소드, 정적 메소드가 있다.</p>\n<h2 id=\"21-constructor\" style=\"position:relative;\"><a href=\"#21-constructor\" aria-label=\"21 constructor permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. constructor</h2>\n<p>constructor는 인스턴스를 생성하고 초기화하는 특별한 함수이다. constructor는 최종적으로 메서드로 해석되는 것이 아니라 클래스가 평가되어 생성한 함수 객체의 일부가 된다. 한마디로 <strong>constructor가 곧 생성자 함수로 동작</strong>한다. 아래의 두 코드는 <code>new</code>키워드로 실행 시 동일하게 동작한다.</p>\n<pre><code class=\"language-js\">// 클래스\nclass Person {\n  // 생성자\n  consturctor(name) {\n    this.name = name\n  }\n}\n\n// 생성자 함수\nfunction Person(name) {\n  this.name = name\n}\n</code></pre>\n<h3 id=\"211-사용\" style=\"position:relative;\"><a href=\"#211-%EC%82%AC%EC%9A%A9\" aria-label=\"211 사용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1.1. 사용</h3>\n<p>constructor로 생성할 <strong>객체의 속성을 초기화</strong>할 수 있다. constructor에 매개변수를 선언하고, 인스턴스를 생성할 때 초깃값을 인자로 전달할 수 있다. 또한 constructor는 생성자 함수와 같이 암묵적으로 <code>this</code>에 빈 객체를 선언하고, 이를 반환한다.</p>\n<pre><code class=\"language-js\">class Person {\n  constructor(name, address) {\n    // 암묵적으로 this를 선언하고 빈 객체를 할당한다\n    // this = {}\n\n    this.name = name\n    this.address = address\n\n    // 암묵적으로 this를 반환한다\n    // return this\n  }\n}\n\nconst me = new Person('Lee', 'Seoul')\nconsole.log(me) // Person {name: \"Lee\", address: \"Seoul\"}\n</code></pre>\n<h3 id=\"212-특징\" style=\"position:relative;\"><a href=\"#212-%ED%8A%B9%EC%A7%95\" aria-label=\"212 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1.2. 특징</h3>\n<ul>\n<li>\n<p><strong>이름을 변경할 수 없다.</strong><br>\n클래스의 생성자 이름은 contructor로 고정되어 있다.</p>\n</li>\n<li>\n<p><strong>클래스 내 최대 하나까지만 존재할 수 있다.</strong><br>\n클래스가 2개 이상이라면 문법 에러(SyntaxError)가 발생한다.</p>\n<pre><code class=\"language-js\">class Person {\n  constructor() {}\n  constructor() {}\n}\n// SyntaxError: A class may only have one constructor\n</code></pre>\n</li>\n<li>\n<p><strong>constructor를 생략하면 빈 constructor가 암묵적으로 정의된다.</strong></p>\n<pre><code class=\"language-js\">class Person {\n  // constructor() {}\n}\n\nconst me = new Person()\nconsole.log(me) // Person {}\n</code></pre>\n</li>\n<li>\n<p><strong>명시적으로 다른 객체를 반환하면 this 대신 명시한 객체가 반환된다.</strong></p>\n<pre><code class=\"language-js\">class Person {\n  constructor(name) {\n    this.name = name\n    return {}\n  }\n}\n\nconst me = new Person('Lee')\nconsole.log(me) // {}\n</code></pre>\n</li>\n<li>\n<p><strong>명시적으로 원시값이 반환하면 원시값 반환은 무시되고 this가 반환된다.</strong></p>\n<pre><code class=\"language-js\">class Person {\n  constructor(name) {\n    this.name = name\n    return 100\n  }\n}\n\nconst me = new Person('Lee')\nconsole.log(me) // Person {name: 'Lee'}\n</code></pre>\n</li>\n</ul>\n<h2 id=\"22-프로토타입-메서드\" style=\"position:relative;\"><a href=\"#22-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EB%A9%94%EC%84%9C%EB%93%9C\" aria-label=\"22 프로토타입 메서드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2. 프로토타입 메서드</h2>\n<p>클래스 내부에 선언된 함수들은 기본적으로 프로토타임 메서드다. 다시 말해 <strong>해당 클래스의 프로토타입 객체(<code>prototype</code>)의 메소드로 할당</strong>되다. 그 결과 생성된 인스턴스의 프로토타입 체인에 포함된다.</p>\n<pre><code class=\"language-js\">class Person {\n  constructor(name) {\n    this.name = name\n  }\n\n  // 프로토타입 메서드\n  sayHi() {\n    console.log(`Hi! I'm ${this.name}`)\n  }\n}\n\nconst lee = new Person('Lee')\nlee.sayHi() // Hi! I'm Lee\n</code></pre>\n<pre><code class=\"language-js\">console.dir(Object.getOwnPropertyNames(lee)) // [ 'name' ]\nconsole.dir(Object.getOwnPropertyNames(Person.prototype)) // [ 'constructor', 'sayHi' ]\n</code></pre>\n<p>아래 그림처럼 프로토타입 메서드는 자동적으로 클래스의 프로토타입 객체(<code>prototype</code>)에 할당된다. 따라서 모든 인스턴스들이 프로토타입 체인으로 접근할 수 있다.</p>\n<figure>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/d8dd0e4c0e9034ce226d75adf89d325d/2b013/class_prototype_method.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 62.28571428571429%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMCBf/EABUBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAHrrwls0T//xAAaEAEAAgMBAAAAAAAAAAAAAAABAiEAECIx/9oACAEBAAEFAk6mXHxxvX//xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAwEBPwGn/8QAFREBAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQIBAT8Bh//EABkQAAEFAAAAAAAAAAAAAAAAADIAESCBof/aAAgBAQAGPwIdQvcf/8QAHBAAAgICAwAAAAAAAAAAAAAAAAERITFBYXGx/9oACAEBAAE/IXtnfkaHZQw1BgX36JQoR//aAAwDAQACAAMAAAAQ9C//xAAWEQEBAQAAAAAAAAAAAAAAAAAAAVH/2gAIAQMBAT8Qmlf/xAAYEQADAQEAAAAAAAAAAAAAAAAAASGh8P/aAAgBAgEBPxBzOwR//8QAGxABAAMBAQEBAAAAAAAAAAAAAQARITGBQcH/2gAIAQEAAT8QOhK3qX5HR8XTpFloFJ2vZix0gASrzEfsI+AUT//Z'); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/TIL/static/d8dd0e4c0e9034ce226d75adf89d325d/c54d4/class_prototype_method.webp 175w,\n/TIL/static/d8dd0e4c0e9034ce226d75adf89d325d/a3432/class_prototype_method.webp 350w,\n/TIL/static/d8dd0e4c0e9034ce226d75adf89d325d/426ac/class_prototype_method.webp 700w,\n/TIL/static/d8dd0e4c0e9034ce226d75adf89d325d/c139f/class_prototype_method.webp 1050w,\n/TIL/static/d8dd0e4c0e9034ce226d75adf89d325d/7f403/class_prototype_method.webp 1400w,\n/TIL/static/d8dd0e4c0e9034ce226d75adf89d325d/e5be3/class_prototype_method.webp 1700w\" sizes=\"(max-width: 700px) 100vw, 700px\" type=\"image/webp\">\n          <source srcset=\"/TIL/static/d8dd0e4c0e9034ce226d75adf89d325d/e52aa/class_prototype_method.jpg 175w,\n/TIL/static/d8dd0e4c0e9034ce226d75adf89d325d/70ebb/class_prototype_method.jpg 350w,\n/TIL/static/d8dd0e4c0e9034ce226d75adf89d325d/29d31/class_prototype_method.jpg 700w,\n/TIL/static/d8dd0e4c0e9034ce226d75adf89d325d/9ecec/class_prototype_method.jpg 1050w,\n/TIL/static/d8dd0e4c0e9034ce226d75adf89d325d/d165a/class_prototype_method.jpg 1400w,\n/TIL/static/d8dd0e4c0e9034ce226d75adf89d325d/2b013/class_prototype_method.jpg 1700w\" sizes=\"(max-width: 700px) 100vw, 700px\" type=\"image/jpeg\">\n          <img class=\"gatsby-resp-image-image\" src=\"/TIL/static/d8dd0e4c0e9034ce226d75adf89d325d/29d31/class_prototype_method.jpg\" alt=\"프로토타입 메서드\" title=\"\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span>\n  <figcaption>From 모던 자바스크립트 Deep Dive. By 이웅모.</figcaption>\n</figure>\n<h2 id=\"23-정적-메서드\" style=\"position:relative;\"><a href=\"#23-%EC%A0%95%EC%A0%81-%EB%A9%94%EC%84%9C%EB%93%9C\" aria-label=\"23 정적 메서드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3. 정적 메서드</h2>\n<p>정적 메서드는 <code>static</code>키워드로 선언할 수 있다. 정적 메서드는 프로토타입이 아닌 <strong>클래스 자체에 할당</strong>된다. 그 결과 생성된 인스턴스 프로토타입 체인에 포함되지 않는다.</p>\n<pre><code class=\"language-js\">class Person {\n  constructor(name) {\n    this.name = name\n  }\n\n  // 프로토타입 메서드\n  static sayHi() {\n    console.log('Hi!')\n  }\n}\n\nPerson.sayHi() // Hi!\n</code></pre>\n<p>아래 그림처럼 정적 메서드는 클래스에 할당된다. 따라서 <strong>자신이 생성된 인스턴스와 다른 프로토타입 체인</strong>을 가지게 된다. 그 결과 프로토타입 메서드와 다음과 같은 차이점을 가진다.</p>\n<ul>\n<li>정적 메서드는 인스턴스로 호출할 수 없고, 클래스로 호출해야 한다.</li>\n<li>정적 메서드는 인스턴스 프로퍼티를 참조할 수 없다.</li>\n</ul>\n<figure>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/3d9b10342a014bf27af96b401bfce19f/2b013/class_static_method.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 60%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDAQX/xAAVAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAAB6zXnLown/8QAGBAAAwEBAAAAAAAAAAAAAAAAAAECETL/2gAIAQEAAQUCrqiOTFQli//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAEDAQE/Aaf/xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAgEBPwGH/8QAGhAAAQUBAAAAAAAAAAAAAAAAAQACECGRMf/aAAgBAQAGPwLh1CnbNx//xAAaEAADAAMBAAAAAAAAAAAAAAAAAREhMXFh/9oACAEBAAE/Ic2zeqRXIZyDRU110Y+QKktH/9oADAMBAAIAAwAAABCHP//EABgRAAIDAAAAAAAAAAAAAAAAAAABESEx/9oACAEDAQE/EFiR2z//xAAZEQEAAgMAAAAAAAAAAAAAAAABABExofD/2gAIAQIBAT8Qc67UCif/xAAcEAEAAgIDAQAAAAAAAAAAAAABABEhQWFxkTH/2gAIAQEAAT8QzAPhPLjvgu+neSBASFxc9tgs6juK6UpBB0Obn//Z'); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/TIL/static/3d9b10342a014bf27af96b401bfce19f/c54d4/class_static_method.webp 175w,\n/TIL/static/3d9b10342a014bf27af96b401bfce19f/a3432/class_static_method.webp 350w,\n/TIL/static/3d9b10342a014bf27af96b401bfce19f/426ac/class_static_method.webp 700w,\n/TIL/static/3d9b10342a014bf27af96b401bfce19f/c139f/class_static_method.webp 1050w,\n/TIL/static/3d9b10342a014bf27af96b401bfce19f/7f403/class_static_method.webp 1400w,\n/TIL/static/3d9b10342a014bf27af96b401bfce19f/e5be3/class_static_method.webp 1700w\" sizes=\"(max-width: 700px) 100vw, 700px\" type=\"image/webp\">\n          <source srcset=\"/TIL/static/3d9b10342a014bf27af96b401bfce19f/e52aa/class_static_method.jpg 175w,\n/TIL/static/3d9b10342a014bf27af96b401bfce19f/70ebb/class_static_method.jpg 350w,\n/TIL/static/3d9b10342a014bf27af96b401bfce19f/29d31/class_static_method.jpg 700w,\n/TIL/static/3d9b10342a014bf27af96b401bfce19f/9ecec/class_static_method.jpg 1050w,\n/TIL/static/3d9b10342a014bf27af96b401bfce19f/d165a/class_static_method.jpg 1400w,\n/TIL/static/3d9b10342a014bf27af96b401bfce19f/2b013/class_static_method.jpg 1700w\" sizes=\"(max-width: 700px) 100vw, 700px\" type=\"image/jpeg\">\n          <img class=\"gatsby-resp-image-image\" src=\"/TIL/static/3d9b10342a014bf27af96b401bfce19f/29d31/class_static_method.jpg\" alt=\"정적 메서드\" title=\"\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span>\n  <figcaption>From 모던 자바스크립트 Deep Dive. By 이웅모.</figcaption>\n</figure>\n<h1 id=\"3-프로퍼티\" style=\"position:relative;\"><a href=\"#3-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\" aria-label=\"3 프로퍼티 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 프로퍼티</h1>\n<p>프로퍼티란 <strong>클래스 내부에서 정의된 변수</strong>를 말한다. 속성/필드라는 이름으로도 부른다. 인스턴스 프로퍼티, 접근자 프로퍼티, 클래스 프로퍼티, 정적 프로퍼티가 있다.</p>\n<h2 id=\"31-인스턴스-프로퍼티\" style=\"position:relative;\"><a href=\"#31-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\" aria-label=\"31 인스턴스 프로퍼티 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1. 인스턴스 프로퍼티</h2>\n<p>인스턴스 프로퍼티는 constructor 내부에서 정의해야 한다. 생성자 코드 실행 전에 암묵적으로 빈 객체가 <code>this</code>에 바인딩 되기 때문에, 인스턴스 프로퍼티는 <strong>생성된 각 인스턴스에 할당</strong>된다.</p>\n<pre><code class=\"language-js\">class Person {\n  constructor(name) {\n    this.name = name\n  }\n}\n\nconst lee = new Person('Lee')\nconsole.log(lee.name) // Lee\n</code></pre>\n<h2 id=\"32-접근자-프로퍼티\" style=\"position:relative;\"><a href=\"#32-%EC%A0%91%EA%B7%BC%EC%9E%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\" aria-label=\"32 접근자 프로퍼티 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2. 접근자 프로퍼티</h2>\n<p>접근자 프로퍼티는 함수이지만, 외부에서 마치 인스터스 프로퍼티처럼 사용할 수 있다. <strong><code>get</code>과 <code>set</code> 키워드로 서언된 함수는 각각 getter와 setter로 동작</strong>한다. getter는 반드시 어떤 값을 반환해야하고,\nsetter는 반드시 단 하나의 매개변수를 받아 값을 할당해야 한다.</p>\n<pre><code class=\"language-js\">class Person {\n  constructor(firstName, lastName) {\n    this.firstName = firstName\n    this.lastName = lastName\n  }\n\n  get fullName() {\n    return `${this.firstName} ${this.lastName}`\n  }\n\n  set fullName(name) {\n    ;[this.firstName, this.lastName] = name.split(' ')\n  }\n}\n\nconst lee = new Person('Brian', 'Lee')\nconsole.log(lee.fullName) // Brian Lee\n\nlee.fullName = 'John Lee'\nconsole.log(lee.firstName) // John\n</code></pre>\n<p>접근자 프로퍼티는 엄밀히 말해 함수이기 때문에 <strong>프로토타입 프로퍼티로 할당</strong>된다.</p>\n<pre><code class=\"language-js\">console.dir(Object.getOwnPropertyNames(lee)) // [ 'firstName', 'lastName' ]\nconsole.dir(Object.getOwnPropertyNames(Person.prototype)) // [ 'constructor', 'fullName' ]\n</code></pre>\n<h2 id=\"33-클래스-필드\" style=\"position:relative;\"><a href=\"#33-%ED%81%B4%EB%9E%98%EC%8A%A4-%ED%95%84%EB%93%9C\" aria-label=\"33 클래스 필드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.3. 클래스 필드</h2>\n<p>이름과 다르게 클래스 필드 또한 <strong>생성할 인스턴스의 프로퍼티</strong>로 할당된다. 이는 원래 Java와 같은 클래스 기반 객체지향 언어에서 사용하던 용어이다.</p>\n<h3 id=\"331-java\" style=\"position:relative;\"><a href=\"#331-java\" aria-label=\"331 java permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.3.1. Java</h3>\n<p>자바의 클래스 필드는 마치 <strong>클래스 내부에서 변수처럼 <code>this</code>없이 참조</strong>할 수 있다. 다만 클래스 필드가 생성자 또는 메서드 매개변수 이름과 동일할 때, 클래스 필드임을 명확하게 하기 위해 <code>this</code>를 사용해야 한다</p>\n<pre><code class=\"language-java\">public class Person {\n  // 클래스 필드 정의\n  private String firstName = \"\";\n  private String lastName = \"\";\n\n  // 생성자\n  Person(String firstName, String lastName) {\n    // 매개변수 이름과 구분하기 위해 this로 클래스 필드임을 명시한다.\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n\n  public String getFulName() {\n    // this 없이 클래스 필드를 참조할 수 있다.\n    return firstName + ' ' + lastName;\n  }\n}\n</code></pre>\n<h3 id=\"332-javasript\" style=\"position:relative;\"><a href=\"#332-javasript\" aria-label=\"332 javasript permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.3.2. JavaSript</h3>\n<p>반면 자바스크립트에서는 클래스 필드라도 <strong>반드시 <code>this</code>를 사용해서 참조</strong>해야한다. 클래스 필드는 초기화할 수 있으며, 초기화하지 않을 경우 <code>undefined</code>가 할당된다.</p>\n<pre><code class=\"language-js\">class Person {\n  name = 'Lee'\n  constructor() {\n    console.log(name) // ReferenceError: name is not defined\n  }\n}\n</code></pre>\n<pre><code class=\"language-js\">class Person {\n  name\n  constructor() {\n    console.log(this.name) // undefined\n  }\n}\n</code></pre>\n<p>보통 클래스 필드는 <strong>인스턴스 생성 시점에 초기화할 필요가 없는 프로퍼티</strong>를 정의한는데 쓰인다.</p>\n<pre><code class=\"language-js\">class Person {\n  lastName = 'Lee'\n\n  constructor(firstName) {\n    this.firstName = firstName\n  }\n}\n\nconst brian = new Person('Brian')\nconsole.log(brian.firstName) // Brian\nconsole.log(brian.lastName) // Lee\n</code></pre>\n<h3 id=\"333-private-필드\" style=\"position:relative;\"><a href=\"#333-private-%ED%95%84%EB%93%9C\" aria-label=\"333 private 필드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.3.3. private 필드</h3>\n<p>기본적으로 선언되는 public 필드는 어디서든 참조할 수 있지만, <strong>private 필드는 클래스 내부에서만 참조</strong>할 수 있다. 변수명 앞에 <code>#</code>을 붙여 선언하며, 참조할 때도 <code>#</code>을 붙여줘야 한다.</p>\n<pre><code class=\"language-js\">class Person {\n  #name = ''\n\n  constructor(name) {\n    this.#name = name\n  }\n}\n\nconst lee = new Person('Lee')\nconsole.log(lee.#name) // SyntaxError: private field '#name' must be declared in an enclosing class\n</code></pre>\n<p>따라서 private 필드를 외부에서 제한적으로 접근하도록 하기 위해 접근자 프로퍼티를 사용한다.</p>\n<pre><code class=\"language-js\">class Person {\n  #name = ''\n\n  constructor(name) {\n    this.#name = name\n  }\n\n  get name() {\n    return this.#name.trim()\n  }\n}\n\nconst lee = new Person(' Lee ')\nconsole.log(lee.name) // Lee\n</code></pre>\n<h2 id=\"34-정적-필드\" style=\"position:relative;\"><a href=\"#34-%EC%A0%95%EC%A0%81-%ED%95%84%EB%93%9C\" aria-label=\"34 정적 필드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.4. 정적 필드</h2>\n<p>정적 메서드와 마찬가지로 클래스에 할당되는 프로퍼티이다. 따라서 클래스에서 바로 참조하여 사용할 수 있는 반면, 인스턴스에서는 참조할 수 없다.</p>\n<pre><code class=\"language-js\">class MyMath {\n  static PI = 22 / 7\n}\n\nconsole.log(MyMath.PI) // 3.142857142857143\n\nmyMath = new MyMath()\nconsole.log(myMath.PI) // undefined\n</code></pre>\n<h1 id=\"4-상속\" style=\"position:relative;\"><a href=\"#4-%EC%83%81%EC%86%8D\" aria-label=\"4 상속 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 상속</h1>\n<p>자바스크립트의 상속으로 프로토타입 체이닝을 간단하게 구현할 수 있다.</p>\n<h2 id=\"41-extends\" style=\"position:relative;\"><a href=\"#41-extends\" aria-label=\"41 extends permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.1. extends</h2>\n<p>자바스크립트 상속은 <code>extends</code>키워드로 구현할 수 있으며, 자식 클래스의 프로토타입이 부모 클래스의 프로토타입을 <code>__proto__</code>로 참조한다.</p>\n<pre><code class=\"language-js\">class Animal {\n  constructor(age, weight) {\n    this.age = age\n    this.weight = weight\n  }\n\n  eat() {\n    console.log('eat')\n  }\n\n  move() {\n    console.log('move')\n  }\n}\n\nclass Bird extends Animal {\n  fly() {\n    console.log('fly')\n  }\n}\n\nconst bird = new Bird(1, 5)\n\nconsole.log(bird) // Bird {age:1, weight: 5}\nconsole.log(bird instanceof Bird) // true\nconsole.log(bird instanceof Animal) // true\n\nbird.eat() // eat\nbird.move() // move\nbird.fly() // fly\n</code></pre>\n<p>위의 코드는 아래 그림과 같은 프로토타입 체인을 형성한다. 자식 클래스 Bird의 프로토타입 객체가 <code>__proto__</code> 부모 클래스 Animal의 프로토타입 객체를 참조하고 있다.</p>\n<figure>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; margin-bottom: 20px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/TIL/static/f93720239ce428bd08e56ece91c48ee3/2b013/class_prototype_chain.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 110.28571428571428%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAWABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAECAwX/xAAWAQEBAQAAAAAAAAAAAAAAAAACAAH/2gAMAwEAAhADEAAAAepa4KySM5Fajb//xAAbEAACAgMBAAAAAAAAAAAAAAABAgAREjEyQf/aAAgBAQABBQL14nNtb3E0TGGUUUP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAWEQADAAAAAAAAAAAAAAAAAAAAARD/2gAIAQIBAT8BFf/EAB4QAAECBwEAAAAAAAAAAAAAAAAxgQECICFBQpGh/9oACAEBAAY/Akn6bMZcT0tCn//EABwQAAMAAgMBAAAAAAAAAAAAAAABESFhMVGRsf/aAAgBAQABPyHF/USmsO9mag6WBrwPbZXNQgxDZvoqKP/aAAwDAQACAAMAAAAQcDfA/8QAGREBAAMBAQAAAAAAAAAAAAAAAQARMRDh/9oACAEDAQE/ELb9jsFM5//EABgRAQEBAQEAAAAAAAAAAAAAAAEAETHR/9oACAECAQE/EAMfLiQewZf/xAAfEAEBAAIBBAMAAAAAAAAAAAABEQAhMVFxobGBkdH/2gAIAQEAAT8QrtyckOe+TSka1vmJi0gbdJXyuRcfqVfWBBrNoJ4cU5K8DfzNhH7wA6wiDPWAKyrtuf/Z'); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/TIL/static/f93720239ce428bd08e56ece91c48ee3/c54d4/class_prototype_chain.webp 175w,\n/TIL/static/f93720239ce428bd08e56ece91c48ee3/a3432/class_prototype_chain.webp 350w,\n/TIL/static/f93720239ce428bd08e56ece91c48ee3/426ac/class_prototype_chain.webp 700w,\n/TIL/static/f93720239ce428bd08e56ece91c48ee3/c139f/class_prototype_chain.webp 1050w,\n/TIL/static/f93720239ce428bd08e56ece91c48ee3/7f403/class_prototype_chain.webp 1400w,\n/TIL/static/f93720239ce428bd08e56ece91c48ee3/e5be3/class_prototype_chain.webp 1700w\" sizes=\"(max-width: 700px) 100vw, 700px\" type=\"image/webp\">\n          <source srcset=\"/TIL/static/f93720239ce428bd08e56ece91c48ee3/e52aa/class_prototype_chain.jpg 175w,\n/TIL/static/f93720239ce428bd08e56ece91c48ee3/70ebb/class_prototype_chain.jpg 350w,\n/TIL/static/f93720239ce428bd08e56ece91c48ee3/29d31/class_prototype_chain.jpg 700w,\n/TIL/static/f93720239ce428bd08e56ece91c48ee3/9ecec/class_prototype_chain.jpg 1050w,\n/TIL/static/f93720239ce428bd08e56ece91c48ee3/d165a/class_prototype_chain.jpg 1400w,\n/TIL/static/f93720239ce428bd08e56ece91c48ee3/2b013/class_prototype_chain.jpg 1700w\" sizes=\"(max-width: 700px) 100vw, 700px\" type=\"image/jpeg\">\n          <img class=\"gatsby-resp-image-image\" src=\"/TIL/static/f93720239ce428bd08e56ece91c48ee3/29d31/class_prototype_chain.jpg\" alt=\"자바스크립트 상속의 프로토타입 체인\" title=\"\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span>\n  <figcaption>From 모던 자바스크립트 Deep Dive. By 이웅모.</figcaption>\n</figure>\n<h2 id=\"42-super\" style=\"position:relative;\"><a href=\"#42-super\" aria-label=\"42 super permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.2. super</h2>\n<p>super 키워드는 함수처럼 호출할 수도 있고 this와 같이 식별자처럼 차조할 수 있는 트구한 키워드이다. super는 다음과 같이 동작한다.</p>\n<ul>\n<li>super를 호출하면 수퍼 클래스의 constructor가 호출된다.</li>\n<li>super를 참조하면 수퍼 클래스의 동일 이름 메서드를 참조한다.</li>\n</ul>\n<h3 id=\"421-super-호출\" style=\"position:relative;\"><a href=\"#421-super-%ED%98%B8%EC%B6%9C\" aria-label=\"421 super 호출 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.2.1. super 호출</h3>\n<p>super를 호출하면 <strong>부모 클래스의 constructor를 호출</strong>한다. 클래스를 상속받을 때 생략된 cosntructor는 암묵적으로 super 호출을 통해 부모 클래스의 constructor를 실행시킨다.</p>\n<pre><code class=\"language-js\">class Base {\n  constructor(a, b) {\n    this.a = a\n    this.b = b\n  }\n}\n\nclass Derived extends Base {\n  // 다음과 같은 constructor를 암묵적으로 정의한다.\n  // constructor(...args) { super(...args) }\n}\n\nconst derived = new Derived(1, 2)\nconsole.log(derived) // Derived {a: 1, b: 2}\n</code></pre>\n<p>만일 자식 클래스에도 추가 초기화 과정을 진행하려면 <strong>반드시 super를 호출하여 부모 클래스의 constructor를 실행</strong>시켜야 한다.</p>\n<pre><code class=\"language-js\">class Base {\n  constructor(a, b) {\n    this.a = a\n    this.b = b\n  }\n}\n\nclass Derived extends Base {\n  constructor(a, b, c) {\n    super(a, b)\n    this.c = c\n  }\n}\n\nconst derived = new Derived(1, 2, 3)\nconsole.log(derived) // Derived {a: 1, b: 2, c: 3}\n</code></pre>\n<h3 id=\"422-super-참조\" style=\"position:relative;\"><a href=\"#422-super-%EC%B0%B8%EC%A1%B0\" aria-label=\"422 super 참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.2.2. super 참조</h3>\n<p><strong>메소드 내에서 super를 참조하면 수퍼 클래스의 메소드를 호출할 수 있다.</strong></p>\n<pre><code class=\"language-js\">class Base {\n  constructor(name) {\n    this.name = name\n  }\n\n  sayHi() {\n    return `Hi!, I'm ${this.name}.`\n  }\n}\n\nclass Derived extends Base {\n  greet() {\n    return `${super.sayHi()} Nice to meet you`\n  }\n}\n\nconst derived = new Derived('Lee')\nconsole.log(derived.greet()) // Hi! I'm Lee. Nice to meet you\n</code></pre>\n<h1 id=\"5-참고자료\" style=\"position:relative;\"><a href=\"#5-%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\" aria-label=\"5 참고자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 참고자료</h1>\n<ul>\n<li><a href=\"https://poiemaweb.com/js-prototype\">이웅모: 모던 자바스크립트 Deep Dive, 19장 프로토타입</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%9E%80\">1. 클래스란?</a></p>\n<ul>\n<li><a href=\"#11-%EC%A0%95%EC%9D%98\">1.1. 정의</a></li>\n<li><a href=\"#12-%ED%8A%B9%EC%A7%95\">1.2. 특징</a></li>\n<li><a href=\"#13-%EA%B8%B0%EB%B3%B8-%EC%82%AC%EC%9A%A9%EB%B2%95\">1.3. 기본 사용법</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-%EB%A9%94%EC%86%8C%EB%93%9C\">2. 메소드</a></p>\n<ul>\n<li>\n<p><a href=\"#21-constructor\">2.1. constructor</a></p>\n<ul>\n<li><a href=\"#211-%EC%82%AC%EC%9A%A9\">2.1.1. 사용</a></li>\n<li><a href=\"#212-%ED%8A%B9%EC%A7%95\">2.1.2. 특징</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#22-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EB%A9%94%EC%84%9C%EB%93%9C\">2.2. 프로토타입 메서드</a></p>\n</li>\n<li>\n<p><a href=\"#23-%EC%A0%95%EC%A0%81-%EB%A9%94%EC%84%9C%EB%93%9C\">2.3. 정적 메서드</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\">3. 프로퍼티</a></p>\n<ul>\n<li>\n<p><a href=\"#31-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\">3.1. 인스턴스 프로퍼티</a></p>\n</li>\n<li>\n<p><a href=\"#32-%EC%A0%91%EA%B7%BC%EC%9E%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\">3.2. 접근자 프로퍼티</a></p>\n</li>\n<li>\n<p><a href=\"#33-%ED%81%B4%EB%9E%98%EC%8A%A4-%ED%95%84%EB%93%9C\">3.3. 클래스 필드</a></p>\n<ul>\n<li><a href=\"#331-java\">3.3.1. Java</a></li>\n<li><a href=\"#332-javasript\">3.3.2. JavaSript</a></li>\n<li><a href=\"#333-private-%ED%95%84%EB%93%9C\">3.3.3. private 필드</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#34-%EC%A0%95%EC%A0%81-%ED%95%84%EB%93%9C\">3.4. 정적 필드</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#4-%EC%83%81%EC%86%8D\">4. 상속</a></p>\n<ul>\n<li>\n<p><a href=\"#41-extends\">4.1. extends</a></p>\n</li>\n<li>\n<p><a href=\"#42-super\">4.2. super</a></p>\n<ul>\n<li><a href=\"#421-super-%ED%98%B8%EC%B6%9C\">4.2.1. super 호출</a></li>\n<li><a href=\"#422-super-%EC%B0%B8%EC%A1%B0\">4.2.2. super 참조</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#5-%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\">5. 참고자료</a></p>\n</li>\n</ul>","frontmatter":{"title":"자바스크립트 ES6 class 문법","createdAt":"2023-10-17","updatedAt":"2023-10-17","tags":["JavaScript","자바스크립트","클래스","class","객체지향"],"description":"자바스크립트 class 문법을 정리","reference":null}},"allMarkdownRemark":{"nodes":[{"id":"d213caa5-57cc-5e67-a96c-cfebe6f529f8","excerpt":"1. Intro 1.1. What is JavaScript? 1.2. The History of JavaScript 1.3. Write to HTML Script 1.4. When to Run JS 1.4.1. Synchronous execution…","parent":{"id":"1720b21e-2873-54b9-8fe5-5ec0e54d9d2e","name":"01_JavaScript_Basics","relativePath":"Language/JavaScript/01_JavaScript_Basics.md"},"frontmatter":{"title":"01. JavaScript Basics","createdAt":"2022-10-23","updatedAt":"2023-01-05"},"fields":{"slug":"/posts/Language/JavaScript/01_JavaScript_Basics/"}},{"id":"e1b04b22-c025-5266-a823-8a21c8214924","excerpt":"1. DOM 1.1. Document Object Model 1.2. Special DOM objects 1.3. Handling DOM 1.3.1. Select 1.3.2. Manipulation 2. Event 2.1. Event handler…","parent":{"id":"24abc79b-ec97-585b-8097-7a47a24aca42","name":"02_JavaScript_Advanced","relativePath":"Language/JavaScript/02_JavaScript_Advanced.md"},"frontmatter":{"title":"02. JavaScript DOM and this ","createdAt":"2022-10-24","updatedAt":"2023-01-02"},"fields":{"slug":"/posts/Language/JavaScript/02_JavaScript_Advanced/"}},{"id":"cad56ff3-d893-52b1-a35c-0e1fce4070ba","excerpt":"1. Synchronous and Asynchronous 1.1. Asynchronous JavaScript 1.2. JavaScript Runtime 2. Axios 2.1. The Structure of Axios 2.2. Promise 2.…","parent":{"id":"15ee5a55-2b53-5813-bdea-be1e3c51ae09","name":"03_JavaScript_Asynchronous","relativePath":"Language/JavaScript/03_JavaScript_Asynchronous.md"},"frontmatter":{"title":"03. JavaScript Async","createdAt":"2022-11-01","updatedAt":"2023-01-02"},"fields":{"slug":"/posts/Language/JavaScript/03_JavaScript_Asynchronous/"}},{"id":"0f51505a-6206-5a85-b28e-02b0dae340db","excerpt":"1. Promise 1.1. Promise(executor) 2. Aysnc & Await 2.1. async 2.2. await 2.3. try / catch 3. Example 3.1. Chaining 처리, Hard Code 3.1.…","parent":{"id":"3585fbfd-fa62-5290-a175-1bd09c1dfd3a","name":"Promise_Await","relativePath":"Language/JavaScript/Promise_Await.md"},"frontmatter":{"title":"Promise와 await를 활용하 JS 8가지 비동기 처리","createdAt":"2023-01-02","updatedAt":"2023-01-02"},"fields":{"slug":"/posts/Language/JavaScript/Promise_Await/"}},{"id":"b4de88cf-2fb7-533b-9cc7-ce8c17b8211a","excerpt":"이 글은 드림코딩: 자바스크립드 11 ~ 13 비동기 강의를 듣고 정리한 문서이다. 1. Callback 콜백 함수란, 다른 함수의 매개변수로 전달되어 전달된 함수 내부에서 실행될 수 있는 함수를 말한다. 1.…","parent":{"id":"f2176031-fe05-57f2-9438-3aa69da6a4f7","name":"Promise_Async_2","relativePath":"Language/JavaScript/Promise_Async_2.md"},"frontmatter":{"title":"JavaScript 비동기 처리 Promise & Async","createdAt":"2023-09-07","updatedAt":"2023-09-07"},"fields":{"slug":"/posts/Language/JavaScript/Promise_Async_2/"}},{"id":"f0396719-efaf-5d7c-8544-52108c97d3b3","excerpt":"1. JavaScript 모듈 1.1. 모듈의 부재 JavaScript는 과거 인터넷 브라우저 회사였던, Netscape의 Brendan Eich(브렌던 아이크)에 의해 만들어졌다. 처음에는 Mocha…","parent":{"id":"afba6128-4a8a-524a-a8fe-b7fc2e236d7e","name":"Modules","relativePath":"Language/JavaScript/Modules.md"},"frontmatter":{"title":"JavaScript 모듈 시스템 비교","createdAt":"2023-09-09","updatedAt":"2023-09-09"},"fields":{"slug":"/posts/Language/JavaScript/Modules/"}},{"id":"3c0103d9-947d-584e-b271-b2aa243f3f08","excerpt":"1. 번들러 1.1. 번들러란? 번들러는 여러 자바스크립트 모듈 간의 관계를 분석하여 하나의 자바스크립트 파일로 만드는 도구이다. 반드시 하나의 자바스크립트 파일일 필요는 없고, 원한면 몇 개로 나눌 수도 있다. 이를 코드 스프리팅(Code…","parent":{"id":"ce744717-0985-5344-94de-496d38113237","name":"Webpack_Rollup_Vite","relativePath":"Language/JavaScript/Webpack_Rollup_Vite.md"},"frontmatter":{"title":"Webpack vs Rollup vs Vite 비교 분석","createdAt":"2023-09-10","updatedAt":"2023-09-10"},"fields":{"slug":"/posts/Language/JavaScript/Webpack_Rollup_Vite/"}},{"id":"4d47e063-d4d4-5864-ade9-a8a2d0f1e051","excerpt":"10분 테코톡: 하루의 실행 컨텍스트 영상을 참조해서 작성한 글이다 우테코는 도대체 무슨 짓을 꾸미고 있는 것일까... 여기 테코톡은 매번 볼 때마다 놀랍다. 특히 이번 영상은 감탄마저 나올 정도다👍 1. 실행 컨텍스트 (Execute Context…","parent":{"id":"598fda13-e699-5500-a0d0-5bad07868743","name":"Execute_Context","relativePath":"Language/JavaScript/Execute_Context.md"},"frontmatter":{"title":"실행 컨텍스트로 이해하는 Hoisting, Scope, Closure","createdAt":"2023-09-22","updatedAt":"2023-09-22"},"fields":{"slug":"/posts/Language/JavaScript/Execute_Context/"}},{"id":"b58b9818-4c5e-5467-b86c-efe2f684e298","excerpt":"1. 핵심 내용 브라우저는 HTML, CSS, JS 등 렌더링에 필요한 리소스르르 요청하고 서버로부터 응답받는다. 브라우저 렌더링 엔진이 HTML과 CSS를 파싱하역 각각 DOM과 CSSOM…","parent":{"id":"42b699e3-ea21-552c-b603-8b9b032568f5","name":"Browser_Rendering","relativePath":"Language/JavaScript/Browser_Rendering.md"},"frontmatter":{"title":"브라우저 렌더링 과정","createdAt":"2023-09-23","updatedAt":"2023-09-23"},"fields":{"slug":"/posts/Language/JavaScript/Browser_Rendering/"}},{"id":"c0ad1c54-8714-5e5d-b1d2-7aa89b3d115d","excerpt":"1. this 란? this는 함수가 실행컨텍스트에서 참조하고 있는 객체이다. 따라서 모든 함수는 자신만의 this를 가지고 있다. 문제는 이 this…","parent":{"id":"bb3ac8ea-a2b4-5a78-8914-0bd7a6c5891c","name":"this","relativePath":"Language/JavaScript/this.md"},"frontmatter":{"title":"자바스크립트 this 정복하기","createdAt":"2023-09-24","updatedAt":"2023-09-24"},"fields":{"slug":"/posts/Language/JavaScript/this/"}},{"id":"61ce8ae2-05de-5484-9960-76b1d878106a","excerpt":"1. 생성자 함수 & new 키워드 new 키워드와 생성자 함수를 사용하면 손쉽게 객체를 찍어낼 수 있다. 자바스크립트 버전의 OOP라고 생각할 수 있다. 자바가 객체를 찍어내기 위해 class 키워드를 사용한다면, 자바스크립트는 생성자 함수와 new…","parent":{"id":"7dbfcf53-cb94-5255-aa1d-4181665d88dd","name":"new","relativePath":"Language/JavaScript/new.md"},"frontmatter":{"title":"자바스크립트 생성자 함수 & new 키워드","createdAt":"2023-10-11","updatedAt":"2023-10-11"},"fields":{"slug":"/posts/Language/JavaScript/new/"}},{"id":"722f2b6c-0335-5a25-94e3-44e6a96d9d17","excerpt":"1. 개요 자바스크립트는 프로토타입 기반의 객체 지향 언어이다. ES6부터 클래스형 문법이 도입되었다고 하지만, 이는 \"다른 객체 지향 언어처럼\" 사용하도록 도와주는 API…","parent":{"id":"43f9daad-bb94-5bfb-b40f-e16699d3d50e","name":"prototype","relativePath":"Language/JavaScript/prototype.md"},"frontmatter":{"title":"자바스크립트 Prototype 이해하기","createdAt":"2023-10-12","updatedAt":"2023-10-12"},"fields":{"slug":"/posts/Language/JavaScript/prototype/"}},{"id":"bc3cf8c8-9ffc-5759-8384-1081ab0862e2","excerpt":"1. 클래스란? 1.1. 정의 자바스크립트의 클래스를 흔히 문법적 설탕(synthetic sugar…","parent":{"id":"3c48b83c-3bf7-5dda-9fce-72c29b8107a4","name":"class","relativePath":"Language/JavaScript/class.md"},"frontmatter":{"title":"자바스크립트 ES6 class 문법","createdAt":"2023-10-17","updatedAt":"2023-10-17"},"fields":{"slug":"/posts/Language/JavaScript/class/"}},{"id":"129e1e6c-97e5-54fe-8f18-bdb6f91f4c7c","excerpt":"진짜 가볍게 작성하려고 했는데 이틀이 걸렸다. 자바스크립트의 모든 문제는 결국 this인 것 같다. 1. Proxy Proxy 객체는 자바스크립트 Object에 대한 기본적인 접근(set, get, define…","parent":{"id":"3e2529cd-00c5-57b8-a789-064c412598ec","name":"proxy","relativePath":"Language/JavaScript/proxy.md"},"frontmatter":{"title":"자바스크립트 Proxy & Reflect 객체","createdAt":"2024-03-08","updatedAt":"2024-03-08"},"fields":{"slug":"/posts/Language/JavaScript/proxy/"}}]}},"pageContext":{"pagePath":"/posts/Language/JavaScript/class/","siblingPostsPathRegex":"/^(?!.*README).*Language\\/JavaScript\\/.*$/","relativeDirectory":"JavaScript","id":"bc3cf8c8-9ffc-5759-8384-1081ab0862e2","parent":{"id":"3c48b83c-3bf7-5dda-9fce-72c29b8107a4","name":"class","relativePath":"Language/JavaScript/class.md"},"fields":{"slug":"/posts/Language/JavaScript/class/"}}},"staticQueryHashes":["24302420","4059933791"],"slicesMap":{}}