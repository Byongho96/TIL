{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/Python/04_Python_OOP.md/","result":{"data":{"markdownRemark":{"id":"8d6a29f2-edbf-52da-a629-03cf90a82b84","html":"<h1>Python OOP</h1>\n<h2>Index</h2>\n<ul>\n<li><a href=\"#1-overview\">1. Overview</a>\n<ul>\n<li><a href=\"#11-object-oriented-programming\">1.1. Object Oriented Programming</a></li>\n<li><a href=\"#12-class\">1.2. Class</a></li>\n<li><a href=\"#13-object\">1.3. Object</a></li>\n<li><a href=\"#14-basic-grammer\">1.4. Basic Grammer</a></li>\n<li><a href=\"#15-namespace\">1.5. Namespace</a></li>\n</ul>\n</li>\n<li><a href=\"#2-attributes\">2. Attributes</a>\n<ul>\n<li><a href=\"#21-class-attributes\">2.1. Class Attributes</a></li>\n<li><a href=\"#22-instance-attributes\">2.2. Instance Attributes</a></li>\n</ul>\n</li>\n<li><a href=\"#3-methods\">3. Methods</a>\n<ul>\n<li><a href=\"#31-class-methods\">3.1. Class Methods</a></li>\n<li><a href=\"#32-instance-methods\">3.2. Instance Methods</a></li>\n<li><a href=\"#33-static-methods\">3.3. Static methods</a></li>\n<li><a href=\"#34-decorator\">3.4. Decorator</a></li>\n<li><a href=\"#35-magic-methods-dunder-methods\">3.5. Magic Methods (Dunder Methods)</a></li>\n</ul>\n</li>\n<li><a href=\"#4-inheritence\">4. Inheritence</a>\n<ul>\n<li><a href=\"#41-simple-inheritance\">4.1. Simple Inheritance</a></li>\n<li><a href=\"#42-super__init__\">4.2. super().__init__()</a></li>\n<li><a href=\"#43-supermethod\">4.3. super().method</a></li>\n<li><a href=\"#44-superclass-self\">4.4. super(Class, self)</a></li>\n<li><a href=\"#45-multiple-inheritence\">4.5. Multiple Inheritence</a>\n<ul>\n<li><a href=\"#461-classmro-method-resolution-order\">4.6.1. Class.mro (Method Resolution Order)**</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#5-polymorphism\">5. Polymorphism</a>\n<ul>\n<li><a href=\"#51-override\">5.1. Override</a></li>\n<li><a href=\"#52-overloading\">5.2. Overloading</a></li>\n</ul>\n</li>\n<li><a href=\"#6-encapsulation\">6. Encapsulation</a>\n<ul>\n<li><a href=\"#61-public-member\">6.1. Public member</a></li>\n<li><a href=\"#62-protected-member\">6.2. Protected Member</a></li>\n<li><a href=\"#63-private-member\">6.3. Private Member</a></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1>1. Overview</h1>\n<h2>1.1. Object Oriented Programming</h2>\n<p><strong>Consider programming as a collection of objects which can handle data and communicate with each others</strong></p>\n<ul>\n<li>\n<p><strong>Pros and Cons</strong></p>\n<ul>\n<li><strong>Pros</strong>\n<ul>\n<li>Modularization is suitable for a big project</li>\n<li>Easy to be maintained</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><strong>Cons</strong>\n<ul>\n<li>Hard to be designed at first</li>\n<li>relatively slower than Procedure Oriented Programming</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><strong>Characteristics</strong>\n<ol>\n<li>Abstraction</li>\n<li>Inheritance</li>\n<li>Polymorphism</li>\n<li>Encapsulation</li>\n</ol>\n</li>\n</ul>\n<h2>1.2. Class</h2>\n<p>As a blueprint for an object, a class provides a way to bind attrubutes(data) and methods(functions) together</p>\n<h2>1.3. Object</h2>\n<p>Data uploaded on memory based on the definition of the class</p>\n<h2>1.4. Basic Grammer</h2>\n<ul>\n<li>\n<p><strong>Define a Class</strong></p>\n<pre><code class=\"language-python\">class Person:\r\n    num = 0\r\n    name ='human'\r\n\r\n    @classmethod\r\n    def class_greeting(cls):\r\n        print('hello,', cls.name)\r\n\r\n    def __init__(self, name = 'Kim'):\r\n        Person.num += 1\r\n        self.name = name\r\n\r\n    def greeting(self):\r\n        print('hello,', self.name)\r\n\r\nprint(type(Person)) # &#x3C;class 'type'>\n</code></pre>\n</li>\n<li>\n<p><strong>Make an Instance</strong></p>\n<pre><code class=\"language-python\">person1 = Person()\r\nprint(isinstance(person1, Person))  # True\r\nprint(type(person1))    # &#x3C;class '__main__.Person'>\r\n                        # __main__: describes that class Person is defined in the current module(.py)\n</code></pre>\n</li>\n<li>\n<p><strong>Use attributes</strong></p>\n<pre><code class=\"language-python\"># class attribute\r\nprint(Person.name)    # human\r\n# instance attribute\r\nprint(person1.name)   # Kim\n</code></pre>\n</li>\n<li>\n<p><strong>Call methods</strong></p>\n<pre><code class=\"language-python\"># class method\r\nPerson.class_greeting()     # Hello, human\r\n# instance method\r\nperson1.greeting()          # Hello, Kim\n</code></pre>\n</li>\n</ul>\n<h2>1.5. Namespace</h2>\n<p>Python finds the names in the following order</p>\n<ol>\n<li>instance</li>\n<li>Child Class</li>\n<li>Parent Class</li>\n</ol>\n<hr>\n<h1>2. Attributes</h1>\n<h2>2.1. Class Attributes</h2>\n<p>Class attributes are class variables that are inherited by every object of a class.</p>\n<ul>\n<li>Class attributes are defined outside the __init__() function.</li>\n<li>Class attributes can be added by <code>Class.attribute = initial value</code></li>\n</ul>\n<h2>2.2. Instance Attributes</h2>\n<p>Instance instance attributes arevariables that allow us to define different values for each object(instance) of a class.</p>\n<ul>\n<li>Instance attributes are defined in the __init__() function.</li>\n<li>Instance attributes can be added by <code>instance.attribute = initial value</code></li>\n</ul>\n<pre><code class=\"language-python\">class Person:\r\n    name = 'lee'\r\n\r\n    def __init__(self, name):\r\n        self.name =name\r\n\r\nPerson.age = 21     # Class attributes can be added\r\nprint(Person.name)\r\nprint(Person.age)\r\n\r\nperson1 = Person('Kim')\r\nperson1.age = 23    # Instance attributes can be added\r\nprint(person1.name)\r\nprint(person1.age)\r\n\r\n# 클래스 이름공간(변수, 메소드) 검색\r\nprint(dir(Person))\r\n# 클래스 이름공간(변수, 메소드) 검색\r\nprint(dir(person1.__class__))\r\n# 인스턴스 변수 검색\r\nprint(vars(person1))\n</code></pre>\n<hr>\n<h1>3. Methods</h1>\n<h2>3.1. Class Methods</h2>\n<p><strong>Methods that only uses class variables</strong></p>\n<ul>\n<li>The first parameter should be <code>cls</code> which indciates the class</li>\n<li><code>@classmethod</code> should be used before defining the function, otherwise the <code>cls</code> parameter can't get the class as the argument.</li>\n</ul>\n<pre><code class=\"language-python\">class  Person:\r\n    count=0\r\n    @classmethod\r\n    def number_of_population(cls):\r\n        print(f'the num of population is {cls.count}')\r\n\r\nPerson.number_of_population() # the num of population is 0\n</code></pre>\n<h2>3.2. Instance Methods</h2>\n<p><strong>Methods that can use both class variables and instance variables</strong></p>\n<ul>\n<li>The first parameter must be <code>self</code></li>\n</ul>\n<h2>3.3. Static methods</h2>\n<p><strong>Methods that don't use both class variables and instance variables</strong></p>\n<ul>\n<li><code>@staticmethod</code> should be used before defining the function.</li>\n</ul>\n<pre><code class=\"language-python\">class  Person:\r\n    count=0\r\n    def __init__(self, name):\r\n        self.name = name\r\n        Person.count += 1\r\n\r\n    @staticmehtod\r\n    def check_rich(money):\r\n        return money > 10000\r\n\r\nperson1 = Person('Kim')\r\nprint(Person.check_rich(100000))    # True\r\nprint(person1.check_rich(100000))   # True\n</code></pre>\n<h2>3.4. Decorator</h2>\n<p><strong>The decorator receives the function as an argument, and returns it by adding a specific code to the function.</strong></p>\n<pre><code class=\"language-python\">def hello(name):\r\n    print(\"hello,\", name)\r\n\r\ndef add_print(original):\r\n        print(\"function starts\")\r\n        original(*args)\r\n        print(\"function ends\")\r\n    return wrapper\r\n\r\nadd_print(hello)('James')   # add_print(original()) : means tht add_print is gonna use the return vale of original function\r\n# function starts\r\n# hello\r\n# function ends\r\n\r\n\r\n@add_print\r\ndef print_hello(name):\r\n    print(\"hello,\", name)\r\n\r\nprint_hello('Anna')\r\n# function starts\r\n# hello, Anna\r\n# function ends\n</code></pre>\n<h2>3.5. Magic Methods (Dunder Methods)</h2>\n<p><strong>Magic methods (dunder methods) in Python are the special methods that start and end with the double underscores.</strong><br>\nMagic methods are not meant to be invoked directly by you, but the invocation happens internally from the class on a certain action.</p>\n<ul>\n<li>\n<p><strong>Construtor(__init__)</strong><br>\ncalled when making objects</p>\n<pre><code class=\"language-python\">class Person:\r\n    def __init__(self, name):\r\n        self.name = name\r\n\r\nperson1 = Person('Kim')\r\nprint(person1.name)   # Kim\n</code></pre>\n</li>\n<li>\n<p><strong>Destructor(__del__)</strong>\r\ncalled when deleting objects</p>\n<pre><code class=\"language-python\">class Person:\r\n    def __del__(self):\r\n        print('인스턴스가 사라졌습니다.')\r\n\r\nperson1 = Person()\r\ndel person1           # 인스턴스가 사라졌습니다.\n</code></pre>\n</li>\n<li>\n<p><strong>__add__</strong><br>\nTo get called on add operation using + operator</p>\n<pre><code class=\"language-python\">class Person:\r\n\r\n    def __init__(self, name):\r\n        self.name = name\r\n\r\n    def __add__(self, another):\r\n        return self.name + ' married ' + another.name\r\n\r\nperson1 = Person('Kim')\r\nperson2 = Person('Lee')\r\n\r\nprint(person1 + person2)    # Kim married Lee\n</code></pre>\n</li>\n</ul>\n<hr>\n<h1>4. Inheritence</h1>\n<p><a href=\"https://supermemi.tistory.com/entry/Python-3-super%ED%81%B4%EB%9E%98%EC%8A%A4-selfinit-%EC%97%90-%EB%8C%80%ED%95%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90\">상속과 super()에 대해 정리된 블로그 글</a></p>\n<p>Inheritance allows us to define a class that inherits all the methods and properties from another(parent) class.</p>\n<p><strong>Parent class</strong> is the class being inherited from, also called base class.<br>\n<strong>Child class</strong> is the class that inherits from another class, also called derived class.\r\n<strong>Object</strong> is an ancestor of all classes.</p>\n<pre><code class=\"language-python\">class ChildClass(ParentClass):\r\n\r\nchild = ChildClass()\r\nprint(issubclass(ChildClass, ParentClass))  # True\r\nprint(issubclass(ChildClass, Object))       # True\n</code></pre>\n<h2>4.1. Simple Inheritance</h2>\n<p>Child class can use Parent class's <mark>class instances</mark> and <mark>methods</mark>.</p>\n<pre><code class=\"language-python\">class Human:\r\n    name = 'name'\r\n    age = 'age'\r\n\r\n    def __init__(self):\r\n        self.city = 'city'\r\n\r\n    def show(self):\r\n        print('This is a method of Human class')\r\n\r\nclass Student(Human):\r\n\r\n    def __init__(self, name):\r\n        self.name = name\r\n\r\n    def show_name(self):\r\n        print(self.name)\r\n\r\n    def show_age(self):\r\n        print(self.age)\r\n\r\n    def show_city(self):\r\n        print(self.city)\r\n\r\na = Student('James')\r\na.show()        # This is a method of Human class\r\na.show_name()   # James\r\na.show_age()    # age\r\na.show_city()   # Attrubute Error!\n</code></pre>\n<h2>4.2. super().__init__()</h2>\n<p>To use parent class's <mark>instance attributes</mark> in child class, you need to excute parent class's constructor by using <code>super().__init__()</code>.</p>\n<pre><code class=\"language-python\">class Human:\r\n\r\n    def __init__(self):\r\n        self.name = 'name'\r\n        self.city = 'city'\r\n\r\n    def show(self):\r\n        print('This is a method of Human class')\r\n\r\nclass Student(Human):\r\n\r\n    def __init__(self, name):\r\n        super().__init__()\r\n        self.name = name\r\n\r\n    def show_name(self):\r\n        print(self.name)\r\n\r\n    def show_city(self):\r\n        print(self.city)\r\n\r\na = Student('James')\r\na.show()        # This is a method of Human class\r\na.show_name()   # James\r\na.show_city()   # city\n</code></pre>\n<p><code>super().__init()__</code> simply means that you're using parent class's <code>__init__()</code> method.</p>\n<pre><code class=\"language-python\">class Human:\r\n\r\n    def __init__(self):\r\n        self.name = 'name'\r\n        self.city = 'city'\r\n\r\n    def show(self):\r\n        print('This is a method of Human class')\r\n\r\nclass Student(Human):\r\n\r\n    def __init__(self, name):\r\n        self.name = name\r\n        super().__init__()\r\n\r\n    def show_name(self):\r\n        print(self.name)\r\n\r\na = Student('James')\r\na.show_name()   # name\n</code></pre>\n<h2>4.3. super().method</h2>\n<p>In the same manner as <code>super().__init__()</code>, <strong>you can call parent's method in the child class's method.</strong></p>\n<pre><code class=\"language-python\">class Human:\r\n\r\n    def __init__(self):\r\n        self.name = 'name'\r\n        self.age = 'age'\r\n        self.city = 'city'\r\n\r\n    def show_everything(self):\r\n        print(self.name, self.age, self.city)\r\n\r\nclass Student(Human):\r\n\r\n    def __init__(self):\r\n        super().__init__()\r\n\r\n    def introduce(self):\r\n        print('Let me introduce myself')\r\n        super.show_everything()\r\n\r\na = Student()\r\na.introduce()   # Let me introduce myself\r\n                # name age city\n</code></pre>\n<h2>4.4. super(Class, self)</h2>\n<p>By using <code>super(Class, self)</code>, you can <mark>specify which class of parent's method</mark> to use.</p>\n<pre><code class=\"language-python\">class A:\r\n    def __init__(self):\r\n        self.a = 10\r\n\r\n    def get_a(self):\r\n        return self.a\r\n\r\nclass B(A):\r\n    def __init__(self):\r\n        super(B, self).__init__()\r\n        self.b = 20\r\n\r\n    def get_b(self):\r\n        return self.b\r\n\r\nclass C(B):\r\n    def __init__(self):\r\n        super(B, self).__init__()\r\n        self.c = 30\r\n\r\n    def get_c(self):\r\n        return self.c\r\n\r\nnew_c = C()\r\nprint(new_c.get_a())    # 10\r\nprint(new_c.get_c())    # 30\r\nprint(new_c.get_b())    # AttributeError\r\n                        # B.__init__() has not excuted!\n</code></pre>\n<h2>4.5. Multiple Inheritence</h2>\n<p>Python supports multiple inheritance.<br>\nIf there are multiple parents, Pyhton searches <strong>the namespace in the order in which the class are received.</strong></p>\n<pre><code class=\"language-python\">class Person:\r\n    def __init__(self, name):\r\n        self.name = name\r\n    def greeting(self):\r\n        return f'Hi, {self.name}'\r\n\r\nclass Mom(Person):\r\n    gene = 'XX'\r\n\r\n    def swim(self):\r\n        return 'Mom\\'s Swimming'\r\n\r\nclass Dad(Person):\r\n    gene = 'XY'\r\n\r\n    def walk(self):\r\n        return 'Dad\\'s walking'\r\n\r\nclass Child(Mom, Dad):\r\n    def swim(self):\r\n        return 'A child\\'s swimming'\r\n    def cry(self):\r\n        return 'A child\\'s crying'\r\n\r\nbaby1 = FirstChild('Lee')\r\nprint(baby1.cry())  # A child's crying\r\nprint(baby1.swim()) # A child's swimming\r\nprint(baby1.walk()) # Dad's walking\r\nprint(baby1.gene()) # XX    &#x3C;&#x3C;&#x3C;     since (Mom, Dad)\n</code></pre>\n<h3>4.6.1. Class.mro (Method Resolution Order)**</h3>\n<p>mro method shows all the parent classes(including self) in method resolution order.</p>\n<pre><code class=\"language-python\">print(FirstChild.mro())\r\n#[&#x3C;class '__main__.FirstChild'>, &#x3C;class '__main__.Mom'>, &#x3C;class '__main__.Dad'>, &#x3C;class '__main__.Person'>, &#x3C;class 'Object'>]\n</code></pre>\n<hr>\n<h1>5. Polymorphism</h1>\n<p>The same name of method can work differently according to classes.</p>\n<h2>5.1. Override</h2>\n<p><strong>Redefine a inherited mehtod in child class.</strong></p>\n<pre><code class=\"language-python\">class Person:\r\n    def __init__(self, name):\r\n        self.name = name\r\n\r\n    def talk(self):\r\n        print(f'Hi, I\\'m {self.name}')\r\n\r\nclass Professor(Person):\r\n    def talk(self):\r\n        print(f'Hi, I\\'m professor {self.name}')\r\n\r\nclass Student(Person):\r\n    def talk(self):\r\n        super().talk()\r\n        print(f'Hi, I\\'m a student')\r\n\r\n\r\np1 = Professor('Kim')\r\np1.talk()   # Hi, I'm professor Kim\r\n\r\ns1 = Student('Lee')\r\ns1.talk()   # Hi, I'm Lee\r\n            # Hi, I'm a student\n</code></pre>\n<h2>5.2. Overloading</h2>\n<p>Overloading refers to the ability to use a single identifier to define multiple methods of a class that differ in their input and output parameters.</p>\n<p>Python does not support overloading officially because <strong>Python can transfer multiple variables as one object(tuple)</strong></p>\n<hr>\n<h1>6. Encapsulation</h1>\n<p>Encapsulation refers to <strong>limiting access to certain class attributes.</strong></p>\n<h2>6.1. Public member</h2>\n<ul>\n<li>Public memebers can be accessed from everywhere</li>\n<li>All members of a class are by default public in Python.</li>\n</ul>\n<h2>6.2. Protected Member</h2>\n<ul>\n<li>\n<p>Protected members of a class can be accessed from <strong>the class and its subclasses.</strong></p>\n</li>\n<li>\n<p>In fact, protected memebers <mark>still can be accessed and modified outside of the classes.</mark> It's just a protocol between developers.</p>\n</li>\n<li>\n<p>Can be declared by adding a prefix '_'</p>\n<pre><code class=\"language-python\">class Student:\r\n    _schoolName = 'XYZ School'\r\n\r\n    def __init__(self, name, age):\r\n        self._name=name\r\n        self._age=age\r\n\r\nstd = Student('Kim', 25)\r\nprint(std._name)    # Kim\r\n\r\nstd._name = 'Lee'\r\nprint(std._name)    # Lee\n</code></pre>\n</li>\n<li>\n<p>You can use decorators to protected members.</p>\n</li>\n<li>\n<p>However, it is still accessible in Python.</p>\n<pre><code class=\"language-python\">class Student:\r\n    def __init__(self,name):\r\n        self._name = name\r\n\r\n    @property\r\n    def name(self):\r\n        return self._name\r\n\r\n    @name.setter\r\n    def name(self,name):\r\n        if isinstance(name, str):\r\n            raise TypeError\r\n        self._name = name\r\n\r\nstd = Student('Kim')\r\nprint(std.name)     # Kim\r\n\r\nstd.name = 'Lee'\r\nprint(std.name)     # Lee\r\n\r\nprint(std._name)    # Lee / still accessible\r\n\r\nstd.name = 1        # TypeError\r\nprint(std.name)\n</code></pre>\n</li>\n</ul>\n<h2>6.3. Private Member</h2>\n<ul>\n<li>Private members of a class can only be accessed from <strong>the class.</strong> Any attempt to do so will result in an <strong>AttributeError</strong>.</li>\n<li>Can be declared by adding a prefix '__'</li>\n</ul>\n<pre><code class=\"language-python\">class Student:\r\n    __schoolName = 'XYZ School'\r\n\r\n    def __init__(self, name, age):\r\n        self.__name = name\r\n        self.__age = age\r\n\r\n    def __show(self):\r\n\t    print('This is private method.')\r\n\r\nstd = Student(\"Kim\", 25)\r\nprint(std.__schoolName)     # AttributeError\r\nprint(std.__name)           # AttributeError\r\nprint(std.__show())         # AttributeError\n</code></pre>\n<ul>\n<li>Private memebers be changed to <code>object._class__variable</code>.</li>\n<li>But the practice should be refrained.</li>\n</ul>\n<pre><code class=\"language-python\">std = Student(\"Bill\", 25)\r\nprint(std._Student__name)   # Bill\r\n\r\nstd._Student__name = 'Steve'\r\nprint(std._Student__name)   # Steve\r\n\r\nstd._Student__display()     # This is private method.\n</code></pre>\n<ul>\n<li>For accessing and modifying the private members, using decorators is reocmmended.</li>\n</ul>\n<pre><code class=\"language-python\">class Student:\r\n\r\n    def __init__(self, name, age):\r\n        self.__name = name\r\n        self.__age = age\r\n\r\n    @property\r\n    def age(self):\r\n        return self.__age\r\n\r\n    @age.setter\r\n    def age(self, new_age):\r\n        if new_age &#x3C; 0:\r\n            raise ValueError(\"invaild range\")\r\n        self.__age = new_age\r\n\r\nstd = Student(\"Bill\", 25)\r\nprint(std.age)              # 25\r\n\r\nstd.age = 11\r\nprint(std.age)              # 11\r\n\r\nstd.age = -1                # ValueError\r\nprint(std.age)\n</code></pre>"}},"pageContext":{"pagePath":"posts/Python/04_Python_OOP.md","id":"8d6a29f2-edbf-52da-a629-03cf90a82b84","parent":{"id":"99eb2c30-a4df-5f8b-9f6f-a55c3a838759","name":"04_Python_OOP","relativePath":"Python/04_Python_OOP.md"}}},"staticQueryHashes":["1274812890","3935499650","82772122"],"slicesMap":{}}