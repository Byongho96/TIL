{"componentChunkName":"component---src-templates-post-index-tsx","path":"/posts/Knowledge/Design Pattern/observer_pattern/","result":{"data":{"markdownRemark":{"id":"465052b6-fc99-5407-a407-8003e014023c","html":"<h1 id=\"1-옵저버-패턴\" style=\"position:relative;\"><a href=\"#1-%EC%98%B5%EC%A0%80%EB%B2%84-%ED%8C%A8%ED%84%B4\" aria-label=\"1 옵저버 패턴 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 옵저버 패턴</h1>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; margin-bottom: 20px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/TIL/static/7234fe5abbc0a5e696b7b2bc78b291da/2bef9/observer-pattern-structure.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.14285714285714%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACQklEQVR42nVT+08TQRDm/098JIpGjDGgBo2Ue7ZCQaSBAj8Qc0IgGk1L77DXe9C93t3u3u7t3JirLSkYf/gyk9ndbx7f7BIiGlxy2yduOyBeO5h4UyuVtBDRvAcDEfV7uHO+hIhaL/zeXe08KBonL9mH7nO+1nnMfOLtzx7cEjOR2dc3/W2fuNtDcrU9It4WANxJWhNuIuKJlBLDKKyiOELGWYWIHUTckFKanHMbATWnf+S8OXyEH49W1LuDJ9X742VOi3RrsdI54RGlTLquV7iuK7I85zXhaDTaI4S0GWN2nudmURRdKaUXR/FVMpkMyrL8BQCtukoAsOaEBgA0AdWuUnJXCvEZAXYAVMv3/eOiKHZmszMRwFBKanmeTS2A0hD/bblmN5lQZsaEmWTM4kJNByyE0AHQyJiwkoxbJKX2OKEtIaTNhaj9ZkyyJmXSYlzeVqj9GIwPH66f5q+ss/SF9i17uH6a9v1kX4lcv/KTzrMNp1htnrPX9jl9uuGIYZzvHTrXZ8sNp3y7dZGvaE6x9ukiklLZ0xkyASf9UY6XvaC67IX40xtXGS0OOGObhZBfYpLfeMMw6g+GUZzkYyHULmXFaTTOSG/wO7z2oxuSUhcA7AWVBQYjvwoDHxmjc5UbMwUbSgpdKanPYvN9bHDODPgb1+Yt61VVdTnnPI5jGkUxY4zRsiz3J5NJOwiCr2matrMss5MkaVFKm4uoY0ope7av1tKMWZdS6rUINWofAHSllFlfrndRKWX8Dwu/RvsDICMU/b5msxoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/TIL/static/7234fe5abbc0a5e696b7b2bc78b291da/c54d4/observer-pattern-structure.webp 175w,\n/TIL/static/7234fe5abbc0a5e696b7b2bc78b291da/a3432/observer-pattern-structure.webp 350w,\n/TIL/static/7234fe5abbc0a5e696b7b2bc78b291da/426ac/observer-pattern-structure.webp 700w,\n/TIL/static/7234fe5abbc0a5e696b7b2bc78b291da/a9a89/observer-pattern-structure.webp 1024w\"\n              sizes=\"(max-width: 700px) 100vw, 700px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/TIL/static/7234fe5abbc0a5e696b7b2bc78b291da/4edbd/observer-pattern-structure.png 175w,\n/TIL/static/7234fe5abbc0a5e696b7b2bc78b291da/13ae7/observer-pattern-structure.png 350w,\n/TIL/static/7234fe5abbc0a5e696b7b2bc78b291da/8c557/observer-pattern-structure.png 700w,\n/TIL/static/7234fe5abbc0a5e696b7b2bc78b291da/2bef9/observer-pattern-structure.png 1024w\"\n            sizes=\"(max-width: 700px) 100vw, 700px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/TIL/static/7234fe5abbc0a5e696b7b2bc78b291da/8c557/observer-pattern-structure.png\"\n            alt=\"옵저버 디자인 패턴 구조\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>옵저버 패턴은 구조는 위와 같다. 아주 직관적이다. 발행자가 Observer(관측자)를 모아 관리하고, 이벤트가 발생할 때마다 Observer에게 알려준다.</p>\n<p>알려주는 방법도 간단하다. 미리 약속된 함수 이름(<code>update</code>)를 정의하고, 실제 로직은 Observer측에서 구현한다. 발행자를 이를 단순히 실행시킨다.</p>\n<h1 id=\"2-옵저버-패턴-구현-with-typescript\" style=\"position:relative;\"><a href=\"#2-%EC%98%B5%EC%A0%80%EB%B2%84-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84-with-typescript\" aria-label=\"2 옵저버 패턴 구현 with typescript permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 옵저버 패턴 구현 with TypeScript</h1>\n<h2 id=\"21-구독자-subscriber\" style=\"position:relative;\"><a href=\"#21-%EA%B5%AC%EB%8F%85%EC%9E%90-subscriber\" aria-label=\"21 구독자 subscriber permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. 구독자 (Subscriber)</h2>\n<pre><code class=\"language-js\">// 인터페이스\nexport interface IObserver {\n  update: () => void;\n}\n\n// 구현체 1\nexport class ObserverA implements IObserver {\n  update() {\n    console.log('Observer A 한테 이벤트 알림이 왔습니다.')\n  }\n\n  toString() {\n    return 'Observer A'\n  }\n}\n\n// 구현체 2\nexport class ObserverB implements IObserver {\n  update() {\n    console.log('ObserverB 한테 이벤트 알림이 왔습니다.')\n  }\n\n  toString() {\n    return 'Observer B'\n  }\n}\n</code></pre>\n<h2 id=\"22-발행자-publisher\" style=\"position:relative;\"><a href=\"#22-%EB%B0%9C%ED%96%89%EC%9E%90-publisher\" aria-label=\"22 발행자 publisher permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2. 발행자 (Publisher)</h2>\n<pre><code class=\"language-js\">import { IObserver } from './observer'\n\n// 인터페이스\ninterface IPublisher {\n  registerObserver: (o: IObserver) => void\n  removeObserver: (o: IObserver) => void\n  notifyObservers: () => void\n}\n\n// 구현체\nexport class Publisher implements IPublisher {\n  observers: IObserver[] = []  // 관찰자 리스트\n\n  // 관찰자 등록\n  registerObserver(o: IObserver) {\n    this.observers.push(o)\n    console.log(o + ' 구독 완료')\n  }\n\n  // 관찰자 제거\n  removeObserver(o: IObserver) {\n    for (let i = 0; i &#x3C; this.observers.length; i++) {\n      if (this.observers[i] === o) {\n        this.observers.splice(i, 1)\n        i--\n      }\n    }\n    console.log(o + ' 구독 취소')\n  }\n\n  // 관찰자 알림\n  notifyObservers() {\n    this.observers.forEach((o) => {\n      o.update()\n    })\n  }\n}\n\n</code></pre>\n<h2 id=\"21-사용-예시\" style=\"position:relative;\"><a href=\"#21-%EC%82%AC%EC%9A%A9-%EC%98%88%EC%8B%9C\" aria-label=\"21 사용 예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. 사용 예시</h2>\n<p><code>PublisherManager</code>는 반드시 필요하지는 않다. 나는 앞서 구현한 <code>Publisher</code>에 대해 <strong>하나의 객체를 생성 및 관리</strong>하고 싶어 <code>Manager</code>를 생성했다.</p>\n<pre><code class=\"language-ts\">import { IObserver } from './observer.ts'\nimport { Publisher } from './subject.ts'\n\nexport class PublisherManager {\n  static publisher = new Publisher() // 하나의 Publisher 객체 관리\n\n  // 새 이벤트 발생\n  static addEvent(e: string) {\n    console.log(`${e} 발생`)\n    PublisherManager.publisher.notifyObservers()\n  }\n\n  // 구독\n  static subscribe(o: IObserver) {\n    PublisherManager.publisher.registerObserver(o)\n  }\n\n  // 구독 취소\n  static unsubscribe(o: IObserver) {\n    PublisherManager.publisher.removeObserver(o)\n  }\n}\n</code></pre>\n<p>아래와 같은 코드를 실행시키면, 콘솔 결과를 통해 예상처럼 동작함을 확인할 수 있다.</p>\n<pre><code class=\"language-ts\">import { PublisherManager } from './manager.ts'\nimport { ObserverA, ObserverB } from './observer.ts'\n\nconst observerA = new ObserverA()\nconst observerB = new ObserverB()\n\nPublisherManager.subscribe(observerA)\nPublisherManager.subscribe(observerB)\nPublisherManager.addEvent('이벤트 1')\n\nPublisherManager.unsubscribe(observerA)\nPublisherManager.addEvent('이벤트 2')\n\nPublisherManager.unsubscribe(observerB)\nPublisherManager.addEvent('이벤트 3')\n</code></pre>\n<pre><code class=\"language-bash\"># typscript 파일을 바로 실행시키려면, ts-node를 사용해야 한다.\nnpx ts-node { ts 파일 }\n</code></pre>\n<pre><code class=\"language-bash\">Observer A 구독 완료\nObserver B 구독 완료\n이벤트 1 발생\nObserver A 한테 이벤트 알림이 왔습니다.\nObserverB 한테 이벤트 알림이 왔습니다.\nObserver A 구독 취소\n이벤트 2 발생\nObserverB 한테 이벤트 알림이 왔습니다.\nObserver B 구독 취소\n이벤트 3 발생\n</code></pre>\n<h1 id=\"3-옵저버-패턴-활용-react\" style=\"position:relative;\"><a href=\"#3-%EC%98%B5%EC%A0%80%EB%B2%84-%ED%8C%A8%ED%84%B4-%ED%99%9C%EC%9A%A9-react\" aria-label=\"3 옵저버 패턴 활용 react permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 옵저버 패턴 활용 (React)</h1>\n<p>팀원 중 한 분이 토스트 메시지를 옵저버 패턴을 구현했다. 내가 평소 구현하는 방식과 달라서 처음 이해하는데 애를 먹었다. 옵저버 패턴으로 토스트0 메시지를 구현하니까, 비즈니스 로직과 UI와 완전히 구분되었다.</p>\n<h2 id=\"31-함수형-react\" style=\"position:relative;\"><a href=\"#31-%ED%95%A8%EC%88%98%ED%98%95-react\" aria-label=\"31 함수형 react permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1. 함수형 React</h2>\n<p>익숙한 함수형 React 구현 방식부터 알아보자. 익숙하지만 함수형이기 때문에 옵저버 패턴이 명확하게 보이지 않는다.</p>\n<h3 id=\"311-array-프로토타입-메소드-추가\" style=\"position:relative;\"><a href=\"#311-array-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%B6%94%EA%B0%80\" aria-label=\"311 array 프로토타입 메소드 추가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1.1. Array 프로토타입 메소드 추가</h3>\n<p>시작하기 앞서 <code>Array.__proto__</code>에 메소드 하나만 추가하려고 한다. 그냥 array에서 특정 요소를 제거하는 로직인데, 이후 작성할 코드들의 간결성을 위해 <strong>간이적으로 추가</strong>했다.</p>\n<pre><code class=\"language-ts\">// Array에서 element 요소를 찾아 제거하는 메소드\nArray.prototype.removeElement = function &#x3C;T>(this: T[], element: T): void {\n  for (let i = 0; i &#x3C; this.length; i++) {\n    if (this[i] === element) {\n      this.splice(i, 1)\n      i--\n    }\n  }\n}\n</code></pre>\n<h3 id=\"312-usetoast-구현\" style=\"position:relative;\"><a href=\"#312-usetoast-%EA%B5%AC%ED%98%84\" aria-label=\"312 usetoast 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1.2. useToast 구현</h3>\n<p>옵저버 패턴은 최종적으로 함수형 React에서 쓸 수 있는 커스텀 훅으로 구현된다. 훅은 컴포넌트에서 쓰이기 때문에, 관찰자(Observer)측의 구현체이다.</p>\n<pre><code class=\"language-ts\">// 타입 정의\ntype TToast = {\n  id: string\n  message: string\n}\n\nconst observers: (() => void)[] = [] // 관찰자 알림 함수 리스트\nconst toasts: TToast[] = [] // 토스트 메시지 리스트\n\n// 토스트 메시지 추가\nfunction addToast(message: string) {\n  const newToast = {\n    id: new Date().toDateString(),\n    message,\n  }\n  toasts.push(newToast)\n  notifyObservers()\n\n  // 3초 후 자동 삭제\n  setTimeout(() => {\n    deleteToast(newToast)\n  }, 3000)\n}\n\n// 토스트 메시지 삭제\nfunction deleteToast(toast: TToast) {\n  toasts.removeElement(toast)\n  notifyObservers()\n}\n\n// 관찰자들에게 알림\nfunction notifyObservers() {\n  observers.forEach((update) => update())\n}\n\n// 커스텀 훅\nexport default function useToast() {\n  const [_, forceUpdate] = useState({})\n\n  useEffect(() => {\n    const curUpdate = () => forceUpdate({}) // 현재 컴포넌트 강제 업데이트 함수 생성\n    observers.push(curUpdate) // 구독\n\n    return () => {\n      observers.removeElement(curUpdate) // 구독 취소\n    }\n  }, [])\n\n  return { toasts, addToast }\n}\n</code></pre>\n<h3 id=\"313-실제-사용\" style=\"position:relative;\"><a href=\"#313-%EC%8B%A4%EC%A0%9C-%EC%82%AC%EC%9A%A9\" aria-label=\"313 실제 사용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1.3. 실제 사용</h3>\n<p>아래와 같이 <code>useToast</code> 훅을 컴포넌트에서 사용할 수 있다.</p>\n<pre><code class=\"language-tsx\">import { FormEventHandler } from 'react'\nimport useToast from './useToast'\n\nfunction ToastContainer() {\n  // 커스텀 훅\n  const { toasts, addToast } = useToast()\n\n  const handleSubmit: FormEventHandler&#x3C;HTMLFormElement> = (e) => {\n    e.preventDefault()\n    e.stopPropagation()\n\n    // form 태그 내에서 메시지 정보 추출\n    const form = e.currentTarget\n    const formData = new FormData(form)\n    const message = formData.get('message') as string\n\n    // 이벤트 발생\n    addToast(message)\n  }\n\n  return (\n    &#x3C;div>\n      &#x3C;ul>\n        {toasts.map((toast) => (\n          &#x3C;li key={toast.id}>{toast.message}&#x3C;/li>\n        ))}\n      &#x3C;/ul>\n      &#x3C;form onSubmit={handleSubmit}>\n        &#x3C;input name=\"message\" />\n        &#x3C;button type=\"submit\">토스트 추가&#x3C;/button>\n      &#x3C;/form>\n    &#x3C;/div>\n  )\n}\n\nexport default ToastContainer\n</code></pre>\n<p><img src=\"/TIL/168d0b04b014eef1732d1d6d625f28b5/function-toast.gif\" alt=\"함수형 옵저버 패턴 토스트 메시지 시연\"></p>\n<h2 id=\"32-클래스형-react\" style=\"position:relative;\"><a href=\"#32-%ED%81%B4%EB%9E%98%EC%8A%A4%ED%98%95-react\" aria-label=\"32 클래스형 react permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2. 클래스형 React</h2>\n<p>클래스형 React로 구현할 경우, 옵저버 패턴을 더 명확하게 확인할 수 있다.</p>\n<h3 id=\"321-array-프로토타입-메소드-추가\" style=\"position:relative;\"><a href=\"#321-array-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%B6%94%EA%B0%80\" aria-label=\"321 array 프로토타입 메소드 추가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2.1. Array 프로토타입 메소드 추가</h3>\n<p>마찬가지로 이후 작성할 코드들의 간결성을 위해 <code>Array.__proto__</code>에 메소드 하나를 <strong>간이적으로 추가</strong>했다.</p>\n<pre><code class=\"language-ts\">// Array에서 element 요소를 찾아 제거하는 메소드\nArray.prototype.removeElement = function &#x3C;T>(this: T[], element: T): void {\n  for (let i = 0; i &#x3C; this.length; i++) {\n    if (this[i] === element) {\n      this.splice(i, 1)\n      i--\n    }\n  }\n}\n</code></pre>\n<h3 id=\"321-발행자-publisher-구현\" style=\"position:relative;\"><a href=\"#321-%EB%B0%9C%ED%96%89%EC%9E%90-publisher-%EA%B5%AC%ED%98%84\" aria-label=\"321 발행자 publisher 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2.1. 발행자 (Publisher) 구현</h3>\n<p>이번에는 마지막에 단일 객체를 생성해서 export 하였기 때문에, 2.1.절처럼 <code>Manager</code>클래스를 구현하지 않았다.</p>\n<p>또한 <strong>리액트 컴포넌트 자체</strong>를 관찰자 리스트(<code>observers</code>)로 수집했다. 토스트 메시지 리스트(<code>toasts</code>)에 변화가 생기면 컴포넌트 프로토타입의 <code>forceUpdate</code> 메소드를 호출하여 강제 업데이트 했다.</p>\n<pre><code class=\"language-ts\">import { Component } from 'react'\n\n// 타입 정의\nexport type TToast = {\n  id: string\n  message: string\n}\n\n// 발행자 인터페이스\ninterface IPublisher&#x3C;T> {\n  registerObserver: (o: T) => void\n  removeObserver: (o: T) => void\n  notifyObservers: () => void\n}\n\n// 발행자 구현체\nclass ToastPublihser implements IPublisher&#x3C;Component> {\n  observers: Component[] = [] // 관찰하는 React 컴포넌트 리스트\n  toasts: TToast[] = []\n\n  // 토스트 메시지 추가\n  addToast(message: string) {\n    const newToast = {\n      id: new Date().toDateString(),\n      message,\n    }\n    this.toasts.push(newToast)\n    this.notifyObservers()\n\n    // 3초 후 삭제\n    setTimeout(() => {\n      this.deleteToast(newToast)\n    }, 3000)\n  }\n\n  // 토스트 메시지 삭제\n  deleteToast(toast: TToast) {\n    this.toasts.removeElement(toast)\n    this.notifyObservers()\n  }\n\n  // 구독자 등록\n  registerObserver(component: Component) {\n    this.observers.push(component)\n  }\n\n  // 구독자 제거\n  removeObserver(component: Component) {\n    this.observers.removeElement(component)\n  }\n\n  // 구독자들에게 알림\n  notifyObservers() {\n    this.observers.forEach((component) => component.forceUpdate())\n  }\n}\n\nexport default new ToastPublihser() // 단일 객체 export\n</code></pre>\n<h3 id=\"322-실제-사용\" style=\"position:relative;\"><a href=\"#322-%EC%8B%A4%EC%A0%9C-%EC%82%AC%EC%9A%A9\" aria-label=\"322 실제 사용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2.2. 실제 사용</h3>\n<p>컴포넌트 측에서는 아래와 같이 사용할 수 있다.</p>\n<pre><code class=\"language-tsx\">import { Component, FormEvent } from 'react'\nimport ToastPublisher, { TToast } from './ToastPublisher'\n\nclass ToastContainer extends Component {\n  state: {\n    toasts: TToast[]\n  }\n\n  constructor(props: {} | Readonly&#x3C;{}>) {\n    super(props)\n    this.state = {\n      toasts: ToastPublisher.toasts,\n    }\n  }\n\n  componentDidMount(): void {\n    ToastPublisher.registerObserver(this) // 토스트 메시지 구독\n  }\n\n  componentWillUnmount(): void {\n    ToastPublisher.removeObserver(this) // 토스트 메시지 구독 취소\n  }\n\n  handleSubmit(e: FormEvent&#x3C;HTMLFormElement>) {\n    e.preventDefault()\n    e.stopPropagation()\n\n    // form 태그 내에서 메시지 데이터 추출\n    const form = e.currentTarget\n    const formData = new FormData(form)\n    const message = formData.get('message') as string\n\n    // 토스트 메시지 추가\n    ToastPublisher.addToast(message)\n  }\n\n  render() {\n    return (\n      &#x3C;div>\n        &#x3C;ul>\n          {this.state.toasts.map((toast) => (\n            &#x3C;li key={toast.id}>{toast.message}&#x3C;/li>\n          ))}\n        &#x3C;/ul>\n        &#x3C;form onSubmit={this.handleSubmit}>\n          &#x3C;input name=\"message\" />\n          &#x3C;button type=\"submit\">토스트 추가&#x3C;/button>\n        &#x3C;/form>\n      &#x3C;/div>\n    )\n  }\n}\n\nexport default ToastContainer\n</code></pre>\n<p><img src=\"/TIL/4db8de3ad22a2bc0bea63108e46c6fa6/class-toast.gif\" alt=\"클래스형 옵저버 패턴 토스트 메시지 시연\"></p>\n<h1 id=\"4-다른-토스트-메시지-구현-방식\" style=\"position:relative;\"><a href=\"#4-%EB%8B%A4%EB%A5%B8-%ED%86%A0%EC%8A%A4%ED%8A%B8-%EB%A9%94%EC%8B%9C%EC%A7%80-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9D\" aria-label=\"4 다른 토스트 메시지 구현 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 다른 토스트 메시지 구현 방식</h1>\n<p>아래는 평소 내가 사용하는 토스트 메시지 구현 방식이다. 더 직관적이지만 로직과 UI가 강하게 결합된다는 한계점이 존재한다. 그러나 토스트 메시지의 로직과 UI가 분리되는 경우는 보지 못했기 때문에, 실질적으로 한계점이라고 느낀 적은 없다.</p>\n<h2 id=\"41-toast-컴포넌트\" style=\"position:relative;\"><a href=\"#41-toast-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\" aria-label=\"41 toast 컴포넌트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.1. Toast 컴포넌트</h2>\n<p>먼저 Toast 메시지 컴포넌트를 생성한다. 이후 설계할 <code>ToastManger</code>에서 이 컴포넌트를 직접 <code>import</code>하여 사용할 것이다.</p>\n<pre><code class=\"language-tsx\">import { useRef, useEffect, useMemo } from 'react'\nimport InfoIcon from '@/assets/svgs/lighthouse.svg'\nimport SuccessIcon from '@/assets/svgs/sail.svg'\nimport ErrorIcon from '@/assets/svgs/wreck.svg'\nimport './Toast.scss'\n\nexport type ToastProps = {\n  type: 'success' | 'error' | 'info'\n  message: string\n  destroy: () => void\n  duration?: number\n}\n\nconst Toast = ({ type, message, destroy, duration = 3000 }: ToastProps) => {\n  // type에 대응하는 아이콘 선택\n  const icon = useMemo(() => {\n    return {\n      success: &#x3C;SuccessIcon />,\n      error: &#x3C;ErrorIcon />,\n      info: &#x3C;InfoIcon />,\n    }[type]\n  }, [type])\n\n  // duration 이후 자동 삭제\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      destroy()\n    }, duration)\n\n    return () => {\n      clearTimeout(timer)\n    }\n  }, [])\n\n  return (\n    &#x3C;div className={`toast ${type}`} onClick={destroy}>\n      &#x3C;div className=\"toast__message\">\n        {icon}\n        &#x3C;p aria-live=\"assertive\">{message}&#x3C;/p>\n      &#x3C;/div>\n      &#x3C;div className=\"toast__progress\" ref={progressRef} />\n    &#x3C;/div>\n  )\n}\n\nexport default Toast\n</code></pre>\n<h2 id=\"42-toastmanager-클래스\" style=\"position:relative;\"><a href=\"#42-toastmanager-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"42 toastmanager 클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.2. ToastManager 클래스</h2>\n<pre><code class=\"language-tsx\">import React from 'react'\nimport { Root, createRoot } from 'react-dom/client'\nimport Toast from '@/atoms/ui/Toast'\nimport { ToastProps } from '@/atoms/ui/Toast/Toast'\nimport './toastManager.scss'\n\ntype ToastOption = ToastProps &#x26; {\n  id?: number\n}\n\nclass ToastManager {\n  private container: Root\n  private toasts: ToastOption[] = [] // 토스트 메시지 리스트\n\n  /**\n   * 토스트 메시지를 렌더링할 DOM을 지정한다.\n   * 프로젝트의 다른 컴포넌트와 다른 위치에서 렌더링하기 위함이다.\n   * 미리 html에 id=\"toast\"인 요소가 존재해야 한다.\n   */\n  constructor() {\n    this.container = createRoot(document.getElementById('toast')!)\n  }\n\n  // 토스트 메시지 추가\n  addToast(\n    type: 'error' | 'success' | 'info',\n    message: string,\n    duration: number = 3000\n  ) {\n    const id = Date.now()\n    this.toasts.push({\n      id,\n      type,\n      message,\n      duration,\n      destroy: () => this.deleteToast(id),\n    })\n    this.render()\n  }\n\n  // 토스트 메시지 삭제\n  deleteToast(id: number) {\n    this.toasts = this.toasts.filter((toast) => toast.id !== id)\n    this.render()\n  }\n\n  // 토스트 메시지 렌더링\n  private render(): void {\n    const toastsList = this.toasts.map((toast) => (\n      &#x3C;Toast key={toast.id} {...toast} />\n    ))\n    this.container.render(toastsList)\n  }\n}\n\nexport default new ToastManager()\n</code></pre>\n<h2 id=\"42-실제-사용\" style=\"position:relative;\"><a href=\"#42-%EC%8B%A4%EC%A0%9C-%EC%82%AC%EC%9A%A9\" aria-label=\"42 실제 사용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.2. 실제 사용</h2>\n<p>컴포넌트에서 <code>ToastManager</code>를 아래와 같은 방식으로 사용할 수 있다.</p>\n<pre><code class=\"language-tsx\">import toastManager from '@/utils/toastManager'\n\ntype GalleryFormProps = {\n  onSuccess?: () => void\n  onError?: () => void\n}\n\nconst GalleryCreateForm = ({ onSuccess, onError }: GalleryFormProps) => {\n  ...\n\n  const handleSubmit = (e: React.FormEvent&#x3C;HTMLFormElement>) => {\n    e.preventDefault()\n    e.stopPropagation()\n\n    const form = e.currentTarget\n    const formData = new FormData(form)\n\n    // 유효성 검사\n    const result = validateGalleryForm(formData)\n    if (!result.result) {\n      // 유효성 검사 통과 못할 경우, 에러 토스트 메시지 추가\n      toastManager.addToast('error', result.reason)\n      return\n    }\n\n    ...\n  }\n\n  return (\n    &#x3C;Form className=\"gallery-create-form\" onSubmit={handleSubmit}>\n      &#x3C;Text label=\"전시회 이름\" name=\"name\" initialValue=\"\" />\n      &#x3C;Textarea label=\"소개글\" name=\"content\" initialValue=\"\" maxLen={150} />\n      &#x3C;PlacesRadio placeList={placeList} showSelected={false} />\n      &#x3C;Button type=\"submit\" direction=\"left\" ariaLabel=\"전시회 생성\" text=\"전시회 개관\" />\n    &#x3C;/Form>\n  )\n}\n\nexport default GalleryCreateForm\n\n</code></pre>\n<p><img src=\"/TIL/b124252dd422819ca2f3c02da7bd48b4/toast-manager.gif\" alt=\"클래스형 옵저버 패턴 토스트 메시지 시연\"></p>\n<h1 id=\"참조\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EC%A1%B0\" aria-label=\"참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참조</h1>\n<ul>\n<li><a href=\"https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%EC%98%B5%EC%A0%80%EB%B2%84Observer-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90#:~:text=%EC%98%B5%EC%A0%80%EB%B2%84%20%ED%8C%A8%ED%84%B4(Observer%20Pattern)%EC%9D%80,%EB%A5%BC%20%EC%B7%A8%ED%95%98%EB%8A%94%20%ED%96%89%EB%8F%99%20%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%8B%A4.\">Inpa Dev : \"옵저버(Observer) 패턴 - 완벽 마스터하기\"</a></li>\n<li><a href=\"https://react.dev/reference/react-dom/client/createRoot\">React : \"createRoot\"</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-%EC%98%B5%EC%A0%80%EB%B2%84-%ED%8C%A8%ED%84%B4\">1. 옵저버 패턴</a></p>\n</li>\n<li>\n<p><a href=\"#2-%EC%98%B5%EC%A0%80%EB%B2%84-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84-with-typescript\">2. 옵저버 패턴 구현 with TypeScript</a></p>\n<ul>\n<li><a href=\"#21-%EA%B5%AC%EB%8F%85%EC%9E%90-subscriber\">2.1. 구독자 (Subscriber)</a></li>\n<li><a href=\"#22-%EB%B0%9C%ED%96%89%EC%9E%90-publisher\">2.2. 발행자 (Publisher)</a></li>\n<li><a href=\"#21-%EC%82%AC%EC%9A%A9-%EC%98%88%EC%8B%9C\">2.1. 사용 예시</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-%EC%98%B5%EC%A0%80%EB%B2%84-%ED%8C%A8%ED%84%B4-%ED%99%9C%EC%9A%A9-react\">3. 옵저버 패턴 활용 (React)</a></p>\n<ul>\n<li>\n<p><a href=\"#31-%ED%95%A8%EC%88%98%ED%98%95-react\">3.1. 함수형 React</a></p>\n<ul>\n<li><a href=\"#311-array-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%B6%94%EA%B0%80\">3.1.1. Array 프로토타입 메소드 추가</a></li>\n<li><a href=\"#312-usetoast-%EA%B5%AC%ED%98%84\">3.1.2. useToast 구현</a></li>\n<li><a href=\"#313-%EC%8B%A4%EC%A0%9C-%EC%82%AC%EC%9A%A9\">3.1.3. 실제 사용</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#32-%ED%81%B4%EB%9E%98%EC%8A%A4%ED%98%95-react\">3.2. 클래스형 React</a></p>\n<ul>\n<li><a href=\"#321-array-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%B6%94%EA%B0%80\">3.2.1. Array 프로토타입 메소드 추가</a></li>\n<li><a href=\"#321-%EB%B0%9C%ED%96%89%EC%9E%90-publisher-%EA%B5%AC%ED%98%84\">3.2.1. 발행자 (Publisher) 구현</a></li>\n<li><a href=\"#322-%EC%8B%A4%EC%A0%9C-%EC%82%AC%EC%9A%A9\">3.2.2. 실제 사용</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#4-%EB%8B%A4%EB%A5%B8-%ED%86%A0%EC%8A%A4%ED%8A%B8-%EB%A9%94%EC%8B%9C%EC%A7%80-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9D\">4. 다른 토스트 메시지 구현 방식</a></p>\n<ul>\n<li><a href=\"#41-toast-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\">4.1. Toast 컴포넌트</a></li>\n<li><a href=\"#42-toastmanager-%ED%81%B4%EB%9E%98%EC%8A%A4\">4.2. ToastManager 클래스</a></li>\n<li><a href=\"#42-%EC%8B%A4%EC%A0%9C-%EC%82%AC%EC%9A%A9\">4.2. 실제 사용</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EC%A1%B0\">참조</a></p>\n</li>\n</ul>","frontmatter":{"title":"옵저버(Observer) 패턴 (feat. React TypeScript)","createdAt":"2024-03-06","updatedAt":"2024-03-06","tags":["Design Pattern","디자인 패턴","Observer","옵저버","토스트 메시지"],"description":"옵저버 디자인 패턴을 알아보고, React 프로젝트의 토스트 메시지 구현에 활용해보자","reference":null}},"allMarkdownRemark":{"nodes":[{"id":"465052b6-fc99-5407-a407-8003e014023c","excerpt":"1. 옵저버 패턴  옵저버 패턴은 구조는 위와 같다. 아주 직관적이다. 발행자가 Observer(관측자)를 모아 관리하고, 이벤트가 발생할 때마다 Observer에게 알려준다. 알려주는 방법도 간단하다. 미리 약속된 함수 이름(update…","parent":{"id":"d330b166-77c3-53f1-bf44-2138df9180d1","name":"observer_pattern","relativePath":"Knowledge/Design Pattern/observer_pattern.md"},"frontmatter":{"title":"옵저버(Observer) 패턴 (feat. React TypeScript)","createdAt":"2024-03-06","updatedAt":"2024-03-06"},"fields":{"slug":"/posts/Knowledge/Design Pattern/observer_pattern/"}}]}},"pageContext":{"pagePath":"/posts/Knowledge/Design Pattern/observer_pattern/","siblingPostsPathRegex":"/^(?!.*README).*Knowledge\\/Design Pattern\\/.*$/","relativeDirectory":"Design Pattern","id":"465052b6-fc99-5407-a407-8003e014023c","parent":{"id":"d330b166-77c3-53f1-bf44-2138df9180d1","name":"observer_pattern","relativePath":"Knowledge/Design Pattern/observer_pattern.md"},"fields":{"slug":"/posts/Knowledge/Design Pattern/observer_pattern/"}}},"staticQueryHashes":["24302420","4059933791"],"slicesMap":{}}