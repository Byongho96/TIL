---
title: '4-3. CS 인터뷰: 트랜잭션과 무결성'
updatedAt: '2023-07-06'
createdAt: '2023-07-06'
description: '트랜잭션과 데이터 무결성에 관한 면접 QnA'
tags: ['CS', '면접 대비', '데이터베이스', '트랜잭션', '무결성']
isCompleted: false
reference: '주홍철, 『면접을 위한 CS 전공지식 노트』, 길벗(2023), 4장'
---

## 4.3.1. 트랜잭션

### 트랜잭션이란 무엇인가요?

**트랜잭션은 데이터베이스에서 수행되는 하나의 논리적인 작업 단위를 말합니다.** 데이터베이스에 접근하는 방법은 쿼리이므로, 여러 개의 쿼리들이 하나로 묶여 트랜잭션을 만듭니다. 트랜잭션은 원자성, 일관성, 격리성, 지속성을 만족시켜야 합니다.

### 트랜잭션의 원자성이란 무엇인가요?

트랜잭션의 원자성(Atomicity)은 데이터베이스에서 트랜잭션의 특성 중 하나로, 트랜잭션 내의 모든 연산이 원자적(Atomic)으로 처리되어야 함을 의미합니다. 원자성은 트랜잭션의 모든 작업이 전부 성공하거나 전혀 수행되지 않는다는 원칙을 나타냅니다.

원자성을 가진 트랜잭션은 다음과 같은 특징을 갖습니다:

트랜잭션의 모든 연산은 원자적인 단위로 간주됩니다. 이는 트랜잭션 내의 모든 연산이 일체화되어서 한꺼번에 수행되거나 전혀 수행되지 않는 것을 의미합니다.

트랜잭션 내의 어떤 연산이 실패하면, 이전 상태로 롤백(rollback)되어야 합니다. 즉, 트랜잭션의 모든 변경은 취소되고 이전 상태로 돌아가야 합니다.

트랜잭션이 성공적으로 완료되면, 모든 변경은 영구적으로 저장되어야 합니다. 트랜잭션의 결과는 데이터베이스에 반영되어 지속되어야 합니다.

원자성은 데이터베이스의 무결성과 일관성을 보장하기 위해 중요한 개념입니다. 트랜잭션의 원자성을 유지함으로써, 데이터베이스 시스템은 트랜잭션 실행 도중에 장애가 발생하거나 예외가 발생해도 데이터의 일관성을 유지할 수 있습니다. 원자성은 트랜잭션의 안정성과 신뢰성을 확보하는 데 중요한 역할을 수행합니다.

### 커밋과 롤백이 무엇이지 설명해주세요

커밋(Commit)과 롤백(Rollback)은 트랜잭션(Transaction)의 결과를 제어하는 데 사용되는 개념입니다.

커밋 (Commit):

커밋은 트랜잭션의 작업을 영구적으로 반영하는 작업을 말합니다.
트랜잭션의 모든 연산이 성공적으로 수행되고, 데이터베이스가 일관된 상태에 도달한 후 커밋 작업을 수행합니다.
커밋을 실행하면 트랜잭션의 변경 사항이 데이터베이스에 적용되어 영구적으로 저장됩니다.
커밋 이후에는 트랜잭션의 변경 사항이 영향을 미치며, 다른 트랜잭션에서도 접근할 수 있습니다.
롤백 (Rollback):

롤백은 트랜잭션의 작업을 이전 상태로 복원하는 작업을 말합니다.
트랜잭션 내에서 오류가 발생하거나 명시적인 롤백 명령이 수행되면 롤백 작업이 수행됩니다.
롤백을 실행하면 트랜잭션의 변경 사항이 취소되고, 이전 상태로 데이터베이스가 복원됩니다.
롤백 이후에는 트랜잭션의 변경 사항은 취소되므로, 다른 트랜잭션에서는 해당 변경 사항을 볼 수 없습니다.

커밋과 롤백은 트랜잭션의 원자성과 데이터베이스의 일관성을 보장하기 위해 사용됩니다. 성공적으로 수행된 트랜잭션은 커밋하여 변경 사항을 영구적으로 저장하고, 실패한 트랜잭션은 롤백하여 이전 상태로 복원함으로써 데이터의 일관성을 유지합니다. 커밋과 롤백은 데이터베이스 시스템에서 트랜잭션의 결과를 관리하고, 장애 또는 예외 상황에서 데이터의 무결성을 보장하는 데 중요한 역할을 합니다.

### 트랜잭션 전파에 대해 설명해주세요

### 트랜잭션의 일관성이란 무엇인가요?

트랜잭션의 일관성(Consistency)은 데이터베이스에서 트랜잭션의 특성 중 하나로, 트랜잭션이 실행되는 동안 데이터베이스의 일관된 상태를 유지해야 함을 의미합니다. 즉, 트랜잭션이 실행되기 전과 실행된 후의 데이터베이스 상태가 일관성을 유지해야 합니다.

트랜잭션의 일관성은 다음과 같은 특징을 갖습니다:

데이터베이스의 일관성 규칙을 준수해야 합니다. 데이터베이스에는 정의된 일관성 규칙이 있으며, 트랜잭션은 이러한 규칙을 준수해야 합니다. 예를 들어, 정해진 제약 조건이나 규칙에 따라 데이터의 무결성을 유지해야 합니다.

트랜잭션이 데이터베이스를 변경하는 동안, 데이터베이스는 항상 유효한 상태를 유지해야 합니다. 트랜잭션이 실행되면 데이터베이스는 일시적으로 변화하지만, 트랜잭션이 성공적으로 완료된 후에는 데이터베이스가 다시 유효하고 일관된 상태로 돌아와야 합니다.

트랜잭션은 일관성 있는 방식으로 데이터를 읽고 수정해야 합니다. 트랜잭션이 읽는 데이터는 트랜잭션이 시작될 때의 데이터 상태와 일치해야 하며, 수정하는 데이터는 다른 트랜잭션에 의해 동시에 수정되지 않아야 합니다.

트랜잭션의 일관성은 데이터베이스 시스템의 무결성을 보장하고 데이터의 일관성을 유지하기 위해 중요한 개념입니다. 트랜잭션이 일관성을 지키지 않을 경우, 데이터의 무결성이 깨질 수 있고 데이터베이스의 불일치가 발생할 수 있습니다. 따라서 트랜잭션은 일관성을 유지하고 데이터베이스의 일관된 상태를 보장하기 위해 적절한 제어와 처리가 필요합니다.

### 트랜잭션의 격리성이란 무엇인가요?

트랜잭션의 격리성(Isolation)은 동시에 실행 중인 여러 개의 트랜잭션이 서로에게 영향을 미치지 않고 독립적으로 실행되는 특성을 말합니다. 격리성은 동시성 제어(Concurrency Control)의 한 측면으로, 다른 트랜잭션의 작업이 현재 실행 중인 트랜잭션에 영향을 미치지 않도록 보장합니다.

트랜잭션의 격리성은 다음과 같은 특징을 갖습니다:

동시성 문제 방지: 격리성은 동시에 실행되는 여러 트랜잭션 간에 발생할 수 있는 다양한 동시성 문제를 방지합니다. 예를 들어, 더티 읽기(Dirty Read), 반복 가능한 읽기(Non-Repeatable Read), 팬텀 읽기(Phantom Read) 등의 문제를 해결합니다.

격리 수준(Isolation Level): 격리성은 격리 수준(Isolation Level)을 통해 설정됩니다. 격리 수준은 동시에 실행되는 트랜잭션 사이에서 어느 정도의 격리를 유지할지를 결정합니다. 대표적인 격리 수준으로는 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE 등이 있습니다.

동시성 제어 메커니즘: 격리성은 동시성 제어 메커니즘을 사용하여 구현됩니다. 동시성 제어 메커니즘은 트랜잭션의 읽기 및 쓰기 연산을 조율하고, 여러 트랜잭션이 동시에 실행되더라도 데이터의 일관성과 무결성을 유지할 수 있도록 합니다.

격리성은 동시성 문제를 방지하고 데이터의 일관성을 보장하는 중요한 개념입니다. 적절한 격리 수준을 선택하고 동시성 제어 메커니즘을 구현하여 트랜잭션의 격리성을 유지함으로써 데이터베이스 시스템의 안정성과 신뢰성을 보장할 수 있습니다.

### 트랜잭션의 격리수준의 종류를 설명해주세요

트랜잭션의 격리 수준(Isolation Level)은 동시에 실행되는 여러 개의 트랜잭션이 서로에게 어떤 수준의 격리를 유지할지를 결정하는 개념입니다. 격리 수준은 동시성 제어를 통해 트랜잭션 간의 상호작용을 제어하고, 동시성 문제를 방지하여 데이터의 일관성과 무결성을 보장합니다.

주요한 격리 수준은 다음과 같습니다:

READ UNCOMMITTED:

가장 낮은 격리 수준이며, 트랜잭션의 변경 사항이 COMMIT되지 않아도 다른 트랜잭션에서 읽을 수 있습니다.
Dirty Read(더티 읽기) 문제가 발생할 수 있어 일관성과 격리성이 보장되지 않습니다.
READ COMMITTED:

트랜잭션이 COMMIT된 데이터만 다른 트랜잭션에서 읽을 수 있습니다.
Dirty Read는 방지되지만 Non-Repeatable Read(반복 불가능한 읽기) 문제가 발생할 수 있습니다.
REPEATABLE READ:

트랜잭션이 읽은 데이터를 일정 시간 동안 유지하여, 같은 트랜잭션에서 반복해서 같은 결과를 얻을 수 있습니다.
Non-Repeatable Read는 방지되지만 Phantom Read(팬텀 읽기) 문제가 발생할 수 있습니다.
SERIALIZABLE:

가장 높은 격리 수준이며, 트랜잭션들이 순차적으로 실행되는 것처럼 처리됩니다.
Dirty Read, Non-Repeatable Read, Phantom Read 모두 방지됩니다.
각 격리 수준은 일관성과 동시성 간의 트레이드오프를 가지고 있습니다. 격리 수준이 높을수록 동시성 문제는 해결되지만, 동시성이 제한될 수 있습니다. 격리 수준은 데이터베이스 시스템의 설정 또는 트랜잭션의 옵션으로 지정되며, 적절한 격리 수준을 선택하여 데이터 일관성과 동시성 요구사항을 충족시킬 수 있어야 합니다.

### 트랜잭션의 격리수준에 따라 발생하는 현상을 설명해주세요

Dirty Read, Non-Repeatable Read, Phantom Read는 동시성 제어와 관련된 문제들로, 다른 트랜잭션들이 데이터를 변경하는 동안 발생할 수 있는 현상을 나타냅니다. 각각의 현상을 설명해보겠습니다:

Dirty Read (더티 읽기):

Dirty Read는 하나의 트랜잭션이 아직 커밋되지 않은 다른 트랜잭션의 변경 사항을 읽는 현상을 말합니다.
예를 들어, 트랜잭션 A가 데이터를 수정하고 있지만 아직 커밋되지 않은 상태에서 트랜잭션 B가 해당 데이터를 읽는 경우, 트랜잭션 B는 임시로 변경된 데이터를 읽게 됩니다.
그러나 트랜잭션 A가 롤백되면 트랜잭션 B는 잘못된 데이터를 읽게 됩니다.
Non-Repeatable Read (반복 불가능한 읽기):

Non-Repeatable Read는 한 트랜잭션이 동일한 쿼리를 반복 실행할 때 다른 트랜잭션에 의해 데이터가 변경되어 이전과 다른 결과를 얻는 현상을 말합니다.
예를 들어, 트랜잭션 A가 특정 행을 읽은 후, 트랜잭션 B가 해당 행을 수정 또는 삭제한 경우, 트랜잭션 A가 같은 쿼리를 다시 실행하면 이전에 읽은 것과 다른 결과를 얻을 수 있습니다.
Phantom Read (팬텀 읽기):

Phantom Read는 한 트랜잭션이 범위를 조회하는 도중 다른 트랜잭션이 해당 범위에 새로운 행을 추가하거나 삭제하여 이전과 다른 결과를 얻는 현상을 말합니다.
예를 들어, 트랜잭션 A가 범위 내의 행을 조회하고 있을 때, 트랜잭션 B가 새로운 행을 추가하면 트랜잭션 A가 다시 같은 범위를 조회하면 새로운 행이 포함된 결과를 얻을 수 있습니다.

다양한 격리 수준(Isolation Level)에 따라 다른 현상이 발생할 수 있습니다. 다음은 주요 격리 수준에 따른 현상들을 설명합니다:

READ UNCOMMITTED:

Dirty Read (더티 읽기): 다른 트랜잭션이 커밋하지 않은 변경 사항을 읽을 수 있습니다. 다른 트랜잭션이 롤백되면 읽은 데이터가 잘못된 데이터일 수 있습니다.
READ COMMITTED:

Dirty Read는 방지됩니다. 다른 트랜잭션이 커밋하지 않은 변경 사항은 읽을 수 없습니다. 하지만 같은 트랜잭션 내에서 동일한 쿼리를 반복 실행할 때 Non-Repeatable Read 문제가 발생할 수 있습니다. 동일한 행을 여러 번 읽을 때 각 읽기에서 다른 값을 얻을 수 있습니다.
REPEATABLE READ:

Non-Repeatable Read: 같은 쿼리를 반복 실행할 때 다른 트랜잭션이 해당 행을 수정 또는 삭제할 수 있으므로 이전과 다른 결과를 얻을 수 있습니다. 하지만 한 트랜잭션 내에서는 같은 쿼리를 반복 실행하더라도 항상 같은 결과를 얻을 수 있습니다.
Phantom Read (팬텀 읽기): 한 트랜잭션이 범위를 조회할 때, 다른 트랜잭션에서 해당 범위에 새로운 행을 추가하거나 삭제할 경우, 이전과 다른 결과를 얻을 수 있습니다.
SERIALIZABLE:

SERIALIZABLE 격리 수준은 가장 높은 격리 수준입니다. 동시성 문제는 해결되지만, 동시에 실행되는 트랜잭션이 순차적으로 처리되기 때문에 동시성이 크게 제한됩니다. Dirty Read, Non-Repeatable Read, Phantom Read는 모두 방지됩니다.
각 격리 수준은 동시성과 일관성 사이의 트레이드오프를 나타냅니다. 더 높은 격리 수준은 데이터 일관성을 유지하기 위해 동시성을 제한할 수 있지만, 동시성을 높이기 위해서는 일관성에 대한 제약이 발생할 수 있습니다. 따라서 적절한 격리 수준을 선택하여 데이터 일관성과 동시성 요구사항을 조절해야 합니다.

### 트랜잭션의 지속성이란 무엇인가요?

트랜잭션의 지속성(Durability)은 데이터베이스 시스템에서 트랜잭션의 성공적인 완료 후에 변경된 데이터가 영구적으로 보존되는 특성을 의미합니다. 즉, 트랜잭션이 커밋되면 해당 트랜잭션의 결과가 영구적으로 저장되어야 함을 나타냅니다.

트랜잭션의 지속성은 다음과 같은 특징을 갖습니다:

영구적인 저장: 트랜잭션이 커밋되면, 해당 트랜잭션에서 수행한 변경 사항은 영구적으로 데이터베이스에 저장되어야 합니다. 이는 시스템 장애나 중단이 발생해도 데이터의 지속성을 보장합니다.

로그 기록: 데이터베이스 시스템은 트랜잭션 실행 과정에서 로그를 유지합니다. 로그는 트랜잭션의 연산과 변경 사항을 기록하여, 장애가 발생하거나 시스템이 복구되어야 할 때 변경 사항을 재실행하거나 롤백할 수 있게 합니다.

영구적인 저장 장치: 변경된 데이터는 일반적으로 영구적인 저장 장치인 디스크에 기록됩니다. 디스크는 일시적인 전원 손실이나 시스템 장애에도 데이터를 안정적으로 보관할 수 있는 특성을 가지고 있습니다.

트랜잭션의 지속성은 데이터베이스 시스템의 신뢰성과 내구성을 보장하는 중요한 개념입니다. 트랜잭션이 지속성을 가지지 않는다면, 시스템 장애 또는 중단 시에 데이터의 일관성과 무결성이 손실될 수 있습니다. 따라서 데이터베이스 시스템은 트랜잭션의 지속성을 보장하기 위해 적절한 로깅 및 저장 메커니즘을 구현하고 데이터의 안정성을 유지해야 합니다.ㄴ

## 4.3.3. 무결성

### 데이터의 무결성이 무엇이고, 그 종류에 대해 설명해주세요

데이터의 무결성(Integrity)은 데이터베이스에서 데이터의 정확성, 일관성, 유효성을 유지하는 것을 의미합니다. 데이터의 무결성은 데이터베이스 시스템이 정의된 규칙과 제약 조건을 준수하며, 데이터의 무결성을 유지하고 보장하는 것이 중요합니다.

데이터의 무결성은 다음과 같은 종류로 구분됩니다:

개체 무결성(Entity Integrity):

개체 무결성은 기본 키(primary key)의 유일성과 NULL 값의 제약을 보장합니다.
기본 키는 각 행을 고유하게 식별하는 역할을 수행하며, 중복된 값이나 NULL 값은 허용되지 않습니다.
참조 무결성(Referential Integrity):

참조 무결성은 관계형 데이터베이스에서 관계를 유지하고 참조 무결성 제약 조건을 준수하는 것을 의미합니다.
참조 무결성은 외래 키(foreign key)와 관련이 있으며, 외래 키는 참조하는 테이블의 기본 키와 일치하거나 NULL 값을 가져야 합니다.
도메인 무결성(Domain Integrity):

도메인 무결성은 각 속성(attribute)이 정의된 도메인에 속하는 값만 가질 수 있도록 하는 것을 의미합니다.
속성은 데이터의 유형(type)과 제약 조건에 따라 특정 도메인에 속하는 값을 가져야 합니다.
키 무결성(Key Integrity):

키 무결성은 기본 키와 대체 키(alternate key)에 대한 제약 조건을 보장합니다.
기본 키는 테이블에서 튜플(tuple)을 고유하게 식별하고 대체 키는 특정 속성이 기본 키로 사용될 수 없음을 보장합니다.
도메인 종속성(Domain Dependency):

도메인 종속성은 속성 간의 종속 관계를 정의하고 유지하는 것을 의미합니다.
도메인 종속성은 한 속성의 값이 다른 속성의 값에 종속되어야 함을 나타냅니다.
데이터의 무결성을 보장하기 위해 데이터베이스 시스템은 데이터의 무결성을 유지하기 위한 제약 조건, 규칙, 검증 메커니즘을 구현합니다. 이를 통해 데이터의 정확성과 일관성을 유지하고 데이터베이스의
