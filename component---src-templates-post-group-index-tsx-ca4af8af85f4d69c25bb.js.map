{"version":3,"file":"component---src-templates-post-group-index-tsx-ca4af8af85f4d69c25bb.js","mappings":"2IAwBA,IApB2BA,IAAe,IAAd,KAAEC,GAAM,EAClC,MAAM,GAAEC,EAAE,OAAEC,EAAM,YAAEC,EAAW,QAAEC,GAAYJ,GACvC,KAAEK,EAAI,aAAEC,GAAiBJ,GACzB,MAAEK,EAAK,UAAEC,GAAcL,EAM7B,OACEM,EAAAA,cAAAA,UAAAA,CAASC,UAAU,YAAYC,QALbC,MAClBC,EAAAA,EAAAA,UAAS,UAAUP,EAAe,GAKhCG,EAAAA,cAAAA,MAAAA,CAAKC,UAAU,mBACbD,EAAAA,cAAAA,KAAAA,CAAIC,UAAU,oBAAoBH,GAASF,GAC3CI,EAAAA,cAAAA,OAAAA,CAAMC,UAAU,mBAAmBF,IAErCC,EAAAA,cAAAA,IAAAA,CAAGC,UAAU,sBAAsBN,GAC3B,C,oCCmEd,IA5EuCL,IAMhC,IANiC,QACtCe,EAAO,MACPC,EAAQ,EAAC,MACTC,EAAQ,CAAC,EAAC,MACVC,EAAQ,IAAI,WACZC,GAAa,GACd,EACC,MAAMC,GAAiBC,EAAAA,EAAAA,QAAwB,MAgE/C,OA9DAC,EAAAA,EAAAA,YAAU,KACR,MAAMC,EAAcH,EAAeI,QAEnC,IAAKD,EAAa,OAElBA,EAAYE,YAAc,GAE1B,IAAIC,EAAY,EACZC,EAAU,EACVC,EAAW,KAGf,SAASC,IACPN,EAAYN,MAAMa,YAAY,mBAAoB,GAClD,MAAMC,EAAgBhB,EAAQW,GAG9B,GAAIC,EAAUI,EAAcC,OAC1BT,EAAYE,aAAeM,EAAcJ,SAD3C,CAKA,GAAID,EAAYX,EAAQiB,OAAS,EAI/B,OAHAN,IACAC,EAAU,OACVM,IAIF,GAAId,EAIF,OAHAO,EAAY,EACZC,EAAU,OACVM,IAIFV,EAAYN,MAAMa,YAAY,mBAAoB,GAClDF,GAAYM,cAAcN,EAjB1B,CAkBF,CAGA,SAASK,IACPV,EAAYN,MAAMa,YAAY,mBAAoB,GAClDF,GAAYM,cAAcN,GAG1BO,YAAW,KACTZ,EAAYa,UAAY,GACxBR,EAAWS,YAAYR,EAAU,IAAOb,EAAM,GAC7CE,EACL,CAMA,OAHAU,EAAWS,YAAYR,EAAU,IAAOb,GAGjC,KACLsB,QAAQC,IAAI,WAAYX,GACxBA,GAAYM,cAAcN,EAAS,CACpC,GACA,CAACb,EAASC,EAAOE,EAAOC,IAGzBT,EAAAA,cAAAA,OAAAA,CAAM8B,IAAKpB,EAAgBT,UAAU,iBAAiBM,MAAOA,GAAc,C,qHC3B/E,UA/C2CjB,IAA2B,IAA1B,YAAEyC,EAAW,KAAEC,GAAM,EAC/D,OACEhC,EAAAA,cAACiC,EAAAA,EAAc,CAACC,gBAAiBH,EAAYnC,MAC3CI,EAAAA,cAAAA,OAAAA,CAAMC,UAAU,sBACdD,EAAAA,cAAAA,MAAAA,CAAKC,UAAU,wBACbD,EAAAA,cAACmC,EAAAA,EAAa,CAAC9B,QAAS,CAAC0B,EAAYnC,SAEvCI,EAAAA,cAAAA,UAAAA,CAASC,UAAU,yBAChB+B,EAAKI,kBAAkBC,MAAMC,KAAK/C,GACjCS,EAAAA,cAACuC,EAAAA,EAAQ,CAACC,IAAKjD,EAAKC,GAAID,KAAMA,QAIpCS,EAAAA,cAACyC,EAAAA,EAAQ,MACM,EAmCd,MAAMC,EAAeA,IAAM1C,EAAAA,cAAAA,QAAAA,KAAO,kB","sources":["webpack://byongho-s-til/./src/components/post-item/index.tsx","webpack://byongho-s-til/./src/components/type-animation/index.tsx","webpack://byongho-s-til/./src/templates/post-group/index.tsx"],"sourcesContent":["import * as React from 'react'\nimport './style.scss'\nimport { navigate } from 'gatsby'\n\nconst PostItem: React.FC = ({ node }) => {\n  const { id, parent, frontmatter, excerpt } = node\n  const { name, relativePath } = parent\n  const { title, createdAt } = frontmatter\n\n  const handleClick = () => {\n    navigate(`/posts/${relativePath}`)\n  }\n\n  return (\n    <article className=\"post-item\" onClick={handleClick}>\n      <div className=\"post-item--flex\">\n        <h1 className=\"post-item__title\">{title || name}</h1>\n        <span className=\"post-item__date\">{createdAt}</span>\n      </div>\n      <p className=\"post-item__excerpt\">{excerpt}</p>\n    </article>\n  )\n}\n\nexport default PostItem\n","import React, { useRef, useEffect } from 'react'\nimport './style.scss'\n\ntype Props = {\n  phrases: string[] // 순서대로 타이핑 할 문구 리스트\n  speed?: number // 타이핑 속도\n  style?: object // 인라인 스타일 객체\n  pause?: number // 한 개의 텍스트가 완성되고, 다음 텍스트가 타이핑 되기 전 대기시간\n  isInfinite?: boolean // 타이핑 무한 반복 여부\n}\n\nconst TypeAnimation: React.FC<Props> = ({\n  phrases,\n  speed = 5,\n  style = {},\n  pause = 2000, // 기본 대기 시간 2초\n  isInfinite = false,\n}) => {\n  const textElementRef = useRef<HTMLSpanElement>(null)\n\n  useEffect(() => {\n    const textElement = textElementRef.current // 타이핑을 입력한 타겟 Element\n\n    if (!textElement) return\n\n    textElement.textContent = ''\n\n    let phraseIdx = 0 // 현재 타이핑하는 문구의 인덱스\n    let charIdx = 0 // 현재 타이핑하는 글자 인덱스\n    let interval = null // setInterval을 담을 변수\n\n    // 2. 타이핑 메인 함수\n    function typeText() {\n      textElement.style.setProperty('--cursor-opacity', 1) // 타이핑 하는 동안은 커서 깜빡이지 않도록\n      const currentPhrase = phrases[phraseIdx] // 현재 타이핑하는 문구\n\n      // 현재 문구 타이핑이 안 끝났을 경우\n      if (charIdx < currentPhrase.length) {\n        textElement.textContent += currentPhrase[charIdx++] // innerText 대신 textContent 사용해야 공백을 담을 수 있음\n        return\n      }\n      // 현재 문구가 마지막 문구가 아닐 경우\n      if (phraseIdx < phrases.length - 1) {\n        phraseIdx++ // 다음 문구로 이동\n        charIdx = 0 // 첫 번째 글자로 이동\n        retypeAfterPause()\n        return\n      }\n      // 무한 반복이 설정되어 있을 경우\n      if (isInfinite) {\n        phraseIdx = 0 // 처음 문구로 이동\n        charIdx = 0 // 첫 번재 글자로 이동\n        retypeAfterPause()\n        return\n      }\n      // 타이핑 종료\n      textElement.style.setProperty('--cursor-opacity', 0) // 타이핑 종료 후 커서 깜빡이도록\n      interval && clearInterval(interval)\n    }\n\n    // 3. 일시 정지 후, 문구 초기화한 뒤 타이핑 재시작하는 함수\n    function retypeAfterPause() {\n      textElement.style.setProperty('--cursor-opacity', 0) // 이리 정지하는 동안 커서 깜빡이도록\n      interval && clearInterval(interval) // 기존 setInterval 제거\n\n      // pause 이 후, setInterval 재시작\n      setTimeout(() => {\n        textElement.innerText = '' // 문구 초기화\n        interval = setInterval(typeText, 1000 / speed)\n      }, pause)\n    }\n\n    // 1. setInterval로 타이핑 시작\n    interval = setInterval(typeText, 1000 / speed)\n\n    // clear 함수\n    return () => {\n      console.log('interval', interval)\n      interval && clearInterval(interval)\n    }\n  }, [phrases, speed, pause, isInfinite])\n\n  return (\n    <span ref={textElementRef} className=\"type-animation\" style={style}></span>\n  )\n}\n\nexport default TypeAnimation\n","import * as React from 'react'\nimport './style.scss'\nimport type { HeadFC, PageProps } from 'gatsby'\nimport { graphql } from 'gatsby'\nimport PostItem from '@components/post-item'\nimport ToTheTop from '@components/to-the-top'\nimport TypeAnimation from '@components/type-animation'\nimport CategoryLayout from '@layouts/category-layout'\n\nconst PostGroupPage: React.FC<PageProps> = ({ pageContext, data }) => {\n  return (\n    <CategoryLayout defaultCategory={pageContext.name}>\n      <main className=\"post-group--layout\">\n        <div className=\"post-group__category\">\n          <TypeAnimation phrases={[pageContext.name]} />\n        </div>\n        <section className=\"post-group__post-list\">\n          {data.allMarkdownRemark.nodes.map((node) => (\n            <PostItem key={node.id} node={node} />\n          ))}\n        </section>\n      </main>\n      <ToTheTop />\n    </CategoryLayout>\n  )\n}\n\nexport const query = graphql`\n  query ($regex: String!) {\n    allMarkdownRemark(\n      filter: {\n        frontmatter: { isCompleted: { eq: true } }\n        fileAbsolutePath: { regex: $regex }\n      }\n      sort: { frontmatter: { title: ASC } }\n    ) {\n      nodes {\n        id\n        parent {\n          ... on File {\n            id\n            name\n            relativePath\n          }\n        }\n        frontmatter {\n          title\n          createdAt\n          updatedAt\n        }\n        excerpt\n      }\n    }\n  }\n`\n\nexport default PostGroupPage\n\nexport const Head: HeadFC = () => <title>Post Group Page</title>\n"],"names":["_ref","node","id","parent","frontmatter","excerpt","name","relativePath","title","createdAt","React","className","onClick","handleClick","navigate","phrases","speed","style","pause","isInfinite","textElementRef","useRef","useEffect","textElement","current","textContent","phraseIdx","charIdx","interval","typeText","setProperty","currentPhrase","length","retypeAfterPause","clearInterval","setTimeout","innerText","setInterval","console","log","ref","pageContext","data","CategoryLayout","defaultCategory","TypeAnimation","allMarkdownRemark","nodes","map","PostItem","key","ToTheTop","Head"],"sourceRoot":""}