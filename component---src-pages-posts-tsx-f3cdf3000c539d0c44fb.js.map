{"version":3,"file":"component---src-pages-posts-tsx-f3cdf3000c539d0c44fb.js","mappings":"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","sources":["webpack://byongho-s-til/./src/components/post-item/index.tsx","webpack://byongho-s-til/./src/components/type-animation/index.tsx","webpack://byongho-s-til/./src/hooks/use-infinite-scroll.tsx","webpack://byongho-s-til/./src/pages/posts.tsx"],"sourcesContent":["import * as React from 'react'\nimport './style.scss'\nimport { Link } from 'gatsby'\n\ninterface Props {\n  node: {\n    id: string\n    excerpt: string\n    parent: {\n      name: string\n      relativePath: string\n    }\n    frontmatter: {\n      title: string\n      createdAt: string\n    }\n  }\n}\n\nconst PostItem: React.FC<Props> = ({ node }) => {\n  const { parent, frontmatter, excerpt } = node\n  const { name, relativePath } = parent\n  const { title, createdAt } = frontmatter\n\n  return (\n    <article className=\"post-item\">\n      <Link to={`/posts/${relativePath}`}>\n        <div className=\"post-item--flex\">\n          <h1 className=\"post-item__title\">{title || name}</h1>\n          <span className=\"post-item__date\">{createdAt}</span>\n        </div>\n        <p className=\"post-item__excerpt\">{excerpt}</p>\n      </Link>\n    </article>\n  )\n}\n\nexport default PostItem\n","import React, { useRef, useEffect } from 'react'\nimport './style.scss'\n\ntype Props = {\n  phrases: string[] // 순서대로 타이핑 할 문구 리스트\n  speed?: number // 타이핑 속도\n  style?: object // 인라인 스타일 객체\n  pause?: number // 한 개의 텍스트가 완성되고, 다음 텍스트가 타이핑 되기 전 대기시간\n  isInfinite?: boolean // 타이핑 무한 반복 여부\n}\n\nconst TypeAnimation: React.FC<Props> = ({\n  phrases,\n  speed = 5,\n  style = {},\n  pause = 2000, // 기본 대기 시간 2초\n  isInfinite = false,\n}) => {\n  const textElementRef = useRef<HTMLParagraphElement>(null)\n\n  useEffect(() => {\n    const textElement = textElementRef.current // 타이핑을 입력한 타겟 Element\n\n    if (!(textElement instanceof HTMLParagraphElement)) return\n\n    textElement.textContent = ''\n\n    let phraseIdx = 0 // 현재 타이핑하는 문구의 인덱스\n    let charIdx = 0 // 현재 타이핑하는 글자 인덱스\n    let interval: number = null // setInterval을 담을 변수\n\n    // 2. 타이핑 메인 함수\n    function typeText() {\n      textElement.style.setProperty('--cursor-opacity', 1) // 타이핑 하는 동안은 커서 깜빡이지 않도록\n      const currentPhrase = phrases[phraseIdx] // 현재 타이핑하는 문구\n\n      // 현재 문구 타이핑이 안 끝났을 경우\n      if (charIdx < currentPhrase.length) {\n        textElement.textContent += currentPhrase[charIdx++] // innerText 대신 textContent 사용해야 공백을 담을 수 있음\n        return\n      }\n      // 현재 문구가 마지막 문구가 아닐 경우\n      if (phraseIdx < phrases.length - 1) {\n        phraseIdx++ // 다음 문구로 이동\n        charIdx = 0 // 첫 번째 글자로 이동\n        retypeAfterPause()\n        return\n      }\n      // 무한 반복이 설정되어 있을 경우\n      if (isInfinite) {\n        phraseIdx = 0 // 처음 문구로 이동\n        charIdx = 0 // 첫 번재 글자로 이동\n        retypeAfterPause()\n        return\n      }\n      // 타이핑 종료\n      textElement.style.setProperty('--cursor-opacity', 0) // 타이핑 종료 후 커서 깜빡이도록\n      interval && clearInterval(interval)\n    }\n\n    // 3. 일시 정지 후, 문구 초기화한 뒤 타이핑 재시작하는 함수\n    function retypeAfterPause() {\n      textElement.style.setProperty('--cursor-opacity', 0) // 이리 정지하는 동안 커서 깜빡이도록\n      interval && clearInterval(interval) // 기존 setInterval 제거\n\n      // pause 이 후, setInterval 재시작\n      setTimeout(() => {\n        textElement.innerText = '' // 문구 초기화\n        interval = setInterval(typeText, 1000 / speed)\n      }, pause)\n    }\n\n    // 1. setInterval로 타이핑 시작\n    interval = setInterval(typeText, 1000 / speed)\n\n    // clear 함수\n    return () => {\n      interval && clearInterval(interval)\n    }\n  }, [phrases, speed, pause, isInfinite])\n\n  return <p ref={textElementRef} className=\"type-animation\" style={style}></p>\n}\n\nexport default TypeAnimation\n","import { useEffect, RefObject } from 'react'\n\n/*\n무한스크롤 커스텀 훅\n특정 DOM요소를 ref로 받은 뒤,\n해당 요소의 마지막으로 스크롤이 닿았을 때, loadMore 함수(api 요청하는 비동기 함수) 실행\n*/\n\ntype InfiniteScrollProps = {\n  ref: RefObject<HTMLElement> // 무한스크롤이 동작할 DOM 엘리먼트를 ref로 받음\n  isEnd: boolean // 더이상 로드할 데이터가 없을 때, true로 설정\n  loadMore: () => void // 컨텐츠를 로드할 함수\n}\n\nfunction useInfiniteScroll({\n  ref,\n  isEnd,\n  loadMore,\n}: InfiniteScrollProps): InfiniteScrollReturns {\n  // 스크롤 이벤트 감지 함수\n\n  useEffect(() => {\n    const element = ref.current // 무한스크롤이 동작할 DOM 엘리먼트\n\n    if (!(element instanceof HTMLElement) || !isEnd) return //element가 null일 경우, 함수 종료\n\n    const handleScroll = () => {\n      const element = ref.current ? ref.current : document.documentElement\n      const THRESHOLD = 5\n\n      const { scrollTop, scrollHeight, clientHeight } = element // 엘리먼트의 스크롤 정보\n      if (scrollHeight - scrollTop - clientHeight > THRESHOLD) return\n\n      loadMore()\n    }\n\n    window.addEventListener('scroll', handleScroll) // element에 스크롤 이베트 감지함수 부착\n    // cleanup 함수\n    return () => {\n      window.removeEventListener('scroll', handleScroll)\n    }\n  }, [ref, isEnd, loadMore])\n}\n\nexport default useInfiniteScroll\n","import React, { useState, useMemo, useRef } from 'react'\nimport './posts.scss'\nimport type { PageProps } from 'gatsby'\nimport { graphql } from 'gatsby'\nimport PostItem from '@components/post-item'\nimport SEO from '@components/seo'\nimport ToTheTop from '@components/to-the-top'\nimport TypeAnimation from '@components/type-animation'\nimport useInfiniteScroll from '@hooks/use-infinite-scroll'\nimport CategoryLayout from '@layouts/category-layout'\n\ntype MarkdownRemarkNode = {\n  id: string\n  excerpt: string\n  parent: {\n    id: string\n    name: string\n    relativePath: string\n  }\n  frontmatter: {\n    title: string\n    createdAt: string\n    updatedAt: string\n  }\n}\n\ntype DataProps = {\n  allMarkdownRemark: {\n    nodes: MarkdownRemarkNode[]\n  }\n}\n\nconst PostsPage: React.FC<PageProps<DataProps>> = ({ data }) => {\n  const [lastIdx, setLastIdx] = useState(20)\n  const infiniteRef = useRef<HTMLElement>(null)\n\n  const shownData = useMemo(() => {\n    return data.allMarkdownRemark.nodes.slice(0, lastIdx + 1)\n  }, [lastIdx])\n\n  const isEnd = useMemo(() => {\n    return lastIdx >= data.allMarkdownRemark.nodes.length - 1\n  }, [lastIdx])\n\n  const loadMore = () => {\n    setLastIdx((prev) => prev + 20)\n  }\n\n  useInfiniteScroll({ ref: infiniteRef, isEnd, loadMore })\n\n  return (\n    <CategoryLayout>\n      <main className=\"posts--layout\">\n        <div className=\"posts__category-name\">\n          <TypeAnimation phrases={['All the Posts']} />\n        </div>\n        <ul className=\"posts__post-list\">\n          {shownData.map((node) => (\n            <li>\n              <PostItem key={node.id} node={node} />\n            </li>\n          ))}\n        </ul>\n      </main>\n      <ToTheTop />\n    </CategoryLayout>\n  )\n}\n\nexport const query = graphql`\n  query PostsPageQuery {\n    allMarkdownRemark(\n      filter: {\n        frontmatter: { isCompleted: { eq: true } }\n        fileAbsolutePath: { regex: \"/^(?!.*README).*posts.*$/\" }\n      }\n      sort: [\n        { frontmatter: { createdAt: DESC } }\n        { frontmatter: { title: DESC } }\n      ]\n    ) {\n      nodes {\n        id\n        parent {\n          ... on File {\n            id\n            name\n            relativePath\n          }\n        }\n        frontmatter {\n          title\n          createdAt\n          updatedAt\n        }\n        excerpt\n      }\n    }\n  }\n`\n\nexport default PostsPage\n\nexport const Head = () => (\n  <SEO title=\"Posts Page\" decription=\"All the TIL posts\" pathname=\"/posts\" />\n)\n"],"names":["_ref","node","parent","frontmatter","excerpt","name","relativePath","title","createdAt","React","className","Link","to","phrases","speed","style","pause","isInfinite","textElementRef","useRef","useEffect","textElement","current","HTMLParagraphElement","textContent","phraseIdx","charIdx","interval","typeText","setProperty","currentPhrase","length","retypeAfterPause","clearInterval","setTimeout","innerText","setInterval","ref","isEnd","loadMore","HTMLElement","handleScroll","element","document","documentElement","scrollTop","scrollHeight","clientHeight","window","addEventListener","removeEventListener","data","lastIdx","setLastIdx","useState","infiniteRef","shownData","useMemo","allMarkdownRemark","nodes","slice","useInfiniteScroll","prev","CategoryLayout","TypeAnimation","map","PostItem","key","id","ToTheTop","Head","SEO","decription","pathname"],"sourceRoot":""}